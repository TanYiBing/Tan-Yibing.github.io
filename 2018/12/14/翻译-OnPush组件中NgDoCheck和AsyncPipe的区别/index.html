<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别 | Ice Panpan&#39;s blog | Tan Yibing&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Angular">
    <meta name="description" content="[翻译] OnPush 组件中 NgDoCheck 和 AsyncPipe 的区别 原文：The difference between NgDoCheck and AsyncPipe in OnPush components作者：Max Koretskyi原技术博文由 Max Koretskyi 撰写发布，他目前于 ag-Grid 担任开发者职位   译者：Ice Panpan">
<meta name="keywords" content="Angular">
<meta property="og:type" content="article">
<meta property="og:title" content="[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别">
<meta property="og:url" content="http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/index.html">
<meta property="og:site_name" content="Ice Panpan&#39;s blog">
<meta property="og:description" content="[翻译] OnPush 组件中 NgDoCheck 和 AsyncPipe 的区别 原文：The difference between NgDoCheck and AsyncPipe in OnPush components作者：Max Koretskyi原技术博文由 Max Koretskyi 撰写发布，他目前于 ag-Grid 担任开发者职位   译者：Ice Panpan">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://tanyibing.com/img/rxjs/1.jpeg">
<meta property="og:updated_time" content="2018-12-14T14:02:36.941Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别">
<meta name="twitter:description" content="[翻译] OnPush 组件中 NgDoCheck 和 AsyncPipe 的区别 原文：The difference between NgDoCheck and AsyncPipe in OnPush components作者：Max Koretskyi原技术博文由 Max Koretskyi 撰写发布，他目前于 ag-Grid 担任开发者职位   译者：Ice Panpan">
<meta name="twitter:image" content="http://tanyibing.com/img/rxjs/1.jpeg">
    
        <link rel="alternate" type="application/atom+xml" title="Ice Panpan&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar_before.jpg">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Ice Panpan(Tan Yibing)</h5>
          <a href="mailto:tanyibing1995@gmail.com" title="tanyibing1995@gmail.com" class="mail">tanyibing1995@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/TanYiBing" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/5341296740?refer_flag=1005055010_" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friendLink"  >
                <i class="icon icon-lg icon-users"></i>
                友链
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
        
            <a id="header-high" style="text-decoration: none; margin-left:12px; width:71px; margin-right:5px" class="header-icon waves-effect waves-circle waves-light" onclick="javascript:(    /*     * Copyright (C) 2015 Rocko (rocko.xyz) <rocko.zxp@gmail.com>     *     * Licensed under the Apache License, Version 2.0 (the 'License');     * you may not use this file except in compliance with the License.     * You may obtain a copy of the License at     *     *      http://www.apache.org/licenses/LICENSE-2.0     *     * Unless required by applicable law or agreed to in writing, software     * distributed under the License is distributed on an 'AS IS' BASIS,     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     * See the License for the specific language governing permissions and     * limitations under the License.     */    function go() {        function c() {        var e = document.createElement('link');        e.setAttribute('type', 'text/css');        e.setAttribute('rel', 'stylesheet');        e.setAttribute('href', f);        e.setAttribute('class', l);        document.body.appendChild(e)    }     function h() {        var e = document.getElementsByClassName(l);        for (var t = 0; t < e.length; t++) {            document.body.removeChild(e[t])        }    }     function p() {        var e = document.createElement('div');        e.setAttribute('class', a);        document.body.appendChild(e);        setTimeout(function() {            document.body.removeChild(e)        }, 100)    }     function d(e) {        return {            height : e.offsetHeight,            width : e.offsetWidth        }    }     function v(i) {        var s = d(i);        return s.height > e &amp;&amp; s.height < n &amp;&amp; s.width > t &amp;&amp; s.width < r    }     function m(e) {        var t = e;        var n = 0;        while (!!t) {            n += t.offsetTop;            t = t.offsetParent        }        return n    }     function g() {        var e = document.documentElement;        if (!!window.innerWidth) {            return window.innerHeight        } else if (e &amp;&amp; !isNaN(e.clientHeight)) {            return e.clientHeight        }        return 0    }     function y() {        if (window.pageYOffset) {            return window.pageYOffset        }        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)    }     function E(e) {        var t = m(e);        return t >= w &amp;&amp; t <= b + w    }     var songs = [               'http://rocko-blog.qiniudn.com/Music-Wake-Live.mp3' ,     'http://rocko-blog.qiniudn.com/Music-Fashion_Show.mp3'           ,                'http://rocko-blog.qiniudn.com/Music-outside.mp3',                'http://rocko-blog.qiniudn.com/Music-sunburst.mp3'    ];    function S() {        var e = document.getElementById('audio_element_id');        if(e != null){            var index = parseInt(e.getAttribute('curSongIndex'));            if(index > songs.length - 2) {                index = 0;            } else {                index++;            }            e.setAttribute('curSongIndex', index);            N();        }        e.src = i;        e.play()    }     function x(e) {        e.className += ' ' + s + ' ' + o    }     function T(e) {        e.className += ' ' + s + ' ' + u[Math.floor(Math.random() * u.length)]    }     function N() {        var e = document.getElementsByClassName(s);        var t = new RegExp('\\b' + s + '\\b');        for (var n = 0; n < e.length; ) {            e[n].className = e[n].className.replace(t, '')        }    }    function initAudioEle() {        var e = document.getElementById('audio_element_id');        if(e === null){            e = document.createElement('audio');            e.setAttribute('class', l);            e.setAttribute('curSongIndex', 0);            e.id = 'audio_element_id';            e.loop = false;            e.bgcolor = 0;            e.addEventListener('canplay', function() {            setTimeout(function() {                x(k)            }, 500);            setTimeout(function() {                N();                p();                for (var e = 0; e < O.length; e++) {                    T(O[e])                }            }, 15500)        }, true);        e.addEventListener('ended', function() {            N();            h();            go();        }, true);        e.innerHTML = ' <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>';        document.body.appendChild(e);        }    }        initAudioEle();    var e = 30;    var t = 30;    var n = 350;    var r = 350;    var curSongIndex = parseInt(document.getElementById('audio_element_id').getAttribute('curSongIndex'));    var i = songs[curSongIndex];        var s = 'mw-harlem_shake_me';    var o = 'im_first';    var u = ['im_drunk', 'im_baked', 'im_trippin', 'im_blown'];    var a = 'mw-strobe_light';    var f = 'https://rocko.xyz/css/harlem-shake-style.css';        var l = 'mw_added_css';    var b = g();    var w = y();    var C = document.getElementsByTagName('*');    var k = null;    for (var L = 0; L < C.length; L++) {        var A = C[L];        if (v(A)) {            if (E(A)) {                k = A;                break            }        }    }    if (A === null) {        console.warn('Could not find a node of the right size. Please try a different page.');        return    }    c();    S();    var O = [];    for (var L = 0; L < C.length; L++) {        var A = C[L];        if (v(A)) {            O.push(A)        }    }    })()">
        <i class="icon icon-lg icon-music"></i> High~
        </a>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-12-14T13:59:55.000Z" itemprop="datePublished" class="page-time">
  2018-12-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Angular/">Angular</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#翻译-OnPush-组件中-NgDoCheck-和-AsyncPipe-的区别"><span class="post-toc-number">1.</span> <span class="post-toc-text">[翻译] OnPush 组件中 NgDoCheck 和 AsyncPipe 的区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#OnPush-组件"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">OnPush 组件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#手动触发变更检测"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">手动触发变更检测</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#输入绑定"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">输入绑定</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#异步更新"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">异步更新</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#AsyncPipe"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">AsyncPipe</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#手动检查并且变更检测"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">手动检查并且变更检测</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#那么那种解决方案更快？"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">那么那种解决方案更快？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一些更有趣的事情"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">一些更有趣的事情</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">总结</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#想要了解更过关于-Angular-中-change-detection-的相关知识？"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">想要了解更过关于 Angular 中 change detection 的相关知识？</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-翻译-OnPush组件中NgDoCheck和AsyncPipe的区别"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-12-14 21:59:55" datetime="2018-12-14T13:59:55.000Z"  itemprop="datePublished">2018-12-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Angular/">Angular</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="翻译-OnPush-组件中-NgDoCheck-和-AsyncPipe-的区别"><a href="#翻译-OnPush-组件中-NgDoCheck-和-AsyncPipe-的区别" class="headerlink" title="[翻译] OnPush 组件中 NgDoCheck 和 AsyncPipe 的区别"></a>[翻译] OnPush 组件中 NgDoCheck 和 AsyncPipe 的区别</h1><blockquote>
<p>原文：<a href="https://blog.angularindepth.com/the-difference-between-ngdocheck-and-asyncpipe-in-onpush-components-4918ec4b29d4" target="_blank" rel="noopener">The difference between NgDoCheck and AsyncPipe in OnPush components</a><br>作者：<strong><a href="http://twitter.com/maxim_koretskyi" target="_blank" rel="noopener">Max Koretskyi</a></strong><br>原技术博文由 <code>Max Koretskyi</code> 撰写发布，他目前于 <a href="https://angular-grid.ag-grid.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=angularcustom" target="_blank" rel="noopener">ag-Grid</a> 担任开发者职位</p>
</blockquote>
<blockquote>
<p>译者：<strong><a href="https://github.com/TanYiBing" target="_blank" rel="noopener">Ice Panpan</a></strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/rxjs/1.jpeg" alt="async or ngdocheck" title="">
                </div>
                <div class="image-caption">async or ngdocheck</div>
            </figure>
<p>这篇文章是对<a href="https://twitter.com/shai_reznik/status/1054868497363283968" target="_blank" rel="noopener">Shai这条推特</a>的回应。他询问使用 <code>NgDoCheck</code> 生命周期钩子来手动比较值而不是使用 <code>asyncPipe</code> 是否有意义。这是一个非常好的问题，需要对引擎的工作原理有很多了解：变化检测(change detection)，管道(pipe)和生命周期钩子(lifecycle hooks)。那就是我探索的入口😎。</p>
<p>在本文中，我将向您展示如何手动处理变更检测。这些技术使您可以更好地掌控 Angular 的输入绑定(input bindings)的自动执行和异步值检查(async values checks)。掌握了这些知识之后，我还将与您分享我对这些解决方案的性能影响的看法。让我们开始吧！</p>
<h2 id="OnPush-组件"><a href="#OnPush-组件" class="headerlink" title="OnPush 组件"></a>OnPush 组件</h2><p>在 Angular 中，我们有一种非常常见的优化技术，需要将 <code>ChangeDetectionStrategy.OnPush</code> 添加到组件中。假设我们有如下两个简单的组件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'a-comp'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am A component&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;b-comp&gt;&lt;/b-comp&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AComponent &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'b-comp'</span>,</span><br><span class="line">    template: <span class="string">`&lt;span&gt;I am B component&lt;/span&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BComponent &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样设置之后， Angular 每次都会对 <code>A</code> 和 <code>B</code> 两个组件运行变更检测。如果我们现在为 <code>B</code> 组件添加上 <code>OnPush</code> 策略：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'b-comp'</span>,</span><br><span class="line">    template: <span class="string">`&lt;span&gt;I am B component&lt;/span&gt;`</span>,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BComponent &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>只有在输入绑定的值发生变化时</strong> Angular 才会对 <code>B</code> 运行变更检测。由于它现在没有任何绑定，因此该组件只会在初始化的时候检查一次。</p>
<h2 id="手动触发变更检测"><a href="#手动触发变更检测" class="headerlink" title="手动触发变更检测"></a>手动触发变更检测</h2><p>有没有办法强制对 <code>B</code> 组件进行变更检测？是的，我们可以注入 <code>changeDetectorRef</code> 并使用它的方法 <code>markForCheck</code> 来指示 Angular 需要检查该组件。并且由于 <a href="https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5" target="_blank" rel="noopener"><em>NgDoCheck 钩子仍然会被 B 组件触发</em></a>，所以我们应该在 <em>NgDoCheck</em> 中调用 <em>markForCheck</em>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'b-comp'</span>,</span><br><span class="line">    template: <span class="string">`&lt;span&gt;I am B component&lt;/span&gt;`</span>,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BComponent &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> cd: ChangeDetectorRef</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        <span class="keyword">this</span>.cd.markForCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当 Angular 检查父组件 <code>A</code> 时，将始终检查 <code>B</code> 组件。现在让我们看看我们可以在哪里使用它。</p>
<h2 id="输入绑定"><a href="#输入绑定" class="headerlink" title="输入绑定"></a>输入绑定</h2><p>我之前说过，Angular 只在 <code>OnPush</code> 组件的绑定发生变化时运行的变化检测。所以让我们看一下输入绑定的例子。假设我们有一个通过输入绑定从父组件传递下来的对象：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'b-comp'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am B component&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BComponent &#123;</span><br><span class="line">    <span class="meta">@Input</span>() user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在父组件 <code>A</code> 中，我们定义了一个对象，并实现了在单击按钮时来更新对象名称的  <em>changeName</em>  方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'a-comp'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am A component&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;button (click)="changeName()"&gt;Trigger change detection&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;b-comp [user]="user"&gt;&lt;/b-comp&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AComponent &#123;</span><br><span class="line">    user = &#123;name: <span class="string">'A'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        <span class="keyword">this</span>.user.name = <span class="string">'B'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您现在<a href="https://stackblitz.com/edit/angular-kq26qe" target="_blank" rel="noopener">运行此示例</a>，则在第一次变更检测后，您将看到用户名称被打印出来：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User name: A</span><br></pre></td></tr></table></figure>
<p>但是当我们点击按钮并回调中更改名称时：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.user.name = <span class="string">'B'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>该名称并没有在屏幕上更新</strong>，这是因为 Angular 对输入参数执行浅比较，并且对 user 对象的引用没有改变。那我们怎么解决这个问题呢？</p>
<p>好吧，我们可以在检测到差异时手动检查名称并触发变更检测：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'b-comp'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am B component&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BComponent &#123;</span><br><span class="line">    <span class="meta">@Input</span>() user;</span><br><span class="line">    previousName = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> cd: ChangeDetectorRef</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.previousName !== <span class="keyword">this</span>.user.name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.previousName = <span class="keyword">this</span>.user.name;</span><br><span class="line">            <span class="keyword">this</span>.cd.markForCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您现在<a href="https://stackblitz.com/edit/angular-8dkwct" target="_blank" rel="noopener">运行此代码</a>，你将在屏幕上看到更新的名称。</p>
<h2 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h2><p>现在，让我们的例子更复杂一点。我们将介绍一种基于 RxJs 的服务，它可以异步发出更新。这类似于 NgRx 的体系结构。我将使用一个 <code>BehaviorSubject</code> 作为值的来源，因为我们需要在这个流的最开始设置初始值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'a-comp'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am A component&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;button (click)="changeName()"&gt;Trigger change detection&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;b-comp [user]="user"&gt;&lt;/b-comp&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AComponent &#123;</span><br><span class="line">    stream = <span class="keyword">new</span> BehaviorSubject(&#123;name: <span class="string">'A'</span>&#125;);</span><br><span class="line">    user = <span class="keyword">this</span>.stream.asObservable();</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        <span class="keyword">this</span>.stream.next(&#123;name: <span class="string">'B'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们需要在子组件中订阅这个流并从中获取到 <code>user</code> 对象。我们需要订阅流并检查值是否更新。这样做的常用方法是使用 <a href="https://angular.io/api/common/AsyncPipe" target="_blank" rel="noopener">AsyncPipe</a>。</p>
<h2 id="AsyncPipe"><a href="#AsyncPipe" class="headerlink" title="AsyncPipe"></a>AsyncPipe</h2><p>所以这里是子组件 <code>B</code> 的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'b-comp'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am B component&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;User name: &#123;&#123;(user | async).name&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BComponent &#123;</span><br><span class="line">    <span class="meta">@Input</span>() user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://stackblitz.com/edit/angular-q8n3qj" target="_blank" rel="noopener">这是演示</a>。但是，还有另一种不使用管道的方法吗？</p>
<h2 id="手动检查并且变更检测"><a href="#手动检查并且变更检测" class="headerlink" title="手动检查并且变更检测"></a>手动检查并且变更检测</h2><p>是的，我们可以手动检查值并在需要时触发变更检测。正如开头的例子一样，我们可以使用 <code>NgDoCheck</code> 生命周期钩子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'b-comp'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am B component&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BComponent &#123;</span><br><span class="line">    <span class="meta">@Input</span>(<span class="string">'user'</span>) user$;</span><br><span class="line">    user;</span><br><span class="line">    previousName = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> cd: ChangeDetectorRef</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        <span class="keyword">this</span>.user$.subscribe(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.user = user;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.previousName !== <span class="keyword">this</span>.user.name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.previousName = <span class="keyword">this</span>.user.name;</span><br><span class="line">            <span class="keyword">this</span>.cd.markForCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以<a href="https://stackblitz.com/edit/angular-4xuug1" target="_blank" rel="noopener">在这查看</a>。</p>
<p>我们希望把值的比较与更新逻辑从 <code>NgDoCheck</code> 中移至订阅的回调函数，因为我们是从那里获取到新值的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BComponent &#123;</span><br><span class="line">    <span class="meta">@Input</span>(<span class="string">'user'</span>) user$;</span><br><span class="line">    user = &#123;name: <span class="literal">null</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> cd: ChangeDetectorRef</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        <span class="keyword">this</span>.user$.subscribe(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.user.name !== user.name) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cd.markForCheck();</span><br><span class="line">                <span class="keyword">this</span>.user = user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://stackblitz.com/edit/angular-lvtfve" target="_blank" rel="noopener">例子在这</a>。</p>
<p>有趣的是，这其实正是 <a href="https://github.com/maximusk/angular/blob/725bae1921cfcdcf5a5b0c35252c632198d1a7a4/packages/common/src/pipes/async_pipe.ts#L139" target="_blank" rel="noopener">AsyncPipe 背后的工作原理</a>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pipe</span>(&#123;name: <span class="string">'async'</span>, pure: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AsyncPipe <span class="keyword">implements</span> OnDestroy, PipeTransform &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> _ref: ChangeDetectorRef</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  transform(obj: ...): <span class="built_in">any</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>._subscribe(obj);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._latestValue === <span class="keyword">this</span>._latestReturnedValue) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._latestReturnedValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._latestReturnedValue = <span class="keyword">this</span>._latestValue;</span><br><span class="line">    <span class="keyword">return</span> WrappedValue.wrap(<span class="keyword">this</span>._latestValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> _subscribe(obj): <span class="built_in">void</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>._strategy.createSubscription(</span><br><span class="line">        obj, <span class="function">(<span class="params">value: <span class="built_in">Object</span></span>) =&gt;</span> <span class="keyword">this</span>._updateLatestValue(obj, value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> _updateLatestValue(<span class="keyword">async</span>: <span class="built_in">any</span>, value: <span class="built_in">Object</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">async</span> === <span class="keyword">this</span>._obj) &#123;</span><br><span class="line">      <span class="keyword">this</span>._latestValue = value;</span><br><span class="line">      <span class="keyword">this</span>._ref.markForCheck();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那么那种解决方案更快？"><a href="#那么那种解决方案更快？" class="headerlink" title="那么那种解决方案更快？"></a>那么那种解决方案更快？</h2><p>现在我们知道如何使用手动进行变更检测而不是使用 AsyncPipe，让我们回答下最一开始的问题。那种方法更快？</p>
<p>嗯…这取决于你如何比较它们，但在其他条件相同的情况下，手动方法会更快。尽管我不认为两者会有明显区别。以下是为什么手动方法可以更快的几个例子。</p>
<p>就内存而言，您不需要创建 Pipe 类的实例。就编译时间而言，编译器不必花时间解析管道特定语法并生成管道特定输出。就运行时间而言，节省了异步管道为组件进行变更检测所调用的函数的时间。这个例子演示了当代码中包含 pipe 时 <a href="https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d" target="_blank" rel="noopener">updateRenderer</a> 所生成的代码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">_ck, _v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _co = _v.component;</span><br><span class="line">    <span class="keyword">var</span> currVal_0 = jit_unwrapValue_7(_v, <span class="number">3</span>, <span class="number">0</span>, asyncpipe.transform(_co.user)).name;</span><br><span class="line">    _ck(_v, <span class="number">3</span>, <span class="number">0</span>, currVal_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，异步管道的代码调用管道实例上的 <code>transform</code> 方法以获取新值。管道将返回从订阅中收到的最新值。</p>
<p>将其与为手动方法生成的普通代码进行比较：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">_ck,_v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _co = _v.component;</span><br><span class="line">    <span class="keyword">var</span> currVal_0 = _co.user.name;</span><br><span class="line">    _ck(_v,<span class="number">3</span>,<span class="number">0</span>,currVal_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是 Angular 在检查 <code>B</code> 组件时调用的方法。</p>
<h2 id="一些更有趣的事情"><a href="#一些更有趣的事情" class="headerlink" title="一些更有趣的事情"></a>一些更有趣的事情</h2><p>与执行浅比较的输入绑定不同，<strong>异步管道的实现根本不执行比较</strong>（感谢 <a href="https://medium.com/@sharlatenok" target="_blank" rel="noopener">Olena Horal</a> 注意到这一点）。它将每个新发射的值认为是更新，即使它与先前发射的值一样。下面的代码是父组件 <code>A</code> 的实现，它每次都发射出相同的对象。尽管如此，Angular 仍然会对 <code>B</code> 组件进行变更检测：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AComponent &#123;</span><br><span class="line">    o = &#123;name: <span class="string">'A'</span>&#125;;</span><br><span class="line">    user = <span class="keyword">new</span> BehaviorSubject(<span class="keyword">this</span>.o);</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        <span class="keyword">this</span>.user.next(<span class="keyword">this</span>.o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着每次发出新值时，使用异步管道的组件都会被标记以进行检查。并且 Angular 将在下次运行变更检测时检查该组件，即使该值未更改。</p>
<p>这是应用于什么情况呢？嗯…在我们的例子中，我们只关注 <code>user</code> 对象的 <code>name</code> 属性，因为我们需要在模板中使用它。我们并不关心整个对象以及对象的引用可能会改变的事实。如果 name 没有发生改变，我们不需要重新渲染组件。但你无法用异步管道来避免这种情况。</p>
<p><code>NgDoCheck</code> 并不是没有问题:)由于仅在检查父组件时触发钩子，如果其中一个父组件使用 <code>OnPush</code> 策略并且在变更检测期间未检查，则不会触发该钩子。因此，当您通过服务收到新值时，不能依赖它来触发变更检测。在这种情况下，我在订阅回调中调用 <code>markForCheck</code> 方法是正确的解决方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上，手动比较可以让您更好地控制检查。您可以定义何时需要检查组件。这与许多其他工具相同 - 手动控制为您提供了更大的灵活性，但您必须知道自己在做什么。为了获得这些知识，我鼓励您投入时间和精力学习和阅读<a href="https://blog.angularindepth.com/level-up-your-reverse-engineering-skills-8f910ae10630" target="_blank" rel="noopener">更多文章</a>。</p>
<p>你不用担心 <code>NgDoCheck</code> 生命周期钩子被调用的频率，或者它会比管道的 <code>transform</code> 方法更频繁地被调用。首先，我上面已经展示了解决方案，当使用异步流时，你应该在订阅的回调中而非在该钩子函数中手动执行变更检测。其次，只有在父组件被检测后才会调用该钩子函数。如果父组件没有被检查，则不会调用该钩子。对于管道而言，由于流中的浅比较和更改引用的原因，管道的 <code>transform</code> 方法被调用的次数只会和手动方法相同甚至更多。</p>
<h2 id="想要了解更过关于-Angular-中-change-detection-的相关知识？"><a href="#想要了解更过关于-Angular-中-change-detection-的相关知识？" class="headerlink" title="想要了解更过关于 Angular 中 change detection 的相关知识？"></a>想要了解更过关于 Angular 中 change detection 的相关知识？</h2><p>从这5篇文章入手会让你成为 Angular 变更检测机制的专家。如果你想要牢固掌握 Angular 中变更检测机制，那么这一系列的文章是必读的。每一篇文章都会基于前一篇文章中所解释的相关信息，既包含高层次的概述又囊括了具体的实现细节，并且都附有相关源代码。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-12-14T14:02:36.941Z" itemprop="dateUpdated">2018-12-14 22:02:36</time>
</span><br>


        
        除特别说明外，文章均采用「知识共享 署名 - 非商业性 - 相同方式共享 4.0 协议」进行许可，转载需注明文章出处：<a href="/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/" target="_blank" rel="external">http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/</a>
        
    </div>
    
    <footer>
        <a href="http://tanyibing.com">
            <img src="/img/avatar.jpg" alt="Ice Panpan(Tan Yibing)">
            Ice Panpan(Tan Yibing)
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/&title=《[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别》 — Ice Panpan's blog&pic=http://tanyibing.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/&title=《[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别》 — Ice Panpan's blog&source=I'm TanYiBing,my email is 820567197@qq.com&tanyibing1995@gmail.com,my qq is 8..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别》 — Ice Panpan's blog&url=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/&via=http://tanyibing.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/11/25/Rxjs（二）：日志记录/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">【翻译】调试Rxjs（二）：日志记录</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "4rdRChJgomStDCzm3AqViMI2-gzGzoHsz",
            appKey: "4cekfBC0l7ePUjMgoIGow6DC",
            avatar: "mm",
            placeholder: "要不要说点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Ice Panpan(Tan Yibing) &copy; 2017 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/&title=《[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别》 — Ice Panpan's blog&pic=http://tanyibing.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/&title=《[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别》 — Ice Panpan's blog&source=I'm TanYiBing,my email is 820567197@qq.com&tanyibing1995@gmail.com,my qq is 8..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《[翻译]OnPush组件中NgDoCheck和AsyncPipe的区别》 — Ice Panpan's blog&url=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/&via=http://tanyibing.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://tanyibing.com/2018/12/14/翻译-OnPush组件中NgDoCheck和AsyncPipe的区别/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADLElEQVR42u3ay27iUBAE0Pz/TzPbWQRT1U0kfDleRTxsjpFS9OPnJz4e/x3PHnn2ruQ8169/9uz14284sLGxsW/CflweM2QOSM6cnCG3YGNjY5/KbhnXsdRGTnKbki+jCDlsbGxs7DKcrq+ShF9+I7CxsbGx31VaXAdbHlrtu7CxsbG/k500lZJ3JbzkI84Kmz/ppWFjY2N/PDufin7+338y38bGxsb+YPajPNpYauOwHQk/Rgc2Njb2Sew8ADZtoCQU8+tu1n2wsbGxz2MnAdO2bNoW1Z6UrwH95LmKjY2NfRP2LK4264+b8iZfBhqOB7CxsbGPYG9+6LdD3NkN2qwTYWNjY5/NzhtAs+FrHkKbZlO9oIONjY19KDsvLd47+s3XLt9WJmFjY2Mfx27b8bM1mrxo2ZRA0ReDjY2NfXP2rCm/KWzaKw57Y9fNKWxsbOzj2O2pNy37vK2/b2k9vRY2Njb2cewE0C7c5Oubq+Z+GZzY2NjY57HzS+b49pwvyoYynIqAxMbGxj6CPcPMNmGS4mQ2GMhLIGxsbOzz2LOf8nlBkt+4dlQ8C05sbGzs89j7hv6mlb8ZJOcDhqftJGxsbOyj2W/Y5SyLjXwwMBsGD1d2sLGxsW/CThoxm1fOInCz0POiTMLGxsY+mt0WEm0gzYbB7QDgxZeBjY2NfSh7Xza0bfrrmNmMgV98WmxsbOyD2PlP/H38tIPbWaTl58HGxsY+g50HSR4SswIjHwBvhsFPSxFsbGzs27L3xcbsDLPzzII2WtzBxsbGvjl7T2oLks2yzqyAqfMNGxsb+1bsvISY3awktGbHrDjBxsbG/jb2LDbyD7cvToarRdjY2NhfwN4UG2350ZYxw9BqZxrY2NjYH8/er9Tsh7JtMdOOpX95HBsbG/sg9nv/57djhv1oob3Rw5kJNjY29sezN5jZWDcPs7awKQIMGxsb+zh2GwyzNn3b0G+bUEX4YWNjY2Ovmzj5rUxaSMmI95dSBBsbG/uL2UnAtIHUFiqzRhg2Njb2qex3DVNnc4l3tY2S0MXGxsY+j50PetsQur5wPkhor5K3q7CxsbFvzv4HOGzEcGiN59AAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
