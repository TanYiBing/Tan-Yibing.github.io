<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice Panpan&#39;s blog</title>
  
  <subtitle>Tan Yibing&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tanyibing.com/"/>
  <updated>2018-09-18T03:29:53.607Z</updated>
  <id>http://tanyibing.com/</id>
  
  <author>
    <name>Ice Panpan(Tan Yibing)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript异步（四）</title>
    <link href="http://tanyibing.com/2018/09/18/javascript%E5%BC%82%E6%AD%A5%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/09/18/javascript异步（四）/</id>
    <published>2018-09-18T02:56:41.000Z</published>
    <updated>2018-09-18T03:29:53.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript异步（四）————async-amp-await"><a href="#JavaScript异步（四）————async-amp-await" class="headerlink" title="JavaScript异步（四）————async &amp; await"></a>JavaScript异步（四）————async &amp; await</h1><p>前面已经介绍了<code>Generator</code>，我的唯一感觉就是————学习成本真特喵的高，我们今天还要看一个异步的终极解决方案————<code>async-await</code>，这就是ES7自己参照Generator封装的，其实更像是Generator的语法糖。</p><h2 id="ES7中的async-await"><a href="#ES7中的async-await" class="headerlink" title="ES7中的async-await"></a>ES7中的async-await</h2><h3 id="Generator和async-await对比"><a href="#Generator和async-await对比" class="headerlink" title="Generator和async-await对比"></a>Generator和async-await对比</h3><p>我们先来一段Generator的异步处理代码：</p><pre><code>co(function* () {    const r1 = yield readFilePromise(&apos;some1.json&apos;)    console.log(r1)  // 打印第 1 个文件内容    const r2 = yield readFilePromise(&apos;some2.json&apos;)    console.log(r2)  // 打印第 2 个文件内容})</code></pre><p>接着看看使用async-await，对比一下;</p><pre><code>const readFilePromise = Q.denodeify(fs.readFile)// 定义 async 函数const readFileAsync = async function () {    const f1 = await readFilePromise(&apos;data1.json&apos;)    const f2 = await readFilePromise(&apos;data2.json&apos;)    console.log(&apos;data1.json&apos;, f1.toString())    console.log(&apos;data2.json&apos;, f2.toString())    return &apos;done&apos; // 先忽略，后面会讲到}// 执行const result = readFileAsync()</code></pre><p>我们可以比较看出，async function代替了function* ，await代替了yield，而且使用async-await不在用co这个第三方库了，直接执行即可。</p><h3 id="使用async-await的差异"><a href="#使用async-await的差异" class="headerlink" title="使用async-await的差异"></a>使用async-await的差异</h3><p>第一，await后面不能再跟thunk函数，而必须跟一个Promise对象（因此，Promise才是异步的终极解决方案和未来）。跟其他类型的数据也OK，但是会直接同步执行，而不是异步。</p><p>第二，执行const result = readFileAsync()返回的是个Promise对象，而且上面代码中的return ‘done’会直接被下面的then函数接收到</p><pre><code>result.then(data =&gt; {    console.log(data)  // done})</code></pre><p>第三，从代码的易读性来将，async-await更加易读简介，也更加符合代码的语意。而且还不用引用第三方库，也无需学习Generator那一堆东西，使用成本非常低。</p><p>因此，如果 ES7 正式发布了之后，强烈推荐使用async-await。但是现在尚未正式发布，从稳定性考虑，还是Generator更好一些。</p><h2 id="异步操作代码的演变历程"><a href="#异步操作代码的演变历程" class="headerlink" title="异步操作代码的演变历程"></a>异步操作代码的演变历程</h2><p>最后再来感受下从<code>callback</code>到<code>async-await</code>的历程吧。</p><h3 id="callback方式"><a href="#callback方式" class="headerlink" title="callback方式"></a>callback方式</h3><pre><code>fs.readFile(&apos;some1.json&apos;, (err, data) =&gt; {    fs.readFile(&apos;some2.json&apos;, (err, data) =&gt; {        fs.readFile(&apos;some3.json&apos;, (err, data) =&gt; {            fs.readFile(&apos;some4.json&apos;, (err, data) =&gt; {            })        })    })})</code></pre><h3 id="Promise方式"><a href="#Promise方式" class="headerlink" title="Promise方式"></a>Promise方式</h3><pre><code>readFilePromise(&apos;some1.json&apos;).then(data =&gt; {    return readFilePromise(&apos;some2.json&apos;)}).then(data =&gt; {    return readFilePromise(&apos;some3.json&apos;)}).then(data =&gt; {    return readFilePromise(&apos;some4.json&apos;)})</code></pre><h3 id="Generator方式"><a href="#Generator方式" class="headerlink" title="Generator方式"></a>Generator方式</h3><pre><code>co(function* () {    const r1 = yield readFilePromise(&apos;some1.json&apos;)    const r2 = yield readFilePromise(&apos;some2.json&apos;)    const r3 = yield readFilePromise(&apos;some3.json&apos;)    const r4 = yield readFilePromise(&apos;some4.json&apos;)})</code></pre><h3 id="async-await方式"><a href="#async-await方式" class="headerlink" title="async-await方式"></a>async-await方式</h3><pre><code>const readFileAsync = async function () {    const f1 = await readFilePromise(&apos;data1.json&apos;)    const f2 = await readFilePromise(&apos;data2.json&apos;)    const f3 = await readFilePromise(&apos;data3.json&apos;)    const f4 = await readFilePromise(&apos;data4.json&apos;)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript异步（四）————async-amp-await&quot;&gt;&lt;a href=&quot;#JavaScript异步（四）————async-amp-await&quot; class=&quot;headerlink&quot; title=&quot;JavaScript异步（四）————async
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://tanyibing.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>javascript异步（三）</title>
    <link href="http://tanyibing.com/2018/09/18/javascript%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/09/18/javascript异步（三）/</id>
    <published>2018-09-18T01:18:08.000Z</published>
    <updated>2018-09-18T03:29:54.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript异步（三）————Generator"><a href="#JavaScript异步（三）————Generator" class="headerlink" title="JavaScript异步（三）————Generator"></a>JavaScript异步（三）————Generator</h1><p>上次已经介绍过一点<code>Generator</code>对象的知识了，这次就继续说说Generator的应用吧。</p><h2 id="Generator的应用"><a href="#Generator的应用" class="headerlink" title="Generator的应用"></a>Generator的应用</h2><h3 id="使用next和yield传递参数"><a href="#使用next和yield传递参数" class="headerlink" title="使用next和yield传递参数"></a>使用next和yield传递参数</h3><p>我们已经知道，<code>yield</code>具有返回数据的功能，如下代码。yield后面的数据被返回，存放到返回结果中的value属性中。这算是一个方向的参数传递。</p><pre><code>function* G() {    yield 100}const g = G()console.log( g.next() ) // {value: 100, done: false}</code></pre><p>还有另一个方向的参数传递，就是next向yield传递，如下：</p><pre><code>function* G() {    const a = yield 100    console.log(&apos;a&apos;, a)  // a aaa    const b = yield 200    console.log(&apos;b&apos;, b)  // b bbb    const c = yield 300    console.log(&apos;c&apos;, c)  // c ccc}const g = G()g.next()    // value: 100, done: falseg.next(&apos;aaa&apos;) // value: 200, done: falseg.next(&apos;bbb&apos;) // value: 300, done: falseg.next(&apos;ccc&apos;) // value: undefined, done: true</code></pre><p>我们看看上面代码的执行过程：</p><ul><li>执行第一个g.next()时，未传递任何参数，返回的{value: 100, done: false}，这个应该没有疑问</li><li>执行第二个g.next(‘aaa’)时，传递的参数是’aaa’，这个’aaa’就会被赋值到G内部的a标量中，然后执行console.log(‘a’, a)打印出来，最后返回{value: 200, done: false}</li><li>执行第三个、第四个时，道理都是完全一样的，大家自己捋一捋。</li></ul><p>有一个要点需要注意，就g.next(‘aaa’)是将’aaa’传递给上一个已经执行完了的yield语句前面的变量，而不是即将执行的yield前面的变量。</p><h3 id="for…of的应用"><a href="#for…of的应用" class="headerlink" title="for…of的应用"></a>for…of的应用</h3><p>for…of是Iterator对象的一个经典操作，我们使用一个斐波那契数列来看一看：</p><pre><code>function* fibonacci() {    let [prev, curr] = [0, 1]    for (;;) {        [prev, curr] = [curr, prev + curr]        // 将中间值通过 yield 返回，并且保留函数执行的状态，因此可以非常简单的实现 fibonacci        yield curr    }}for (let n of fibonacci()) {    if (n &gt; 1000) {        break    }    console.log(n)}</code></pre><p>这样我们就能找到1000里面的斐波那契数列了。</p><h3 id="yield-嵌套Generator"><a href="#yield-嵌套Generator" class="headerlink" title="yield*嵌套Generator"></a>yield*嵌套Generator</h3><p>如果我们有两个Generator，我们想在第一个中包含第二个：</p><pre><code>function* G1() {    yield &apos;a&apos;    yield* G2()  // 使用 yield* 执行 G2()    yield &apos;b&apos;}function* G2() {    yield &apos;x&apos;    yield &apos;y&apos;}for (let item of G1()) {    console.log(item)}</code></pre><p>之前学过的yield后面会接一个普通的 JS 对象，而yield<em> 后面会接一个Generator，而且会把它其中的yield按照规则来一步一步执行。如果有多个Generator串联使用的话（例如Koa源码中），用yield</em>来操作非常方便。</p><h3 id="Generator中的this"><a href="#Generator中的this" class="headerlink" title="Generator中的this"></a>Generator中的this</h3><p>对于以下这种写法，大家可能会和构造函数创建对象的写法产生混淆，这里一定要注意 —— Generator 不是函数，更不是构造函数</p><pre><code>function* G() {}const g = G()</code></pre><p>而以下这种写法，更加不会成功。只有构造函数才会这么用，构造函数返回的是this，而Generator返回的是一个Iterator对象。完全是两码事，千万不要搞混了。</p><pre><code>function* G() {    this.a = 10}const g = G()console.log(g.a) // 报错</code></pre><h2 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h2><p>为什么要说说Thunk函数呢，因为它和Generator处理异步操作还是有关系的，我们先看看。</p><h3 id="普通异步函数"><a href="#普通异步函数" class="headerlink" title="普通异步函数"></a>普通异步函数</h3><pre><code>fs.readFile(&apos;data1.json&apos;, &apos;utf-8&apos;, (err, data) =&gt; {    // 获取文件内容})</code></pre><p>这个普通的node读取文件的函数传递了三个函数，接下来我们进行一点改造。</p><h3 id="封装成Thunk函数"><a href="#封装成Thunk函数" class="headerlink" title="封装成Thunk函数"></a>封装成Thunk函数</h3><pre><code>const thunk = function (fileName, codeType) {    // 返回一个只接受 callback 参数的函数    return function (callback) {        fs.readFile(fileName, codeType, callback)    }}const readFileThunk = thunk(&apos;data1.json&apos;, &apos;utf-8&apos;)readFileThunk((err, data) =&gt; {    // 获取文件内容})</code></pre><p>从上面的Thunk函数可以看出，执行const readFileThunk = thunk(‘data1.json’, ‘utf-8’)返回的其实是一个函数，readFileThunk这个函数，只接受一个参数，而且这个参数是一个callback函数。</p><h3 id="使用thunkify库"><a href="#使用thunkify库" class="headerlink" title="使用thunkify库"></a>使用thunkify库</h3><p>上面的代码封装使我们自己做的，但我们不需要每遇到一个情况就自己做，我们可以直接使用第三方的thunkify就可以了。</p><pre><code>onst thunk = thunkify(fs.readFile)const readFileThunk = thunk(&apos;data1.json&apos;, &apos;utf-8&apos;)readFileThunk((err, data) =&gt; {    // 获取文件内容})</code></pre><h2 id="Generator异步操作"><a href="#Generator异步操作" class="headerlink" title="Generator异步操作"></a>Generator异步操作</h2><p>上次我们只是大概的讲了讲，接下来我们详细看看Generator是如何进行异步操作的</p><h3 id="Generator中使用Thunk"><a href="#Generator中使用Thunk" class="headerlink" title="Generator中使用Thunk"></a>Generator中使用Thunk</h3><p>直接看代码吧</p><pre><code>const readFileThunk = thunkify(fs.readFile)const gen = function* () {    const r1 = yield readFileThunk(&apos;data1.json&apos;)    console.log(r1)    const r2 = yield readFileThunk(&apos;data2.json&apos;)    console.log(r2)}</code></pre><h3 id="挨个读取两个文件的内容"><a href="#挨个读取两个文件的内容" class="headerlink" title="挨个读取两个文件的内容"></a>挨个读取两个文件的内容</h3><p>接着上面的代码继续写：</p><pre><code>const g = gen()// 试着打印 g.next() 这里一定要明白 value 是一个 thunk函数 ，否则下面的代码你都看不懂// console.log( g.next() )  // g.next() 返回 {{ value: thunk函数, done: false }} // 下一行中，g.next().value 是一个 thunk 函数，它需要一个 callback 函数作为参数传递进去g.next().value((err, data1) =&gt; {    // 这里的 data1 获取的就是第一个文件的内容。下一行中，g.next(data1) 可以将数据传递给上面的 r1 变量，此前已经讲过这种参数传递的形式    // 下一行中，g.next(data1).value 又是一个 thunk 函数，它又需要一个 callback 函数作为参数传递进去    g.next(data1).value((err, data2) =&gt; {        // 这里的 data2 获取的是第二个文件的内容，通过 g.next(data2) 将数据传递个上面的 r2 变量        g.next(data2)    })})</code></pre><p>仔细看望上面的注释，也许会有中恍然大悟的感觉，原来是这样子把异步写成同步的感觉。</p><h3 id="自驱动流程"><a href="#自驱动流程" class="headerlink" title="自驱动流程"></a>自驱动流程</h3><p>接下来我们做一个自驱动的流程，定义好Generator的代码之后，就让他自动执行：</p><pre><code>// 自动流程管理的函数function run(generator) {    const g = generator()    function next(err, data) {        const result = g.next(data)  // 返回 { value: thunk函数, done: ... }        if (result.done) {            // result.done 表示是否结束，如果结束了那就 return 作罢            return        }        result.value(next)  // result.value 是一个 thunk 函数，需要一个 callback 函数作为参数，而 next 就是一个 callback 形式的函数    }    next() // 手动执行以启动第一次 next}// 定义 Generatorconst readFileThunk = thunkify(fs.readFile)const gen = function* () {    const r1 = yield readFileThunk(&apos;data1.json&apos;)    console.log(r1.toString())    const r2 = yield readFileThunk(&apos;data2.json&apos;)    console.log(r2.toString())}// 启动执行run(gen)</code></pre><p>我们简单分析下：</p><ul><li>最后一行run(gen)之后，进入run函数内部执行</li><li>先const g = generator()创建Generator实例，然后定义一个next方法，并且立即执行next()</li><li>注意这个next函数的参数是err, data两个，和我们fs.readFile用到的callback函数形式完全一样</li><li>第一次执行next时，会执行const result = g.next(data)，而g.next(data)返回的是{ value: thunk函数, done: … }，value是一个thunk函数，done表示是否结束</li><li>如果done: true，那就直接return了，否则继续进行</li><li>result.value是一个thunk函数，需要接受一个callback函数作为参数传递进去，因此正好把next给传递进去，让next一直被执行下去</li></ul><h3 id="co库"><a href="#co库" class="headerlink" title="co库"></a>co库</h3><p>这个流程我们也可以使用第三方的库co，用Generator的工程师肯定都要用co，两者天生一对。</p><pre><code>// 定义 Generatorconst readFileThunk = thunkify(fs.readFile)    const gen = function* () {    const r1 = yield readFileThunk(&apos;data1.json&apos;)    console.log(r1.toString())    const r2 = yield readFileThunk(&apos;data2.json&apos;)    console.log(r2.toString())}const c = co(gen)</code></pre><p>而且const c = co(gen)返回的是一个Promise对象，可以接着这么写</p><pre><code>c.then(data =&gt; {    console.log(&apos;结束&apos;)})</code></pre><h2 id="Koa中使用Generator"><a href="#Koa中使用Generator" class="headerlink" title="Koa中使用Generator"></a>Koa中使用Generator</h2><p>Koa第一版中大量使用了Generator，接下来我们去看看怎么使用的。</p><h3 id="Koa中如何使用Generator"><a href="#Koa中如何使用Generator" class="headerlink" title="Koa中如何使用Generator"></a>Koa中如何使用Generator</h3><p>koa 是一个 web 框架，处理 http 请求，但是这里我们不去管它如何处理 http 请求，而是直接关注它使用Genertor的部分————中间件。<br>例如，我们现在要用 3 个Generator输出12345，我们如下代码这么写。</p><pre><code>let info = &apos;&apos;function* g1() {    info += &apos;1&apos;  // 拼接 1    yield* g2()  // 拼接 234    info += &apos;5&apos;  // 拼接 5}function* g2() {    info += &apos;2&apos;  // 拼接 2    yield* g3()  // 拼接 3    info += &apos;4&apos;  // 拼接 4}function* g3() {    info += &apos;3&apos;  // 拼接 3}var g = g1()g.next()console.log(info)  // 12345</code></pre><p>但是如果用 koa 的 中间件 的思路来做，就需要如下这么写。</p><pre><code>app.use(function *(next){    this.body = &apos;1&apos;;    yield next;    this.body += &apos;5&apos;;    console.log(this.body);});app.use(function *(next){    this.body += &apos;2&apos;;    yield next;    this.body += &apos;4&apos;;});app.use(function *(next){    this.body += &apos;3&apos;;});</code></pre><p>我们需要注意几点：</p><ul><li>app.use()中传入的每一个Generator就是一个 中间件，中间件按照传入的顺序排列，顺序不能乱</li><li>每个中间件内部，next表示下一个中间件。yield next就是先将程序暂停，先去执行下一个中间件，等next被执行完之后，再回过头来执行当前代码的下一行。因此，koa 的中间件执行顺序是一种洋葱圈模型，不过这里看不懂也没问题。</li><li>每个中间件内部，this可以共享变量。即第一个中间件改变了this的属性，在第二个中间件中可以看到效果。</li></ul><h3 id="Koa的这种机制如何实现的"><a href="#Koa的这种机制如何实现的" class="headerlink" title="Koa的这种机制如何实现的"></a>Koa的这种机制如何实现的</h3><p>我们封住个简单的Koa：</p><pre><code>class MyKoa extends Object {    constructor(props) {        super(props);        // 存储所有的中间件        this.middlewares = []    }    // 注入中间件    use (generator) {        this.middlewares.push(generator)    }    // 执行中间件    listen () {        this._run()    }    _run () {        const ctx = this        const middlewares = ctx.middlewares        co(function* () {            let prev = null            let i = middlewares.length            //从最后一个中间件到第一个中间件的顺序开始遍历            while (i--) {                // ctx 作为函数执行时的 this 才能保证多个中间件中数据的共享                //prev 将前面一个中间件传递给当前中间件，才使得中间件里面的 next 指向下一个中间件                prev = middlewares[i].call(ctx, prev);            }            //执行第一个中间件            yield prev;        })    }}</code></pre><p>如何使用呢：</p><pre><code>var app = new MyKoa();app.use(function *(next){    this.body = &apos;1&apos;;    yield next;    this.body += &apos;5&apos;;    console.log(this.body);  // 12345});app.use(function *(next){    this.body += &apos;2&apos;;    yield next;    this.body += &apos;4&apos;;});app.use(function *(next){    this.body += &apos;3&apos;;});app.listen();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript异步（三）————Generator&quot;&gt;&lt;a href=&quot;#JavaScript异步（三）————Generator&quot; class=&quot;headerlink&quot; title=&quot;JavaScript异步（三）————Generator&quot;&gt;&lt;/a&gt;Ja
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://tanyibing.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>javascript异步（二）</title>
    <link href="http://tanyibing.com/2018/09/17/javascript%E5%BC%82%E6%AD%A5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/09/17/javascript异步（二）/</id>
    <published>2018-09-17T06:40:16.000Z</published>
    <updated>2018-09-17T07:16:39.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript异步（二）————Promise"><a href="#JavaScript异步（二）————Promise" class="headerlink" title="JavaScript异步（二）————Promise"></a>JavaScript异步（二）————Promise</h1><h2 id="ES6中的Promise"><a href="#ES6中的Promise" class="headerlink" title="ES6中的Promise"></a>ES6中的Promise</h2><h3 id="写一个传统的异步操作"><a href="#写一个传统的异步操作" class="headerlink" title="写一个传统的异步操作"></a>写一个传统的异步操作</h3><p>我们先写一段异步的代码，然后用promise来封装一下：</p><pre><code>var wait = function () {    var task = function () {        console.log(&apos;执行完成&apos;)    }    setTimeout(task, 2000)}wait()</code></pre><h3 id="用Promise进行封装"><a href="#用Promise进行封装" class="headerlink" title="用Promise进行封装"></a>用Promise进行封装</h3><pre><code>const wait =  function () {    // 定义一个 promise 对象    const promise = new Promise((resolve, reject) =&gt; {        // 将之前的异步操作，包括到这个 new Promise 函数之内        const task = function () {            console.log(&apos;执行完成&apos;)            resolve()  // callback 中去执行 resolve 或者 reject        }        setTimeout(task, 2000)    })    // 返回 promise 对象    return promise}</code></pre><p>我们首先将之前传统的异步方法用<code>new Promise((resolve, reject) =&gt; {...})</code>包装起来，然后return就行了。异步操作的内部，在callback中执行<code>resolve()</code>（表明成功了，失败的话执行reject）。</p><p>我们接下来怎么处理返回的数据呢：</p><pre><code>const w = wait()w.then(() =&gt; {    console.log(&apos;ok 1&apos;)}, () =&gt; {    console.log(&apos;err 1&apos;)}).then(() =&gt; {    console.log(&apos;ok 2&apos;)}, () =&gt; {    console.log(&apos;err 2&apos;)})</code></pre><p>我们调用<code>then</code>方法，这个方法接收两个参数，第一个在成功时（触发resolve）执行，第二个在失败时(触发reject)时执行。而且，then还可以进行链式操作。</p><p>以上就是ES6中Promise的基本使用方法，接下来看一些Promise的常见用法吧。</p><h2 id="Promise在ES6中的常见用法"><a href="#Promise在ES6中的常见用法" class="headerlink" title="Promise在ES6中的常见用法"></a>Promise在ES6中的常见用法</h2><p>为了方便使用，我们首先封装个Promise，为后面使用：</p><pre><code>const fs = require(&apos;fs&apos;)const path = require(&apos;path&apos;)  // 后面获取文件路径时候会用到const readFilePromise = function (fileName) {    return new Promise((resolve, reject) =&gt; {        fs.readFile(fileName, (err, data) =&gt; {            if (err) {                reject(err)  // 注意，这里执行 reject 是传递了参数，后面会有地方接收到这个参数            } else {                resolve(data.toString())  // 注意，这里执行 resolve 时传递了参数，后面会有地方接收到这个参数            }        })    })}</code></pre><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>我们要使用上面封装的readFilePromise读取一个 json 文件../data/data2.json，这个文件内容非常简单：{“a”:100, “b”:200}</p><p>先将文件内容打印出来，代码如下。大家需要注意，readFilePromise函数中，执行<code>resolve(data.toString())</code>传递的参数内容，会被下面代码中的data参数所接收到。</p><pre><code>const fullFileName = path.resolve(__dirname, &apos;../data/data2.json&apos;)const result = readFilePromise(fullFileName)result.then(data =&gt; {    console.log(data)})</code></pre><p>参数传递就是在异步里面通过resolve来传递至，然后就会被第一个<code>then</code>处理时接收到，而且通过<code>then</code>的链式操作可以继续将处理后的值传递下去。</p><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>我们知道then会接收两个参数（函数），第一个参数会在执行resolve之后触发（还能传递参数），第二个参数会在执行reject之后触发（其实也可以传递参数，和resolve传递参数一样），但是上面的例子中，我们没有用到then的第二个参数。这是为何呢 ———— 因为不建议这么用。</p><p>对于Promise中的异常处理，我们建议用catch方法，而不是then的第二个参数。请看下面的代码，以及注释。</p><pre><code>const fullFileName = path.resolve(__dirname, &apos;../data/data2.json&apos;)const result = readFilePromise(fullFileName)result.then(data =&gt; {    console.log(data)    return JSON.parse(data).a}).then(a =&gt; {    console.log(a)).catch(err =&gt; {    console.log(err.stack)  // 这里的 catch 就能捕获 readFilePromise 中触发的 reject ，而且能接收 reject 传递的参数})</code></pre><p>在若干个then串联之后，我们一般会在最后跟一个.catch来捕获异常，而且执行reject时传递的参数也会在catch中获取到。这样做的好处是：</p><ul><li>让程序看起来更加简洁，是一个串联的关系，没有分支（如果用then的两个参数，就会出现分支，影响阅读）</li><li>更像是try - catch的样子，更易理解</li></ul><h3 id="串联多个异步操作"><a href="#串联多个异步操作" class="headerlink" title="串联多个异步操作"></a>串联多个异步操作</h3><p>如果现在有一个需求：先读取data2.json的内容，当成功之后，再去读取data1.json。这样的需求，如果用传统的callback去实现，会变得很麻烦。而且，现在只是两个文件，如果是十几个文件这样做，写出来的代码就没法看了（臭名昭著的callback-hell）。但是用刚刚学到的Promise就可以轻松胜任这项工作：</p><pre><code>const fullFileName2 = path.resolve(__dirname, &apos;../data/data2.json&apos;)const result2 = readFilePromise(fullFileName2)const fullFileName1 = path.resolve(__dirname, &apos;../data/data1.json&apos;)const result1 = readFilePromise(fullFileName1)result2.then(data =&gt; {    console.log(&apos;data2.json&apos;, data)    return result1  // 此处只需返回读取 data1.json 的 Promise 即可}).then(data =&gt; {    console.log(&apos;data1.json&apos;, data) // data 即可接收到 data1.json 的内容})</code></pre><p>上文“参数传递”提到过，如果then有链式操作，前面步骤返回的值，会被后面的步骤获取到。但是，如果前面步骤返回值是一个Promise的话，情况就不一样了。如果前面返回的是Promise对象，后面的then将会被当做这个返回的Promise的第一个then来对待。</p><h3 id="Promise-all-amp-Promise-race"><a href="#Promise-all-amp-Promise-race" class="headerlink" title="Promise.all &amp; Promise.race"></a>Promise.all &amp; Promise.race</h3><p>现在我需要一起读取data1.json和data2.json这两个文件，等待它们全部都被读取完，再做下一步的操作。此时需要用到Promise.all：</p><pre><code>// Promise.all 接收一个包含多个 promise 对象的数组Promise.all([result1, result2]).then(datas =&gt; {    // 接收到的 datas 是一个数组，依次包含了多个 promise 返回的内容    console.log(datas[0])    console.log(datas[1])})</code></pre><p>读取两个文件data1.json和data2.json，现在我需要一起读取这两个文件，但是只要有一个已经读取了，就可以进行下一步的操作。此时需要用到Promise.race：</p><pre><code>// Promise.race 接收一个包含多个 promise 对象的数组Promise.race([result1, result2]).then(data =&gt; {    // data 即最先执行完成的 promise 的返回值    console.log(data)})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript异步（二）————Promise&quot;&gt;&lt;a href=&quot;#JavaScript异步（二）————Promise&quot; class=&quot;headerlink&quot; title=&quot;JavaScript异步（二）————Promise&quot;&gt;&lt;/a&gt;JavaScri
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://tanyibing.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>node中踩的坑（不定时更新）</title>
    <link href="http://tanyibing.com/2018/09/14/node%E4%B8%AD%E8%B8%A9%E7%9A%84%E5%9D%91%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/09/14/node中踩的坑（不定时更新）/</id>
    <published>2018-09-14T09:02:35.000Z</published>
    <updated>2018-09-14T09:16:20.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018-9-14"><a href="#2018-9-14" class="headerlink" title="2018-9-14"></a>2018-9-14</h3><p><strong>问题</strong><br>在Koa中想要使用art-template这个模板引擎，但是使用之后在渲染模板的时候一直报下面的错：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/node/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p><strong>分析</strong><br>报的错说我的路径必须为一个字符串，我重新检查后，发现并不存在语法错误呀，果断去度娘看看，试了几个方法解决不了我的问题，但是反馈最多的一个方法就是node版本和其他的不兼容。我靠！这要重搞工作量有点大，果断换个模板引擎吧。</p><p><strong>解决方法</strong><br>最后回去官网看一看，发现有<code>art-template</code>和<code>koa-art-template</code>之分，但是配置好像没啥区别啊。把引入的模块改成<code>koa-art-template</code>，再试试，成了！什么鬼！不管了，问题暂时是解决了。</p><p><strong>另外附上项目的地址</strong>：<a href="https://github.com/TanYiBing/cms_demo" target="_blank" rel="noopener">https://github.com/TanYiBing/cms_demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2018-9-14&quot;&gt;&lt;a href=&quot;#2018-9-14&quot; class=&quot;headerlink&quot; title=&quot;2018-9-14&quot;&gt;&lt;/a&gt;2018-9-14&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;br&gt;在Koa中想要使用art-templa
      
    
    </summary>
    
      <category term="Node" scheme="http://tanyibing.com/categories/Node/"/>
    
    
      <category term="Node" scheme="http://tanyibing.com/tags/Node/"/>
    
      <category term="Koa" scheme="http://tanyibing.com/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>javascript异步（一）</title>
    <link href="http://tanyibing.com/2018/09/14/javascript%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/09/14/javascript异步（一）/</id>
    <published>2018-09-14T08:06:01.000Z</published>
    <updated>2018-09-14T08:55:17.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript异步（一）"><a href="#JavaScript异步（一）" class="headerlink" title="JavaScript异步（一）"></a>JavaScript异步（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天刚立了个flag，而我这个人向来都是说话不算话的（手动滑稽），为了防止自己半途而废，所以今天先来开个头，开了头就不好回头了。</p><h2 id="异步和单线程有什么关系？"><a href="#异步和单线程有什么关系？" class="headerlink" title="异步和单线程有什么关系？"></a>异步和单线程有什么关系？</h2><h3 id="1-为啥是单线程"><a href="#1-为啥是单线程" class="headerlink" title="1.为啥是单线程"></a>1.为啥是单线程</h3><p><code>JavaScript</code> 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h3 id="2-啥是异步"><a href="#2-啥是异步" class="headerlink" title="2.啥是异步"></a>2.啥是异步</h3><p>我们先看一段代码：</p><pre><code>var i,     t = Date.now();for (i = 0; i &lt; 100000000; i++) {}console.log(Date.now() - t)  // 250</code></pre><p>上面的程序花费 250ms 的时间执行完成，执行过程中就会有卡顿，其他的事儿就先撂一边不管了。</p><p>执行程序这样没有问题，但是对于 JS 最初使用的环境 ———— 浏览器客户端 ———— 就不一样了。因此在浏览器端运行的js，可能会有大量的网络请求，而一个网络资源啥时候返回，这个时间是不可预估的。这种情况也要傻傻的等着、卡顿着、啥都不做吗？———— 那肯定不行。</p><p>因此，JS 对于这种场景就设计了异步 ———— 即，发起一个网络请求，就先不管这边了，先干其他事儿，网络请求啥时候返回结果，到时候再说。这样就能保证一个网页的流程运行。</p><h3 id="3-事件和回调函数"><a href="#3-事件和回调函数" class="headerlink" title="3.事件和回调函数"></a>3.事件和回调函数</h3><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p><p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><h3 id="4-使用回调函数来进行异步操作"><a href="#4-使用回调函数来进行异步操作" class="headerlink" title="4.使用回调函数来进行异步操作"></a>4.使用回调函数来进行异步操作</h3><p>举个栗子：</p><pre><code>var ajax = $.ajax({    url: &apos;/data/data1.json&apos;,    success: function () {        console.log(&apos;success&apos;)    }})</code></pre><p>上面这个<code>ajax</code>操作就是一个异步操作，第二个参数就是一个callback，我们先发个消息出去取一些数据，当然不会立即就能取到，那我们也不闲着，先去干别的，等拿到了通知我们，我们再执行callback进行数据操作。<strong>实现异步的最核心原理，就是将callback作为参数传递给异步执行函数，当有结果返回之后再触发 callback执行，就是如此简单！</strong></p><h3 id="5-常用的异步操作"><a href="#5-常用的异步操作" class="headerlink" title="5.常用的异步操作"></a>5.常用的异步操作</h3><p>开发中我们比较常用的异步操作有;</p><ul><li>网络请求，如 ajax、http</li><li>IO操作，如 readFile、readDir</li><li>定时函数：如 setTimeout、setInterval</li></ul><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p><strong>这一部分让我写肯定显得业余，还是去看看阮一峰老师怎么说吧：</strong><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p><h2 id="事件绑定算不算异步呢？"><a href="#事件绑定算不算异步呢？" class="headerlink" title="事件绑定算不算异步呢？"></a>事件绑定算不算异步呢？</h2><p>我们看一个事件绑定的操作：</p><pre><code>$btn.on(&apos;click&apos;, function (e) {    console.log(&apos;你点击了按钮&apos;)})</code></pre><p>这个写法和我们上面的异步操作是不是一样，都定义了callback，那事件绑定算不算异步操作呢？如果你认真看了阮一峰老师的那篇文章，你就会发现，其实这也是异步操作。为什么我会这么问呢？</p><p>因为它们之间还有有些不同之处的：</p><ul><li>event-loop 执行时，调用的源不一样。异步操作是系统自动调用，无论是setTimeout时间到了还是$.ajax请求返回了，系统会自动调用。而事件绑定就需要用户手动触发。</li><li>从设计上来将，事件绑定有着明显的“订阅-发布”的设计模式，而异步操作却没有。</li></ul><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/js/4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>但是我们从这张图上又可以发现,我们的事件包括了<code>Network</code>和我们的一些鼠标操作，这些都被认为是异步的。其实仔细想想也对，网络请求其实也相当于订阅和发布啊！</p><p>今天的就到这吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript异步（一）&quot;&gt;&lt;a href=&quot;#JavaScript异步（一）&quot; class=&quot;headerlink&quot; title=&quot;JavaScript异步（一）&quot;&gt;&lt;/a&gt;JavaScript异步（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://tanyibing.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>封装个Koa</title>
    <link href="http://tanyibing.com/2018/09/13/%E5%B0%81%E8%A3%85%E4%B8%AAKoa/"/>
    <id>http://tanyibing.com/2018/09/13/封装个Koa/</id>
    <published>2018-09-13T08:39:37.000Z</published>
    <updated>2018-09-13T09:03:23.626Z</updated>
    
    <content type="html"><![CDATA[<p>想了解下<code>Koa</code>是怎么个骚操作，之前使用的是<code>Koa2</code>，里面是<code>async</code>和<code>await</code>，用起来爽歪歪。不过，<code>async</code>和<code>await</code>是ES7里面的东东，还是有必要看一下koa的第一代的，发现里面的中间件是<code>Generator</code>，其实我对这个也不是很理解，ES6里面新增加的，一下子有点难接受，今天就提上日程，看一看怎么搞，自己封装个Koa试试！</p><p>想要真正搞懂这个<code>Generator</code>还是比较烦，我自己感觉整个ES6的主要部分应该就是这个Generator了，相知带它怎么回事先要知道<code>Iterator</code>、然后再看<code>Generator</code>，但是想和异步扯上关系你还要看<code>Chunk</code>函数，还要看看<code>co</code>库，当然啦，<code>Promise</code>肯定要知道，所以感觉这也不是个简单的东西，门道多着呢。</p><p>不说废话了，上代码吧，封装个<code>MyKoa</code>：</p><pre><code>class MyKoa extends Object {    constructor(props) {        super(props);        // 存储所有的中间件        this.middlewares = []    }    // 注入中间件    use (generator) {        this.middlewares.push(generator)    }    // 执行中间件    listen () {        this._run()    }    _run () {        const ctx = this;        const middlewares = ctx.middlewares;        co(function* () {            let prev = null            let i = middlewares.length            //从最后一个中间件到第一个中间件的顺序开始遍历            while (i--) {                // ctx 作为函数执行时的 this 才能保证多个中间件中数据的共享                //prev 将前面一个中间件传递给当前中间件，才使得中间件里面的 next 指向下一个中间件                prev = middlewares[i].call(ctx, prev);            }            //执行第一个中间件            yield prev;        })    }}</code></pre><p>然后可以试验下效果：</p><pre><code>var app = new MyKoa();app.use(function *(next){    this.body = &apos;1&apos;;    yield next;    this.body += &apos;5&apos;;    console.log(this.body);  // 12345});app.use(function *(next){    this.body += &apos;2&apos;;    yield next;    this.body += &apos;4&apos;;});app.use(function *(next){    this.body += &apos;3&apos;;});app.listen();</code></pre><p><strong>其实Generator和我们的回调处理异步的callback根本没有一点关系，它的本质是‘暂停’，并将执行权转移，我们只是给它穿上了一层又一层的外套，强行让它和异步‘发生关系’。</strong></p><p><strong>PS：立个flag，2018年过年之前找个机会，我一定彻彻底底研究次js中的异步！！！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想了解下&lt;code&gt;Koa&lt;/code&gt;是怎么个骚操作，之前使用的是&lt;code&gt;Koa2&lt;/code&gt;，里面是&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;，用起来爽歪歪。不过，&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/co
      
    
    </summary>
    
      <category term="Node" scheme="http://tanyibing.com/categories/Node/"/>
    
    
      <category term="Node" scheme="http://tanyibing.com/tags/Node/"/>
    
      <category term="Koa" scheme="http://tanyibing.com/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>Jade怎么玩</title>
    <link href="http://tanyibing.com/2018/09/13/Jade%E6%80%8E%E4%B9%88%E7%8E%A9/"/>
    <id>http://tanyibing.com/2018/09/13/Jade怎么玩/</id>
    <published>2018-09-13T02:24:18.000Z</published>
    <updated>2018-09-13T02:39:46.179Z</updated>
    
    <content type="html"><![CDATA[<p>前端想要用模板，那就看看<code>Jade</code>吧，打开我们的<a href="http://jade-lang.com/" target="_blank" rel="noopener">Jade官网</a>，上去看看呢，结果发现官网真的很水，水在哪呢？特喵的，给的代码没有一个注意缩进的，这也就导致后面很多模板使用jade命令时报错，有失水准啊！</p><p>好在咋们国人搞的还是比较靠谱：<a href="http://www.nooong.com/docs/jade_chinese.htm" target="_blank" rel="noopener">点这可以学习Jade</a></p><p><strong>你不会真以为我要写个技术博客吧，我只是来吐槽下，Jade很简单，自己去学吧，几分钟就会了。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端想要用模板，那就看看&lt;code&gt;Jade&lt;/code&gt;吧，打开我们的&lt;a href=&quot;http://jade-lang.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jade官网&lt;/a&gt;，上去看看呢，结果发现官网真的很水，水在哪呢？特喵的，给
      
    
    </summary>
    
      <category term="Jade" scheme="http://tanyibing.com/categories/Jade/"/>
    
    
      <category term="Jade" scheme="http://tanyibing.com/tags/Jade/"/>
    
  </entry>
  
  <entry>
    <title>Generator函数</title>
    <link href="http://tanyibing.com/2018/09/12/Generator%E5%87%BD%E6%95%B0/"/>
    <id>http://tanyibing.com/2018/09/12/Generator函数/</id>
    <published>2018-09-12T08:09:54.000Z</published>
    <updated>2018-09-12T09:14:58.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h1><p>昨天的<code>Promise</code>对象就是一种异步编程解决方案，今天再看一种方案，这就是<code>Generator</code>函数。<br>网上有很多关于<code>Generator</code>的介绍，例如：</p><blockquote><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p></blockquote><h2 id="Generator的创建"><a href="#Generator的创建" class="headerlink" title="Generator的创建"></a>Generator的创建</h2><p>接下来我们看一下怎么定义一个Generator函数：</p><pre><code>function* helloWorldGenerator() {    yield &apos;hello&apos;;    yield &apos;world&apos;;    return &apos;ending&apos;;}var hw = helloWorldGenerator();</code></pre><p>我们发现在<code>function</code>关键字和函数名称之间有个星号，这表示这是一个Generator函数。但这样还不行，进入函数我们发现使用了<code>yield</code>表达式，定义了不同的内部状态(<code>yield</code>在英语中就是“产生”的意思)。这样我们一共定义了三个状态：hello、word和一个return语句。</p><h2 id="Generator的调用"><a href="#Generator的调用" class="headerlink" title="Generator的调用"></a>Generator的调用</h2><p>Generator函数返回的是一个遍历器对象，也就是说我们需要调用<code>next</code>方法来遍历函数中的状态：</p><pre><code>hw.next()// { value: &apos;hello&apos;, done: false }hw.next()/ { value: &apos;world&apos;, done: false }hw.next()// { value: &apos;ending&apos;, done: true }hw.next()/ { value: undefined, done: true }</code></pre><p>上面一共运行了四次<code>next</code>方法。</p><p>第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。</p><p>第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。</p><p>第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。</p><p>第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。</p><h2 id="Generator函数的作用"><a href="#Generator函数的作用" class="headerlink" title="Generator函数的作用"></a>Generator函数的作用</h2><p>这个东西看上去好像没啥用，那么它到底能干点啥呢？</p><h3 id="把异步回调变成‘同步’代码"><a href="#把异步回调变成‘同步’代码" class="headerlink" title="把异步回调变成‘同步’代码"></a>把异步回调变成‘同步’代码</h3><p>例如我们写个ajax代码：</p><pre><code>ajax(&apos;http://url-1&apos;, data1, function (err, result) {    if (err) {        return handle(err);    }    ajax(&apos;http://url-2&apos;, data2, function (err, result) {        if (err) {            return handle(err);        }        ajax(&apos;http://url-3&apos;, data3, function (err, result) {            if (err) {                return handle(err);            }            return success(result);        });    });});</code></pre><p>这个代码简直不想看，那么我们可以用Generator来改造下：</p><pre><code>try {    r1 = yield ajax(&apos;http://url-1&apos;, data1);    r2 = yield ajax(&apos;http://url-2&apos;, data2);    r3 = yield ajax(&apos;http://url-3&apos;, data3);    success(r3);}catch (err) {    handle(err);}</code></pre><p>这样看上去好多了，但不是真正的同步代码，至少看上去很像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Generator函数&quot;&gt;&lt;a href=&quot;#Generator函数&quot; class=&quot;headerlink&quot; title=&quot;Generator函数&quot;&gt;&lt;/a&gt;Generator函数&lt;/h1&gt;&lt;p&gt;昨天的&lt;code&gt;Promise&lt;/code&gt;对象就是一种异步编程解
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://tanyibing.com/categories/ECMAScript6/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
      <category term="ECMAScript6" scheme="http://tanyibing.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>Promise对象</title>
    <link href="http://tanyibing.com/2018/09/11/Promise%E5%AF%B9%E8%B1%A1/"/>
    <id>http://tanyibing.com/2018/09/11/Promise对象/</id>
    <published>2018-09-11T08:07:08.000Z</published>
    <updated>2018-09-11T08:56:57.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h1><h2 id="Promise的介绍"><a href="#Promise的介绍" class="headerlink" title="Promise的介绍"></a>Promise的介绍</h2><p><code>Promise</code>在<code>ECMAScript6</code>中被正式写进了语言标准，这是异步编程的一种解决方案，较之传统的函数回调和事件，<code>Promise</code>来得更加强大。<br><code>Promise</code>被理解成一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br><code>Promise</code>有三个状态，分别是：</p><ul><li><code>pending</code>：进行中</li><li><code>fulfilled</code>：已成功</li><li><code>rejected</code>：已失败</li></ul><p>这三个状态是根据异步操作的结果来决定的，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。这三个状态一旦确定就不会在改变了。</p><h2 id="Promise的使用"><a href="#Promise的使用" class="headerlink" title="Promise的使用"></a>Promise的使用</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>怎么创建一个Promise实例呢：</p><pre><code>const promise = new Promise(function(resolve, reject) {    // ... some code    if (/* 异步操作成功 */){        resolve(value);    } else {        reject(error);    }});</code></pre><p>其中两个方法，<code>resolve</code>用来处理异步操作成功的结果，将其结果传递出去，在后面的<code>then</code>方法中去接受，<code>reject</code>用来处理操作失败的结果并传递出去，也可用<code>then</code>方法接收。</p><h3 id="then方法的使用"><a href="#then方法的使用" class="headerlink" title="then方法的使用"></a>then方法的使用</h3><p><code>Promise</code>实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数：</p><pre><code>promise.then(function(value) {    // success}, function(error) {    // failure});</code></pre><p>其中第二个函数是可选的。这两个函数就是用来接收上面传出来的结果的。而且需要注意的是<strong>then方法返回是一个新的Promise，也就是说我们可以进行链式编程。</strong></p><h3 id="Promise执行顺序"><a href="#Promise执行顺序" class="headerlink" title="Promise执行顺序"></a>Promise执行顺序</h3><p><code>Promise</code>在新建之后就会立即执行，举个例子：</p><pre><code>let promise = new Promise(function(resolve, reject) {    console.log(&apos;a&apos;);    resolve();});promise.then(function() {    console.log(&apos;b&apos;);});console.log(&apos;c&apos;);// a// c// b</code></pre><p>上面的代码先输出a，因为Promise新建之后就立即执行，<code>then</code>方法在当前脚本所有同步任务执行完才执行，最后才会输出b。</p><h2 id="Promise和其他技术"><a href="#Promise和其他技术" class="headerlink" title="Promise和其他技术"></a>Promise和其他技术</h2><p>昨天我看了RxJS，发现这两货好像有点像，一个是把所有数据都变成流进行操作。一个是一直返回<code>Promise</code>，通过<code>then</code>方法一直链式操作，那就比较一下吧。</p><table><thead><tr><th style="text-align:center">操作</th><th>可观察对象</th><th>承诺</th></tr></thead><tbody><tr><td style="text-align:center">创建</td><td>new Observable((observer) =&gt; {observer.next(123);});</td><td>new Promise((resolve, reject) =&gt; {resolve(123);});</td></tr><tr><td style="text-align:center">转换</td><td>obs.map((value) =&gt; value * 2 );</td><td>promise.then((value) =&gt; value * 2);</td></tr><tr><td style="text-align:center">订阅</td><td>sub = obs.subscribe((value) =&gt; {console.log(value)});</td><td>promise.then((value) =&gt; {console.log(value);});</td></tr><tr><td style="text-align:center">取消订阅</td><td>sub.unsubscribe();</td><td>承诺被解析时隐式完成。</td></tr></tbody></table><h2 id="Promise的应用"><a href="#Promise的应用" class="headerlink" title="Promise的应用"></a>Promise的应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p><pre><code>const preloadImage = function (path) {    return new Promise(function (resolve, reject) {        const image = new Image();        image.onload  = resolve;        image.onerror = reject;        image.src = path;    });};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Promise对象&quot;&gt;&lt;a href=&quot;#Promise对象&quot; class=&quot;headerlink&quot; title=&quot;Promise对象&quot;&gt;&lt;/a&gt;Promise对象&lt;/h1&gt;&lt;h2 id=&quot;Promise的介绍&quot;&gt;&lt;a href=&quot;#Promise的介绍&quot; cla
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://tanyibing.com/categories/ECMAScript6/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
      <category term="ECMAScript6" scheme="http://tanyibing.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>初入RxJS</title>
    <link href="http://tanyibing.com/2018/09/10/%E5%88%9D%E5%85%A5RxJS/"/>
    <id>http://tanyibing.com/2018/09/10/初入RxJS/</id>
    <published>2018-09-10T03:21:19.000Z</published>
    <updated>2018-09-10T09:15:42.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>刚开始接触angular的时候就发现，RxJS在angular中是使用的最多的框架。它的全称是：<code>Reactive Extension</code>。这套框架其实是源自于微软，微软在2011年就已经开发出这套框架了，但真正火起来是在NetFlix，支持很多语言的一套响应式编程的框架，感兴趣可以去它的官网看看：<a href="reactivex.io">reactivex.io</a>，支持了这么多语言！！！</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>它的优势在于：<code>在思考的维度上加上时间考量。</code>，这也是一个问题，导致更难理解！</p><h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><h3 id="Observable的性质"><a href="#Observable的性质" class="headerlink" title="Observable的性质"></a>Observable的性质</h3><p>Observable有三种状态，分别是：</p><ul><li><code>next</code>：必要。用来处理每个送达值。在开始执行后可能执行零次或多次。</li><li><code>error</code>：可选。用来处理错误通知。错误会中断这个可观察对象实例的执行过程。</li><li><code>complete</code>：可选。用来处理执行完毕（complete）通知。当执行完毕后，这些值就会继续传给下一个处理器。 </li></ul><p>还有特殊的Observable：<code>永不结束的</code>、<code>Never</code>、<code>Empty（结束但不发射）</code>、<code>Throw</code></p><p>本来是想写介绍点操作符的，但是我发现没啥意思，反正文档都能查到，那就记录点自己对Observable的理解吧，具体操作符到时候查api。<br>其实Observable就是将数据以流的形式来进行处理，可以理解成node中的流，我们可以对流进行一系列的操作，最后我们再订阅这个流，对流里面的数据进行使用。</p><p>举个例子吧:</p><pre><code>const a: Array&lt;number&gt; = [1, 2, 3, 4];const a$ = Rx.Observable.from(a).pipe(map( val =&gt; val * val));const observer = {    next: (val) =&gt; console.log(val);    error： (err) =&gt; console.log(err);    complete: () =&gt; console.log(`everything is completed`);}a$.subscribe(observer);</code></pre><p>上面的例子会打印出：</p><blockquote><p>1 4 9 16</p></blockquote><p>因为我们对流中的数据进行了map操作，使它们自己乘以自己。这就是对流的一个简单处理，连<code>pipe</code>方法都和node中的流一样。</p><h3 id="Observable的冷和热"><a href="#Observable的冷和热" class="headerlink" title="Observable的冷和热"></a>Observable的冷和热</h3><p>Observable有两种，一种是冷的，一种是热的。怎么去理解呢？<strong>下面的内容在angular的官网上并没有说明</strong></p><ul><li>冷的就是表示，每次你订阅之后我们都会从头执行一遍，就像看重播一样，点击之后都是重头开始播放；</li><li>热代表每次订阅之后大家之间的进度是一样的，就像看直播一样，打开之后都是最新时刻的通知。</li></ul><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RxJS&quot;&gt;&lt;a href=&quot;#RxJS&quot; class=&quot;headerlink&quot; title=&quot;RxJS&quot;&gt;&lt;/a&gt;RxJS&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>angular动画</title>
    <link href="http://tanyibing.com/2018/09/07/angular%E5%8A%A8%E7%94%BB/"/>
    <id>http://tanyibing.com/2018/09/07/angular动画/</id>
    <published>2018-09-07T06:48:12.000Z</published>
    <updated>2018-09-10T01:08:20.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular动画"><a href="#Angular动画" class="headerlink" title="Angular动画"></a>Angular动画</h1><p>在angular2的时候，angular动画还是个核心的组件库，但是到了angular4的时候，为了减小核心库的体积，所以移除出核心组件。但并不是不重要，它依然是angular中很重要的组成部分，而且也是官方提供的支持。</p><p><em>angular动画架构其实很简单，就是在组件里面定义数个触发器，每个触发器会有一系列的状态和过渡效果，其实这就是动画。</em></p><h2 id="State-amp-Transiton（这两个是核心）"><a href="#State-amp-Transiton（这两个是核心）" class="headerlink" title="State &amp; Transiton（这两个是核心）"></a>State &amp; Transiton（这两个是核心）</h2><ul><li>动画其实就是从一个状态过渡到另一个状态</li><li>状态本身包含形状、颜色、大小等等</li><li>State就是定义状态而Transition是定义如何过渡</li></ul><h2 id="Animate函数"><a href="#Animate函数" class="headerlink" title="Animate函数"></a>Animate函数</h2><p><strong>其实在Transition函数中，还会调用另一个函数，那就是Animate</strong></p><ul><li>Animate规定了具体怎么样过渡，比如时间、过渡的速度等</li><li>Animate有多个重载形式</li></ul><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><h3 id="引入关键模块并声明"><a href="#引入关键模块并声明" class="headerlink" title="引入关键模块并声明"></a>引入关键模块并声明</h3><pre><code>import { BrowserModule } from &apos;@angular/platform-browser&apos;;import { BrowserAnimationsModule } from &apos;@angular/platform-browser/animations&apos;;@NgModule({    imports: [         BrowserModule,        BrowserAnimationsModule     ],})export class AppModule { }</code></pre><p>建议在<code>imports</code>中最后引入<code>BrowserAnimationsModule</code>模块，放在前面可能会踩坑。</p><h3 id="定义各种状态"><a href="#定义各种状态" class="headerlink" title="定义各种状态"></a>定义各种状态</h3><p>拿个官网的例子来看看：</p><pre><code>@Component({    ...    //这里是一些正常的定义    animations: [        trigger(&apos;heroState&apos;, [        state(&apos;inactive&apos;, style({            backgroundColor: &apos;#eee&apos;,            transform: &apos;scale(1)&apos;        })),        state(&apos;active&apos;,   style({            backgroundColor: &apos;#cfd8dc&apos;,            transform: &apos;scale(1.1)&apos;        })),        transition(&apos;inactive =&gt; active&apos;, animate(&apos;100ms ease-in&apos;)),        transition(&apos;active =&gt; inactive&apos;, animate(&apos;100ms ease-out&apos;))        ])    ]})</code></pre><p>这里定义了两个状态，一个是<code>active</code>还有个是<code>incative</code>，这两个状态分别有不同的style样式，transition定义了从不同状态过渡到另一个状态的过程。</p><h3 id="附加到模板上"><a href="#附加到模板上" class="headerlink" title="附加到模板上"></a>附加到模板上</h3><pre><code>template: `    &lt;ul&gt;        &lt;li *ngFor=&quot;let hero of heroes&quot;            [@heroState]=&quot;hero.state&quot;            (click)=&quot;hero.toggleState()&quot;&gt;            {{hero.name}}        &lt;/li&gt;    &lt;/ul&gt;    `</code></pre><p>只要使用<code>[@triggerName]</code>语法加到模板上就行了。这就是一个简单的动画效果。</p><p><strong>更多的深入知识，例如缓动函数、关键帧需要的话可以去官网看看，在这贴两个好玩的网址出来：</strong></p><p><a href="https://easings.net/zh-cn" target="_blank" rel="noopener">https://easings.net/zh-cn</a><br><a href="http://cubic-bezier.com/#.17,.67,.83,-0.63" target="_blank" rel="noopener">http://cubic-bezier.com/#.17,.67,.83,-0.63</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Angular动画&quot;&gt;&lt;a href=&quot;#Angular动画&quot; class=&quot;headerlink&quot; title=&quot;Angular动画&quot;&gt;&lt;/a&gt;Angular动画&lt;/h1&gt;&lt;p&gt;在angular2的时候，angular动画还是个核心的组件库，但是到了angula
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>angular实战中踩过的坑（不定时更新）</title>
    <link href="http://tanyibing.com/2018/09/07/angular%E5%AE%9E%E6%88%98%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/09/07/angular实战中踩过的坑（不定时更新）/</id>
    <published>2018-09-07T04:08:48.000Z</published>
    <updated>2018-09-14T09:06:22.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态表单中踩过的坑"><a href="#动态表单中踩过的坑" class="headerlink" title="动态表单中踩过的坑"></a>动态表单中踩过的坑</h2><h3 id="2018-9-7"><a href="#2018-9-7" class="headerlink" title="2018-9-7"></a>2018-9-7</h3><p><strong>问题：</strong><br>今天在写动态表单时遇到个问题，我在控制器中生成的<code>formControl</code>死活就是拿不到我输入的值。</p><p><strong>分析：</strong><br>生成<code>formControl</code>的代码肯定没有问题：</p><pre><code>let fb = new FormBuilder();this.formModel = fb.group({  title: [&apos;&apos;, Validators.minLength(3)],  price: [null, this.positiveNumberValidator],  category: [&apos;-1&apos;]});</code></pre><p>对吧，是没有问题，那肯定就是出在绑定模板的时候，于是我们认真看看吧。</p><p><strong>问题根源：</strong></p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>发现了吧，这个<code>Name</code>由于打快了，打成了小写！低级错误！以后拼写细心点！</p><hr><h2 id="版本更新问题"><a href="#版本更新问题" class="headerlink" title="版本更新问题"></a>版本更新问题</h2><p><strong>问题：</strong><br>我想要做个商品筛选的功能，其中我需要使用<code>debounceTime</code>方法来对我的输入行为产生一个延时的处理，我的调用方法如下：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>引入的是：</p><blockquote><p>import ‘rxjs/RW’;</p></blockquote><p>结果引入报错。</p><p><strong>分析：</strong><br>既然引入报错肯定是更新过了，目录结构发生变化了，甚至连方法的使用也有可能改变了，还是去官方找找吧。</p><p><strong>问题根源：</strong><br>一查果然是更新的问题，而且不出意料，方法也需要修改下，经过修改后引入的方式如下：</p><blockquote><p>import { debounceTime } from ‘rxjs/operators’;</p></blockquote><p>方法也需要改进成下面这种:</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态表单中踩过的坑&quot;&gt;&lt;a href=&quot;#动态表单中踩过的坑&quot; class=&quot;headerlink&quot; title=&quot;动态表单中踩过的坑&quot;&gt;&lt;/a&gt;动态表单中踩过的坑&lt;/h2&gt;&lt;h3 id=&quot;2018-9-7&quot;&gt;&lt;a href=&quot;#2018-9-7&quot; class=&quot;
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Koa中使用Cookie &amp; Session</title>
    <link href="http://tanyibing.com/2018/09/06/Koa%E4%B8%AD%E4%BD%BF%E7%94%A8Cookie-Session/"/>
    <id>http://tanyibing.com/2018/09/06/Koa中使用Cookie-Session/</id>
    <published>2018-09-06T02:43:21.000Z</published>
    <updated>2018-09-06T03:20:32.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="koa中cookie和session使用"><a href="#koa中cookie和session使用" class="headerlink" title="koa中cookie和session使用"></a>koa中cookie和session使用</h1><hr><h3 id="cookie介绍"><a href="#cookie介绍" class="headerlink" title="cookie介绍"></a>cookie介绍</h3><p>cookie 是存储于访问者的计算机中的变量（客户端）。可以让我们用同一个浏览器访问同一个域名的时候共享数据。那为什么不使用http呢？很简单，因为HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。</p><h3 id="cookie用处"><a href="#cookie用处" class="headerlink" title="cookie用处"></a>cookie用处</h3><p>随便举几个例子：</p><ol><li>存储用户信息，例如登陆信息。</li><li>浏览历史记录。</li><li>猜你喜欢的功能。</li><li>10天免登陆。</li><li>多个页面之间的数据传递。</li><li>实现购物车功能。</li></ol><h3 id="Koa-Cookie的使用"><a href="#Koa-Cookie的使用" class="headerlink" title="Koa Cookie的使用"></a>Koa Cookie的使用</h3><h6 id="Koa中设置Cookie的值"><a href="#Koa中设置Cookie的值" class="headerlink" title="Koa中设置Cookie的值"></a>Koa中设置Cookie的值</h6><pre><code>ctx.cookies.set(name, value, [options])</code></pre><p>通过options设置cookie name的value:</p><table><thead><tr><th style="text-align:center">options名称</th><th>options值</th></tr></thead><tbody><tr><td style="text-align:center">maxAge</td><td>一个数字表示从 Date.now() 得到的毫秒数。</td></tr><tr><td style="text-align:center">expires</td><td>cookie 过期的 Date</td></tr><tr><td style="text-align:center">path</td><td>cookie 路径, 默认是’/‘。</td></tr><tr><td style="text-align:center">secure</td><td>安全 cookie 默认 false，设置成 true 表示只有 https 可以访问。</td></tr><tr><td style="text-align:center">httpOnly</td><td>是否只是服务器可访问 cookie, 默认是 true</td></tr><tr><td style="text-align:center">overwrite</td><td>一个布尔值，表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（不管路径或域）是否在设置此 Cookie 时从Set-Cookie 标头中过滤掉。</td></tr></tbody></table><h6 id="Koa中设置中文Cookie"><a href="#Koa中设置中文Cookie" class="headerlink" title="Koa中设置中文Cookie"></a>Koa中设置中文Cookie</h6><pre><code>console.log(new Buffer(&apos;hello, world!&apos;).toString(&apos;base64&apos;));// 转换成 base64 字符串：aGVsbG8sIHdvcmxkIQ==console.log(new Buffer(&apos;aGVsbG8sIHdvcmxkIQ==&apos;, &apos;base64&apos;).toString());// 还原 base64 字符串：hello, world!</code></pre><hr><h3 id="Session介绍"><a href="#Session介绍" class="headerlink" title="Session介绍"></a>Session介绍</h3><p>session 是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。</p><h3 id="Session-的工作流程"><a href="#Session-的工作流程" class="headerlink" title="Session 的工作流程"></a>Session 的工作流程</h3><p>当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session 对象，生成一个类似于 key,value的键值对，然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的Session(value)。 客户的信息都保存在Session中。</p><h3 id="koa-session-的使用"><a href="#koa-session-的使用" class="headerlink" title="koa-session 的使用"></a>koa-session 的使用</h3><pre><code>npm install koa-session --save</code></pre><h6 id="引入-express-session"><a href="#引入-express-session" class="headerlink" title="引入 express-session"></a>引入 express-session</h6><pre><code>const session = require(&apos;koa-session&apos;);</code></pre><h6 id="设置官方文档提供的中间件"><a href="#设置官方文档提供的中间件" class="headerlink" title="设置官方文档提供的中间件"></a>设置官方文档提供的中间件</h6><pre><code>app.keys = [&apos;some secret hurr&apos;];const CONFIG = {    key: &apos;koa:sess&apos;, //cookie key (default is koa:sess)    maxAge: 86400000, // cookie 的过期时间 maxAge in ms (default is 1 days)    overwrite: true, //是否可以 overwrite (默认 default true)    httpOnly: true, //cookie 是否只有服务器端可以访问 httpOnly or not (default true)    signed: true, //签名默认 true    rolling: false, //在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false）    renew: false, //(boolean) renew session when session is nearly expired,};app.use(session(CONFIG, app));</code></pre><h6 id="Cookie-和-Session-区别"><a href="#Cookie-和-Session-区别" class="headerlink" title="Cookie 和 Session 区别"></a>Cookie 和 Session 区别</h6><ol><li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li><li>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗考虑到安全应当使用 session。</li><li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE。</li><li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;koa中cookie和session使用&quot;&gt;&lt;a href=&quot;#koa中cookie和session使用&quot; class=&quot;headerlink&quot; title=&quot;koa中cookie和session使用&quot;&gt;&lt;/a&gt;koa中cookie和session使用&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Node" scheme="http://tanyibing.com/categories/Node/"/>
    
    
      <category term="Node" scheme="http://tanyibing.com/tags/Node/"/>
    
      <category term="Koa" scheme="http://tanyibing.com/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>分享按钮功能的实现</title>
    <link href="http://tanyibing.com/2018/09/05/%E5%88%86%E4%BA%AB%E6%8C%89%E9%92%AE%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://tanyibing.com/2018/09/05/分享按钮功能的实现/</id>
    <published>2018-09-05T09:07:22.000Z</published>
    <updated>2018-09-05T09:35:24.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Facebook分享功能事项"><a href="#Facebook分享功能事项" class="headerlink" title="Facebook分享功能事项"></a>Facebook分享功能事项</h3><p>今天需要实现一个点击按钮进行分享的功能，而且需要是多平台，之前了解过应该是通过调用各个平台的api进行实现的，没办法，去网上找找方法吧。</p><p>首先找个Facebook的实现看看效果，当你只是想分享一个链接到facebook中的时候，我们只需要将分享的url作为参数的形式传递到facebook网站即可，如下：</p><blockquote><p>“<a href="http://www.facebook.com/sharer/sharer.php?u=&quot;" target="_blank" rel="noopener">http://www.facebook.com/sharer/sharer.php?u=&quot;</a> + url;</p></blockquote><p>当然也可以当成参数的形式传递：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;share_button&quot; type=&quot;button&quot; value=&quot;share to facebook&quot; /&gt;    &lt;script type=&quot;text/JavaScript&quot;&gt;        function popupwindow(url, title, w, h) {            wLeft = window.screenLeft ? window.screenLeft : window.screenX;            wTop = window.screenTop ? window.screenTop : window.screenY;            var left = wLeft + (window.innerWidth / 2) - (w / 2);            var top = wTop + (window.innerHeight / 2) - (h / 2);            return window.open(url, title, &apos;toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=&apos; + w + &apos;, height=&apos; + h + &apos;, top=&apos; + top + &apos;, left=&apos; + left);        }        window.onload = function () {            document.getElementById(&apos;share_button&apos;).onclick = function(){                var shareUrl = &quot;http://www.facebook.com/sharer/sharer.php?u=https://www.google.com&quot;;                popupwindow(shareUrl, &apos;Facebook&apos;, 600, 400);            }        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上面虽然分享成功了，但是分享的内容显得很死板，只有一些文字，如何自定义我们的内容呢？我们需要在被分享的网站的页面上添加一些<code>meta</code>标签，facebook会自己从所分享的页面上去抓取这些标签里的内容，你可以自定义图片、描述等等。</p><p>在定义了这些之后就更加生动了：</p><pre><code>&lt;meta property=&quot;og:title&quot; content=&quot;百度&quot;&gt;&lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;&lt;meta property=&quot;og:image&quot; content=&quot;www.baidu.com/img/bd_logo1.png&quot;&gt;&lt;meta property=&quot;og:description&quot; content=&quot;百度一下，你就知道&quot;&gt;</code></pre><p>当然，你可能想动态的去生成这些东西，这就复杂一些，需要用到facebook中的Javascript SDK:</p><pre><code>&lt;script&gt;  window.fbAsyncInit = function() {    FB.init({      appId            : &apos;your-app-id&apos;,      autoLogAppEvents : true,      xfbml            : true,      version          : &apos;v2.10&apos;    });    FB.AppEvents.logPageView();  };  (function(d, s, id){     var js, fjs = d.getElementsByTagName(s)[0];     if (d.getElementById(id)) {return;}     js = d.createElement(s); js.id = id;     js.src = &quot;//connect.facebook.net/en_US/sdk.js&quot;;     fjs.parentNode.insertBefore(js, fjs);   }(document, &apos;script&apos;, &apos;facebook-jssdk&apos;));&lt;/script&gt;</code></pre><p>在他们的<a href="https://developers.facebook.com/docs/javascript/quickstart" target="_blank" rel="noopener">官网</a>可以看更多。</p><p>我们还可以通过facebook develop来检测你要分享的网站的效果，并且在这里可以生成使用sdk所需要的appid，而且可以在这里看到网址的被转发数，点击数之类的。</p><hr><p><strong>这样就完成facebook的分享功能了，但他喵的是不是也太麻烦了，果断找找有没有别的方法，难道你还真以为我会一个个写下去！！！？？？结果还真找到了一个方法，那就是Mob上面的ShareSDK啦。</strong></p><p>怎么实现？首先在里面找到你需要的简单的，首先在下图中找到你要的，然后傻瓜式写代码就行了</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><pre><code>&lt;!--MOB SHARE BEGIN--&gt;&lt;div class=&quot;-mob-share-ui-button -mob-share-open&quot;&gt;分享&lt;/div&gt;&lt;div class=&quot;-mob-share-ui&quot; style=&quot;display: none&quot;&gt;    &lt;ul class=&quot;-mob-share-list&quot;&gt;        &lt;li class=&quot;-mob-share-weibo&quot;&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt;        &lt;li class=&quot;-mob-share-qzone&quot;&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt;        &lt;li class=&quot;-mob-share-qq&quot;&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt;        &lt;li class=&quot;-mob-share-douban&quot;&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt;        &lt;li class=&quot;-mob-share-facebook&quot;&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt;        &lt;li class=&quot;-mob-share-twitter&quot;&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div class=&quot;-mob-share-close&quot;&gt;取消&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;-mob-share-ui-bg&quot;&gt;&lt;/div&gt;&lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey=你的appkey&quot;&gt;&lt;/script&gt;&lt;!--MOB SHARE END--&gt;</code></pre><p>这是最简单的一种，至于怎么扩展，文档写的很清楚，也很傻瓜式，我就不再傻瓜式的写出来了，影响我的形象。啦啦啦啦！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Facebook分享功能事项&quot;&gt;&lt;a href=&quot;#Facebook分享功能事项&quot; class=&quot;headerlink&quot; title=&quot;Facebook分享功能事项&quot;&gt;&lt;/a&gt;Facebook分享功能事项&lt;/h3&gt;&lt;p&gt;今天需要实现一个点击按钮进行分享的功能，而且
      
    
    </summary>
    
      <category term="Web SDK" scheme="http://tanyibing.com/categories/Web-SDK/"/>
    
    
      <category term="Web SDK" scheme="http://tanyibing.com/tags/Web-SDK/"/>
    
  </entry>
  
  <entry>
    <title>angular应用的构建和部署</title>
    <link href="http://tanyibing.com/2018/09/04/angular%E5%BA%94%E7%94%A8%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
    <id>http://tanyibing.com/2018/09/04/angular应用的构建和部署/</id>
    <published>2018-09-04T02:11:32.000Z</published>
    <updated>2018-09-07T06:49:35.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一步-构建"><a href="#第一步-构建" class="headerlink" title="第一步 构建"></a>第一步 构建</h3><p>我们知道我们的angular应用是使用Typescript进行编写的，而浏览器不能直接运行Typescript，而且我们的样式可能是使用scss编写的，我们需要将这所有的一切进行整合，构建成浏览器能看得懂的文件。索性的是angular cli工具已经帮我们准备好了一切，我们只要执行一条命令就行了：</p><blockquote><p>ng build</p></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>然后我们就得到了这样一个dist文件夹，这样我们就已经构建好了。</p><hr><h3 id="第二步-部署"><a href="#第二步-部署" class="headerlink" title="第二步 部署"></a>第二步 部署</h3><p>部署简单啊，例如node的服务器，直接新建一个目录，然后把dist里面的文件都复制进去就行了，这样就算是部署完成了。</p><hr><h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>为了让我们的项目能在多种环境下都能运行，我们需要做多环境配置，具体配置方法还在研究中！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一步-构建&quot;&gt;&lt;a href=&quot;#第一步-构建&quot; class=&quot;headerlink&quot; title=&quot;第一步 构建&quot;&gt;&lt;/a&gt;第一步 构建&lt;/h3&gt;&lt;p&gt;我们知道我们的angular应用是使用Typescript进行编写的，而浏览器不能直接运行Typescrip
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>angular中的两种表单</title>
    <link href="http://tanyibing.com/2018/09/03/angular%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A1%A8%E5%8D%95/"/>
    <id>http://tanyibing.com/2018/09/03/angular中的两种表单/</id>
    <published>2018-09-03T06:44:55.000Z</published>
    <updated>2018-09-07T06:49:38.850Z</updated>
    
    <content type="html"><![CDATA[<p>表单forms是前端中很重要的一块内容，Angular中同样如此。在Angular中，有两种表单的形式，一种是<code>模板驱动表单</code>，还有一种是<code>响应式表单</code>。接下来就简单的介绍一下：</p><h2 id="模版驱动表单"><a href="#模版驱动表单" class="headerlink" title="模版驱动表单"></a>模版驱动表单</h2><p>区别：只能在模板中操作，不能在代码中操作。<br>不说了，直接上个表单：</p><pre><code>&lt;form #myForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(myForm.value)&quot;&gt;    &lt;div&gt;用户名：&lt;input ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt;    &lt;div&gt;手机号：&lt;input ngModel name=&quot;mobile&quot; type=&quot;number&quot;&gt;&lt;/div&gt;    &lt;div ngModelGroup=&quot;passwordsGroup&quot;&gt;        &lt;div&gt;密码：&lt;input ngModel name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/div&gt;        &lt;div&gt;确认密码：&lt;input ngModel name=&quot;pconfirm&quot; type=&quot;password&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt;</code></pre><h2 id="响应式表单"><a href="#响应式表单" class="headerlink" title="响应式表单"></a>响应式表单</h2><p>区别：只能在代码中操作，不能在模板中操作。<br>响应式表单一共分为两步：</p><h3 id="创建数据模型"><a href="#创建数据模型" class="headerlink" title="创建数据模型"></a>创建数据模型</h3><p>由三个类组成：<code>FormControl</code>、<code>FormGroup</code>、<code>FormArray</code>，怎么创建呢？直接贴出代码：</p><pre><code>export class ReactiveFormComponent implements OnInit {    username: FormControl = new FormControl(&apos;username&apos;);    formModel: FormGroup = new FormGroup({        dateRange: new FormGroup({            from: new FormControl(),            to: new FormControl()        }),        emails: FormArray = new FormArray([            new FormControl(&quot;a@a.com&quot;),            new FormControl(&quot;b@b.com&quot;)        ]);    });    }</code></pre><h3 id="使用响应式表单指令绑定表单模版"><a href="#使用响应式表单指令绑定表单模版" class="headerlink" title="使用响应式表单指令绑定表单模版"></a>使用响应式表单指令绑定表单模版</h3><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><pre><code>html&lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt;    &lt;div formGroupName=&quot;dateRange&quot;&gt;        起始日期：&lt;input type=&quot;date&quot; formControlName=&quot;from&quot;&gt;        截止日期：&lt;input type=&quot;date&quot; formControlName=&quot;to&quot;&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;ul formArryName=&quot;emails&quot;&gt;            &lt;li *ngFor=&quot;let e of this.formModel.get(&apos;emails&apos;).controls; let i = index;&quot;&gt;                &lt;input type=&quot;text&quot; [formControlName]=&quot;i&quot;&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;button type=&quot;button&quot; (click)=&quot;addEmail()&quot;&gt;增加email&lt;/button&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt;    &lt;/div&gt;&lt;/form&gt;jsaddEmail(){    let emails = this.formModel.get(&quot;emails&quot;) as FormArray;    emails.push(new FormControl());}</code></pre><p>这样看上去是不是代码很多，有个简化的方法就是使用<code>FormBuilder</code>，使用首先要引入，然后再<code>constructor</code>中注册，然后给个对比吧：</p><pre><code>profileForm = new FormGroup({    firstName: new FormControl(&apos;&apos;),    lastName: new FormControl(&apos;&apos;),    address: new FormGroup({        street: new FormControl(&apos;&apos;),        city: new FormControl(&apos;&apos;),        state: new FormControl(&apos;&apos;),        zip: new FormControl(&apos;&apos;)    })});</code></pre><p>上面的等同于：</p><pre><code>profileForm = this.fb.group({    firstName: [&apos;&apos;],    lastName: [&apos;&apos;],    address: this.fb.group({        street: [&apos;&apos;],        city: [&apos;&apos;],        state: [&apos;&apos;],        zip: [&apos;&apos;]    }),});</code></pre><p><code>FormGroup</code>用<code>this.fb.group</code>替代，<code>FormContrl</code>用<code>[&#39;&#39;]</code>替代,怎么进行校验，我的天，又是好多字，今天就先这样吧！！！反正是我自己看的，我记得就行了！！！哈哈哈！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;表单forms是前端中很重要的一块内容，Angular中同样如此。在Angular中，有两种表单的形式，一种是&lt;code&gt;模板驱动表单&lt;/code&gt;，还有一种是&lt;code&gt;响应式表单&lt;/code&gt;。接下来就简单的介绍一下：&lt;/p&gt;
&lt;h2 id=&quot;模版驱动表单&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>angular生命周期钩子</title>
    <link href="http://tanyibing.com/2018/09/02/angular%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/"/>
    <id>http://tanyibing.com/2018/09/02/angular生命周期钩子/</id>
    <published>2018-09-02T14:40:24.000Z</published>
    <updated>2018-09-07T06:49:10.796Z</updated>
    
    <content type="html"><![CDATA[<p>Angular中每个组件都有它的生命周期，从创建、渲染，到变更检测，再到最后的销毁过程过程，Angular一共提供了<strong>八个</strong>生命周期钩子，他们按照顺序分别是：<code>constructor</code>、<code>ngOnChanges</code>、<code>ngOnInit</code>、<code>ngDoCheck</code>、<code>ngAfterContentInit</code>、<code>ngAfterContentChecked</code>、<code>ngAfterViewInit</code>、<code>ngAfterViewChecked</code>、<code>ngOnDestroy</code>，其中有的钩子在生命周期内只调用一次，有的则可以反复调用（变更检测机制中需要调用方法）。如下图：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>其中红色的表示只调一次，绿色的则可以被多次调用。我们将介绍其中重要的几个方法。</p><h4 id="ngOnChanges"><a href="#ngOnChanges" class="headerlink" title="ngOnChanges:"></a>ngOnChanges:</h4><p>这个钩子在父组件初始化或修改子组件的<strong>输入属性</strong>时会被调用。想要理解这个方法为什么会被调用或不被调用，我们需要了解<code>可变对象</code>和<code>不可变对象</code>，在js中，字符串是不可变对象，但一个对象是一个可变对象，至于为什么，请自行百度。最后的结论是：<br><strong>当输入属性是变对象例如对象时，对象的属性发生变化并不会触发<code>ngOnChanges</code>方法；当输入属性是不可变对象例如字符串时，字符串改变会触发<code>ngOnChanges</code>方法</strong>。<br><em>还需要注意一点就是</em>：<br><strong><code>ngOnChanges</code>方法首次调用一定是发生在<code>ngOninit</code>方法之前的。</strong></p><h4 id="ngDoCheck"><a href="#ngDoCheck" class="headerlink" title="ngDoCheck:"></a>ngDoCheck:</h4><p>变更检测可以说是Angular中最复杂的模块：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>angular有两种变更检测机制，一种是Default策略，一种是OnPush策略。Default策略会在组件发生变化时去检查组件树中<strong>所有</strong>组件，而使用OnPush的组件只会在其<code>输入属性</code>发生变化时去检查它。当我们对性能要求比较高的时候，例如有大量的表格数据在时时发生变化时，这两种策略的正确选择就显得尤为重要。<br>在<code>ngOnChanges</code>中我们知道</p><blockquote><p>当输入属性是可变对象例如对象时，对象的属性发生变化并不会触发<code>ngOnChanges</code>方法。</p></blockquote><p>那么怎么检测对象的属性呢，这时就需要用到<code>ngDoCheck</code>方法了。<code>check</code>的调用十分频繁，发生一点点动静都会调用<code>check</code>方法，就比如我们的鼠标光标切换input但是没有改变值框这类的动作，组件树上所有的有<code>check</code>关键字钩子都会调用，所以，我们的所有<code>check</code>方法一定要小心，<strong>一定要高效，一定要轻量级</strong>。</p><h4 id="ngAfterViewInit-amp-ngAfterViewChecked"><a href="#ngAfterViewInit-amp-ngAfterViewChecked" class="headerlink" title="ngAfterViewInit &amp; ngAfterViewChecked:"></a>ngAfterViewInit &amp; ngAfterViewChecked:</h4><p>顾名思义，这两个方法都是跟组件的视图密切相关的，前者是在视图都组建完毕之后才调用，后者是在视图发生变化时调用，值得注意的是：</p><ol><li><strong>这两个方法都是在视图组建完毕之后被调用的；</strong></li><li><strong>如果父组件存在子组件，那么父组件的这两个方法会在所有子组件的视图都组建完毕后调用；</strong></li><li><strong>不要早在这两个方法里面去改变视图中绑定的东西，这样做会报错。如果真的需要修改，需要写在一个timeout方法里面。</strong></li></ol><h4 id="ngAfterContentInit-amp-ngAfterContentChecked"><a href="#ngAfterContentInit-amp-ngAfterContentChecked" class="headerlink" title="ngAfterContentInit &amp; ngAfterContentChecked:"></a>ngAfterContentInit &amp; ngAfterContentChecked:</h4><p>要使用这两个方法，就得再说到一个<code>ng-content投影</code>，什么是<code>内容投影</code>呢？就是从组件外部导入HTML内容，并把它插在组件中指定位置上的一种途径，举个例子，我们在子组件模板中这样定义一个投影点：</p><pre><code>&lt;ng-content&gt;&lt;/ng-content&gt;</code></pre><p>这样我们在父组件中可以定义：</p><pre><code>&lt;app-child&gt;//这里面可以写想投影到子组件的内容&lt;/app-child&gt;</code></pre><p>这样我们就将父组件中的内容投影到了子组件中。不仅如此，我们还能同时投影多个内容，在父组件中这样定义：</p><pre><code>&lt;app-child&gt;//这里面可以写想投影到子组件的内容&lt;div class=&apos;header&apos;&gt;{{title}}&lt;/div&gt;&lt;div class=&apos;footer&apos;&gt;{{content}}&lt;/div&gt;&lt;/app-child&gt;</code></pre><p>然后再子组件中可以这样接收：</p><pre><code>&lt;ng-content select=&apos;.header&apos;&gt;&lt;/ng-content&gt;&lt;ng-content select=&apos;.footer&apos;&gt;&lt;/ng-content&gt;</code></pre><p>这样我们不仅将两个HTML片段投影到子组件中，还将父组件控制器中的<code>title</code>、<code>content</code>通过插值表达式投影到了子组件中。<br><code>ngAfterContentInit</code>和<code>ngAfterViewInit</code>不同的是：<strong><code>ngAfterViewInit</code>不能够改变视图中绑定的值，而在<code>ngAfterContentInit</code>中是可以的，不会报错</strong>。因为在<code>ngAfterContentInit</code>的时候，视图还没有组装完毕，只是投影进来的内容被组装完毕了。</p><h4 id="ngOnDestroy"><a href="#ngOnDestroy" class="headerlink" title="ngOnDestroy"></a>ngOnDestroy</h4><p>组件什么时候被销毁呢，就是路由到别处的时候，当前组件会被销毁，创建新的路由的组件。在这一般是用来释放那些不会被垃圾收集器自动回收的各类资源的地方。取消那些对可观察对象和 DOM 事件的订阅。停止定时器。注销该指令曾注册到全局服务或应用级服务中的各种回调函数。如果不这么做，就会有导致内存泄露的风险。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Angular中每个组件都有它的生命周期，从创建、渲染，到变更检测，再到最后的销毁过程过程，Angular一共提供了&lt;strong&gt;八个&lt;/strong&gt;生命周期钩子，他们按照顺序分别是：&lt;code&gt;constructor&lt;/code&gt;、&lt;code&gt;ngOnChanges&lt;
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>angular中组件之间如何通信(二)</title>
    <link href="http://tanyibing.com/2018/09/01/angular%E4%B8%AD%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/09/01/angular中组件之间如何通信（二）/</id>
    <published>2018-09-01T11:19:43.000Z</published>
    <updated>2018-09-07T06:49:46.346Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇的内容，上一篇最后说到有公共父组件的组件之间是如何通信的，最后还有一个问题没有解决。但是在这之前我需要补充一下，父组件和子组件之间的通信还有一种方式，那就是<strong>通过本地变量或者使用<code>@ViewChiad</code>来进行传递</strong>，举个例子：</p><pre><code>export class childComponent {    private sayHello() {        console.log(&apos;Hello&apos;);    }}</code></pre><p>我在子组件中定义这样一个方法，我怎么在父组件中调用呢，一个是通过本地变量的方法：</p><pre><code>&lt;app-child #child1&gt;&lt;/app-child&gt;&lt;button (click)=&quot;child1.syaHello()&quot;&gt;sayHello&lt;/button&gt;</code></pre><p>我在父组件的模板中使用子组件并加上<code>#child1</code>这个属性，然后就可以在<strong>父组件的模版中直接调用子组件的方法了</strong>。但是我们发现父组件的控制器并不能调用到这个方法，于是，我们就可以使用<code>@ViewChiad</code>：</p><pre><code>export class ParentComponent {    @ViewChild(&apos;child1&apos;)    private child: ChildComponent;//声明一个子组件    sayBay() {        this.child.sayHello();    }}</code></pre><p>这样我们就实现了<strong>在父组件的控制器中调用子组件的方法</strong>。</p><hr><p><strong>接下来我们就讨论一下最后一个问题：当组件之间没有公共的父组件时，它们应该如何通信呢？答案就是使用服务进行通信</strong><br>。。。loading</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接着上一篇的内容，上一篇最后说到有公共父组件的组件之间是如何通信的，最后还有一个问题没有解决。但是在这之前我需要补充一下，父组件和子组件之间的通信还有一种方式，那就是&lt;strong&gt;通过本地变量或者使用&lt;code&gt;@ViewChiad&lt;/code&gt;来进行传递&lt;/strong
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>angular中组件之间如何通信</title>
    <link href="http://tanyibing.com/2018/08/31/angular%E4%B8%AD%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1/"/>
    <id>http://tanyibing.com/2018/08/31/angular中组件之间如何通信/</id>
    <published>2018-08-31T07:27:24.000Z</published>
    <updated>2018-09-07T06:49:50.323Z</updated>
    
    <content type="html"><![CDATA[<p>在angular中，我们会设计很多的component组件，也就生成了组件树，组件之间有可能是父子组件，或者兄弟组件，或者彼此都没有关系。那么这么多组件之间该如何通讯呢？下面我们就简答的了解了解。</p><h2 id="父子组件之间的通讯"><a href="#父子组件之间的通讯" class="headerlink" title="父子组件之间的通讯"></a>父子组件之间的通讯</h2><p>父子之间的通讯比较简单，我们需要用到<code>@Input输入属性</code>和<code>@Output输出属性</code>。当我们需要<strong>从父组件向子组件传递信息时</strong>，我们首先需要为子组件定义一个属性：</p><pre><code>export class childComponent {    @Input() hero: Hero;}</code></pre><p>被<code>@Input</code>修饰的属性就即将接受从父组件传过来的信息。具体怎么传值呢？我们在父组件中通过子组件的属性进行传值：</p><pre><code>&lt;app-child [hero]=&quot;控制器中的属性值&quot;&gt;&lt;/app-child&gt;</code></pre><p>我们在父组件的模板中调用子组件时，只要在子组件中对<code>hero</code>属性进行绑定就行了。是不是很简单？而<strong>从子组件向父组件传值</strong>也很简单，其实就是一个反向的过程，我们需要借助EventEmitter的订阅和广播的功能就可以了，首先我们在子组件中定义要传输出去的属性值：</p><pre><code>export class childComponent {    @Output() voted = new EventEmitter&lt;boolean&gt;();    didVote = false;    vote(agreed: boolean) {        this.voted.emit(agreed);        this.didVote = true;    }}</code></pre><p>我们将要输出的是通过EventEmitter进行实例化，然后在需要的时候触发<code>.emit(agreed)</code>事件就能将数据传出去。那接下来我们需要在父组件中进行接收：</p><pre><code>&lt;app-child (voted)=&quot;onVoted($event)&quot;&gt;&lt;/app-child&gt;</code></pre><p>我们在父组件模板中的子组件上加上一个事件绑定，并且在父组件中定义<code>onVoted()</code>方法：</p><pre><code>export class ParentComponent {    agreed = 0;    disagreed = 0;    onVoted(event: boolean) {//event就是传递过来的数据        agreed ? this.agreed++ : this.disagreed++;}</code></pre><p>在父组件的方法中的参数就是我们从子组件中拿到的数据。这样就成功的传递出了信息。但是需要注意的是：<strong>默认情况下父组件模板中捕获事件的名字和子组件中输出属性的名字是一样的，都是voted！！！</strong>但是我们也可以通过输出属性来重命名：</p><pre><code>@Output(&apos;XXX&apos;)//这样就可以改掉输出属性的名字，同样的捕获事件的名字也要同步改过来。</code></pre><hr><h2 id="中间人模式"><a href="#中间人模式" class="headerlink" title="中间人模式"></a>中间人模式</h2><p>父子组件之间传递数据容易实现，但是当我们的组件不是父子关系的时候我们应该怎么传递数据？这就要用到我们的中间人模式了。</p><p>中间人模式最简单的一种关系就是<strong>两个组件有共同的父组件</strong>，也就是两个组件是兄弟关系。但是这个比喻不贴切，他们只是拥有共同的父组件，其实他们两之间谁都不认识谁。那么他们之间怎么通信呢？就把父组件当成中间人就行了：</p><pre><code>export class childOneComponent {    @Output() voted = new EventEmitter&lt;boolean&gt;();    didVote = false;    vote(agreed: boolean) {        this.voted.emit(agreed);        this.didVote = true;    }}</code></pre><p>首先还是一个组件中输出一个属性，并在适当的时触发广播的行为，将我们的数据发送出去。接着需要在父组件中监听<code>voted</code>这个事件：</p><pre><code>&lt;app-child-one (voted)=&quot;veteHandler($event)&quot;&gt;&lt;/app-child-one&gt;</code></pre><p>我们的另一个子组件需要有个输入属性：</p><pre><code>export class childTwoComponent {    @Input() voteCount;}</code></pre><p>既然是我们的中间人，它就应该先接收它收到的数据，然后将数据再传给需要的人。这就很简单啦：</p><pre><code>export class ParentComponent {    voteCount;    veteHandler(event: boolean) {//event就是传递过来的数据        this.voteCount = event;}</code></pre><p>我想你已经猜到下一步应该怎么办了，我们将父组件接受的数据传给另一个子组件就行了，怎么传？通过属性绑定来传递啊：</p><pre><code>&lt;app-child-one (voted)=&quot;veteHandler($event)&quot;&gt;&lt;/app-child-one&gt;&lt;app-child-two [voteCount]=&quot;voteCount&quot;&gt;&lt;/app-child-two&gt;</code></pre><p>这样我这个中间人的职责就完成啦，成功将一个组件传递给另一个组件。而且他们两互相之间根本不知情。</p><hr><p><strong>那么没有共同的父组件的组件之间难道就不能通讯了吗？答案肯定是不是的，我将在下一篇博客中回答！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在angular中，我们会设计很多的component组件，也就生成了组件树，组件之间有可能是父子组件，或者兄弟组件，或者彼此都没有关系。那么这么多组件之间该如何通讯呢？下面我们就简答的了解了解。&lt;/p&gt;
&lt;h2 id=&quot;父子组件之间的通讯&quot;&gt;&lt;a href=&quot;#父子组件之
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>angular数据绑定</title>
    <link href="http://tanyibing.com/2018/08/30/angular%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>http://tanyibing.com/2018/08/30/angular数据绑定/</id>
    <published>2018-08-30T14:56:05.000Z</published>
    <updated>2018-09-07T06:49:29.884Z</updated>
    
    <content type="html"><![CDATA[<p>Angular数据绑定是Angular中最常见的，绑定的方式有单向数据绑定和双向数据绑定。单向的数据绑定通常有以下几种方式：</p><p><strong>1.使用插值表达式将一个表达式的值显示在模板上：</strong></p><pre><code>&lt;h1&gt;{{titke}}&lt;/h1&gt;</code></pre><hr><p><strong>2.使用方括号将HTML标签的一个属性绑定到一个表达式上：</strong></p><pre><code>&lt;img [src] = &quot;imgUrl&quot;&gt;</code></pre><p>其实我们的属性绑定和我们的插值表达式是一样的，我们举个例子;</p><pre><code>&lt;img [src] = &quot;imgUrl&quot;&gt;&lt;img src = {{imgUrl}}&gt;</code></pre><p>这两种写法其实都一样，插值的表达式都会被Angular转化成属性绑定。<strong>在这还有一个需要理解的东西就是HTML属性和DOM属性的区别</strong>，举个例子：</p><pre><code>&lt;input value=&quot;hello&quot; (click)=&quot;doOnInput($event)&quot;&gt;</code></pre><p>我们的控制器定义一下我们的输入事件：</p><pre><code>doOnInput(event: any) {    console.log(event.target.value);//打印DOM属性的值    console.log(event.target.getAttribute(&apos;value&apos;);//打印HTML属性的值}</code></pre><p>我们可以发现DOM属性的值是随着你改变输入的值而一直在改变的，而HTML属性的值一直是hello，因为HTML是初始化DOM属性的值的，不能改变，而DOM属性的值可以改变。</p><p><strong>HTML属性和DOM属性的关系如下：</strong></p><ol><li>少量HTML属性和DOM属性之间有1:1的映射，比如id。</li><li>有些HTML属性没有对应的DOM属性，如colspan。</li><li>有些DOM属性没有对应的HTML属性，如textContent。</li><li>就算名字相同，HTML属性和DOM属性也不是一样东西。</li><li>HTML属性的值指定了初始值；DOM属性的值表示当前值.DOM属性的值可以改变；HTML属性的值不能改变。</li><li>模板绑定是通过DOM属性和事件来工作的，而不是HTML属性。</li></ol><p><strong>以上是DOM属性的绑定，下面介绍下HTML属性的绑定</strong><br>简单的举个例子：</p><pre><code>&lt;td [attr.colspan]={{1+1}}&gt;</code></pre><p>因为colspan是个DOM属性没有的HTML属性，所以我们在前面加上<code>attr</code>这个前缀来表示它是HTML属性。</p><p>更多的我们可以通过<code>[ngClass]</code>或者<code>[class.classname]</code>、<code>[class]</code>这种来控制部分或者全部的类名，以此来达到控制样式的效果。<code>ngclass</code>的表达式需要接收一个对象，对象中通过<code>{cssClassName: Boolen}</code>这种键值对来表示该类是否要加上，<code>true</code>表示加上，<code>false</code>代表移除，这就是<strong>CSS类绑定</strong>。</p><p>类似的，我们还可以通过<strong>css样式绑定</strong>，不过不再是<code>class</code>开头了，而是<code>style</code>开头，举个栗子：</p><pre><code>&lt;div [style.color]=&quot; isDev? &apos;red&apos;: &apos;blue&apos;&quot;&gt;</code></pre><p>其中的<code>isDev</code>就是控制器来控制的。和上面css类绑定一样，这只是单一样式的绑定，所以我们还有个<code>[ngStyle]</code>来批量控制，它也是接受一个对象，但和css类不同的是，这个对象里面定义的是样式的键值对，例如{color: red,background: black}</p><hr><p><strong>3.上面这两个绑定方式都是控制器向模板传输数据，下面这种是模板向控制器传输数据，也就是事件绑定：</strong></p><pre><code>&lt;button (click)=&quot;onClickEvent($event)&quot;&gt;点击执行&lt;/button&gt;//小括号表示这是一个事件绑定//小括号中的是事件的名称//等号后面双引号中的是事件发生时执行的表达式//如果处理事件的方法需要了解事件的属性，我们就可以给方法加上$event参数</code></pre><p>我们的事件绑定中也可以不是一个方法调用，而是一个属性赋值：</p><pre><code>&lt;button (click)=&quot;saved = true&quot;&gt;</code></pre><p>这样我们就能够直接给控制器中的saved属性赋值为true。</p><hr><p><strong>接下来我们看一下最重要的双向数据绑定</strong></p><blockquote><p>盒子里面装香蕉</p></blockquote><p>这句话是官网文档上面说的，就是指<code>[(ngModel)]</code>是方括号包着小括号，其实从上面就能看出，控制器传值给模板是方括号，模板传值给控制器是小括号，两个融合到一起就是双向数据绑定了，举个栗子：</p><pre><code>&lt;input [value]=&quot;currentHero.name&quot;       (input)=&quot;currentHero.name=$event.target.value&quot; &gt;</code></pre><p>下面这个而其实就是一个双向数据绑定，但是显得太过笨重，于是有了下面这种写法：</p><pre><code>&lt;input [(ngModel)]=&quot;currentHero.name&quot;&gt;</code></pre><p>这样就能够同步输入和显示了，最常用的地方就是我们的表单元素了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Angular数据绑定是Angular中最常见的，绑定的方式有单向数据绑定和双向数据绑定。单向的数据绑定通常有以下几种方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.使用插值表达式将一个表达式的值显示在模板上：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>angular中如何引入第三方库</title>
    <link href="http://tanyibing.com/2018/08/29/angular%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>http://tanyibing.com/2018/08/29/angular中如何引入第三方库/</id>
    <published>2018-08-29T15:06:42.000Z</published>
    <updated>2018-09-07T06:49:42.873Z</updated>
    
    <content type="html"><![CDATA[<p>当我们想要在angular项目中引入第三方的库的时候我们应该怎么操作？就拿jquery来说吧：</p><p><strong>第一步</strong><br>我们需要在项目目录下安装自己所需要的包：</p><pre><code>npm install --save jquery</code></pre><p><code>--save</code>和<code>--save-dev</code>的区别就不多描述了，安装完成之后我们就可以在项目下的node_modules下面看到它了。</p><p><strong>第二步</strong><br>我们需要把我们下载好的包加入到angular的配置文件中，在6.x之前，这个配置文件的名称是<code>.angular-cli.json</code>，但是在6.x之后就不是这个名字了，而是换成了<code>angular.json</code>，打开这个文件我们就能看到一系列的配置信息。我们需要将自己下载的包的路径引用到<code>styles</code>和<code>scripts</code>数组下面：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在这里填入正确的路径就可以了。这样jquery或者你需要的第三方包就被加入到angular项目中了。</p></blockquote><p><em>但是</em>我们现在还是不能直接使用jquery，因为angular是使用typescript开发的，而jquery的本质是javascript，Typescript是不能直接使用的。我们还需要安装类型描述文件让Typescript认识jquery。</p><p><strong>第三步</strong><br>我们通过命令来安装jquery的类型描述文件：</p><pre><code>npm install @types/jquery(这个名字是你需要安装的包的名字) --save-dev</code></pre><p>这样我们就能够使用jquery的命令了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们想要在angular项目中引入第三方的库的时候我们应该怎么操作？就拿jquery来说吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;br&gt;我们需要在项目目录下安装自己所需要的包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install --save jqu
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>rem的正确使用姿势</title>
    <link href="http://tanyibing.com/2018/08/27/rem%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>http://tanyibing.com/2018/08/27/rem的正确使用姿势/</id>
    <published>2018-08-27T14:14:03.000Z</published>
    <updated>2018-08-28T09:06:22.657Z</updated>
    
    <content type="html"><![CDATA[<p>最近用的比较多的就是rem了，所以写一篇rem的文章来记录下使用rem来制作移动端的页面的关键之处。</p><p>首先简单的阐述下px、em、rem三者之间的关系：</p><p><strong>px</strong>：像素是相对于显示器屏幕分辨率而言的相对长度单位。pc端使用px倒也无所谓，可是在移动端，因为手机分辨率种类颇多，不可能一个个去适配，这时px就显得非常无力，所以就要考虑em和rem。</p><p><strong>em</strong>：继承父级的，假设html的font-size默认为16px，body字体大小定义为50%，那么在body里字体大小就是1em=8px了。可当你又定义了一个div，然后把字体设置成了50%，请问，现在div下的1em等于多少？因为继承了父级的值，现在这个div里的1em=4px，这么嵌套下去的话，抱歉，我数学不好！所以rem就出现了。</p><p><strong>rem</strong>：是em的升级版，rem只会相对html的值，不会受到父级的影响，这样的好处在于：从em里的例子来讲，1rem始终会等于8px。使用的时候不需要重新计算rem此时的大小。rem因为是css3增加的，所以ie8或以下请无视（始终想不明白，为什么国人至今对微软都放弃的ie这么恋恋不舍）。</p><p><em>使用方法</em>：<br>首先在css中先全局声明font-size=625%,这里为什么用625%呢？因为100%=16px,1px=6.25%,所以100px=625%，1rem=100px。这样在后面使用的时候就方便很多。需要注意的是，rem是相对于根元素html的font-size，也就是说只需要设置根元素html的百分比就行了：</p><pre><code>html{font-size: 625%;}</code></pre><p>还可以动态的来设置rem，例如使用媒体查询：</p><pre><code>@media screen and (min-width: 320px) {  html {font-size: 14px;}}    @media screen and (min-width: 360px) {  html {font-size: 16px;}}@media screen and (min-width: 400px) {  html {font-size: 18px;}}@media screen and (min-width: 440px) {  html {font-size: 20px;}}@media screen and (min-width: 480px) {  html {font-size: 22px;}}@media screen and (min-width: 640px) {  html {font-size: 28px;}}</code></pre><p>或者利用js计算当前设备来设置：</p><pre><code>(function (doc, win) {    var docEl = doc.documentElement,    resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,    recalc = function () {        var clientWidth = docEl.clientWidth;        if (!clientWidth) return;           if(clientWidth&gt;=640){            docEl.style.fontSize = &apos;100px&apos;;        }else{            //这里的640是根据设计图实际大小来的            docEl.style.fontSize = 100 * (clientWidth / 640) + &apos;px&apos;;        }       };    if (!doc.addEventListener) return;        win.addEventListener(resizeEvt, recalc, false);        doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);})(document, window);</code></pre><p>后来看到一个关于手淘的文章，有了下面这种最佳的方法，通过js计算当前设备的DPR，动态设置在html标签上，并动态的设置html的font-size，利用css选择器根据DPR来设置不同DPR下的字体的大小：</p><pre><code>function(win, lib) {    var timer,    doc     = win.document,    docElem = doc.documentElement,    vpMeta   = doc.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;),    flexMeta = doc.querySelector(&apos;meta[name=&quot;flexible&quot;]&apos;),    dpr   = 0,    scale = 0,    flexible = lib.flexible || (lib.flexible = {});    // 设置了 viewport meta    if (vpMeta) {        console.warn(&quot;将根据已有的meta标签来设置缩放比例&quot;);        var initial = vpMeta.getAttribute(&quot;content&quot;).match(/initial\-scale=([\d\.]+)/);        if (initial) {            scale = parseFloat(initial[1]); // 已设置的 initialScale            dpr = parseInt(1 / scale);      // 设备像素比 devicePixelRatio        }    // 设置了 flexible Meta    }else if (flexMeta) {        var flexMetaContent = flexMeta.getAttribute(&quot;content&quot;);        if (flexMetaContent) {            var initial = flexMetaContent.match(/initial\-dpr=([\d\.]+)/),                maximum = flexMetaContent.match(/maximum\-dpr=([\d\.]+)/);            if (initial) {                dpr = parseFloat(initial[1]);                scale = parseFloat((1 / dpr).toFixed(2));            }            if (maximum) {                dpr = parseFloat(maximum[1]);                scale = parseFloat((1 / dpr).toFixed(2));            }        }    }    // viewport 或 flexible    // meta 均未设置    if (!dpr &amp;&amp; !scale) {        // QST        // 这里的 第一句有什么用 ?        // 和 Android 有毛关系 ?        var u = (win.navigator.appVersion.match(/android/gi), win.navigator.appVersion.match(/iphone/gi)),        _dpr = win.devicePixelRatio;    // 所以这里似乎是将所有 Android 设备都设置为 1 了        dpr = u ? ( (_dpr &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3))                    ? 3                    : (_dpr &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))                        ? 2                        : 1              )            : 1;        scale = 1 / dpr;    }    docElem.setAttribute(&quot;data-dpr&quot;, dpr);    // 插入 viewport meta    if (!vpMeta) {        vpMeta = doc.createElement(&quot;meta&quot;);        vpMeta.setAttribute(&quot;name&quot;, &quot;viewport&quot;);        vpMeta.setAttribute(&quot;content&quot;,        &quot;initial-scale=&quot; + scale + &quot;, maximum-scale=&quot; + scale + &quot;, minimum-scale=&quot; + scale + &quot;, user-scalable=no&quot;);    if (docElem.firstElementChild) {        docElem.firstElementChild.appendChild(vpMeta)    } else {        var div = doc.createElement(&quot;div&quot;);        div.appendChild(vpMeta);        doc.write(div.innerHTML);    }    }    function setFontSize() {        var winWidth = docElem.getBoundingClientRect().width;        if (winWidth / dpr &gt; 540) {            (winWidth = 540 * dpr);        }        // 根节点 fontSize 根据宽度决定        var baseSize = winWidth / 10;        docElem.style.fontSize = baseSize + &quot;px&quot;;        flexible.rem = win.rem = baseSize;    }    // 调整窗口时重置    win.addEventListener(&quot;resize&quot;, function() {        clearTimeout(timer);        timer = setTimeout(setFontSize, 300);    }, false);    // 这一段是我自己加的    // orientationchange 时也需要重算下吧    win.addEventListener(&quot;orientationchange&quot;, function() {        clearTimeout(timer);        timer = setTimeout(setFontSize, 300);    }, false);    // pageshow    // keyword: 倒退 缓存相关    win.addEventListener(&quot;pageshow&quot;, function(e) {        if (e.persisted) {            clearTimeout(timer);            timer = setTimeout(setFontSize, 300);        }    }, false);    // 设置基准字体    if (&quot;complete&quot; === doc.readyState) {        doc.body.style.fontSize = 12 * dpr + &quot;px&quot;;    } else {        doc.addEventListener(&quot;DOMContentLoaded&quot;, function() {            doc.body.style.fontSize = 12 * dpr + &quot;px&quot;;        }, false);    }    setFontSize();    flexible.dpr = win.dpr = dpr;    flexible.refreshRem = setFontSize;    flexible.rem2px = function(d) {        var c = parseFloat(d) * this.rem;        if (&quot;string&quot; == typeof d &amp;&amp; d.match(/rem$/)) {            c += &quot;px&quot;;        }        return c;    };    flexible.px2rem = function(d) {        var c = parseFloat(d) / this.rem;        if (&quot;string&quot; == typeof d &amp;&amp; d.match(/px$/)) {            c += &quot;rem&quot;;        }        return c;    }}(window, window.lib || (window.lib = {}));</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用的比较多的就是rem了，所以写一篇rem的文章来记录下使用rem来制作移动端的页面的关键之处。&lt;/p&gt;
&lt;p&gt;首先简单的阐述下px、em、rem三者之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;px&lt;/strong&gt;：像素是相对于显示器屏幕分辨率而言的相对长度单位。pc
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://tanyibing.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
      <category term="CSS" scheme="http://tanyibing.com/tags/CSS/"/>
    
      <category term="HTML" scheme="http://tanyibing.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>全屏遮罩播放视频</title>
    <link href="http://tanyibing.com/2018/08/23/%E5%85%A8%E5%B1%8F%E9%81%AE%E7%BD%A9%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"/>
    <id>http://tanyibing.com/2018/08/23/全屏遮罩播放视频/</id>
    <published>2018-08-23T08:48:28.000Z</published>
    <updated>2018-08-28T09:04:11.267Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇的内容，现在我播放视频不希望跳转到一个新的视频播放页面这么麻烦了，我想要通过点击直接在本页面进行播放。最后决定的是在全屏加上一个遮罩，视频控制住在屏幕的正中央进行播放。直接上我的代码吧：</p><pre><code>&lt;div class=&quot;box-mask&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;input  class=&quot;btnCancel&quot; type=&quot;button&quot;  value=&quot;关闭&quot;&gt;&lt;script src=&apos;//player.polyv.net/script/polyvplayer.min.js&apos;&gt;&lt;/script&gt;&lt;div id=&apos;&apos; class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;script&gt;    let videoDiv = $(&apos;.box div&apos;);    $(&quot;.btnDel&quot;).click(function() {        let vid = $(this).attr(&apos;id&apos;);        console.log(vid);        let plv = &apos;plv_&apos; + vid;        let plvObj = &apos;#&apos; +  plv;        $(videoDiv).attr(&apos;id&apos;, plv);        let plvConfig = {            &apos;width&apos;:&apos;100%&apos;,            &apos;height&apos;:&apos;100%&apos;,            &apos;vid&apos; : vid        }        let player = polyvObject(plvObj).videoPlayer(plvConfig);    });&lt;/script&gt;&lt;/div&gt;</code></pre><p>这是我的遮罩和视频播放模块的DOM结构，其中<code>.btnDel</code>就是我们点击进入遮罩的入口。紧接着我放出我的css样式：</p><pre><code>.box-mask {  position: fixed;  top: 0;  left: 0;  width: 100%;  height: 100%;  background: #000;  opacity: 0.7;  filter: alpha(opacity=50);  z-index: 99;  display: none;}.box {  position: absolute;  width: 1000px;  height: 620px;  line-height:620px;  text-align: center;  z-index: 101;  display: none;}.demo{  width:100%;  height:100%;  margin:0 auto;}.btnCancel {  float: right;  width: 50px;  height: 30px;}</code></pre><p>紧接着我要实现通过点击来实现遮罩的开启和关闭，并且要考虑下鼠标滚轮的滚动和浏览器窗口的大小改变这些情况：</p><pre><code>$(document).ready(function() {        var isOpen = 0;        //全局变量，判断是否已经打开弹出框        $(&quot;.btnDel&quot;).click(function() {            //$(&quot;.box-mask&quot;).css({&quot;display&quot;:&quot;block&quot;});            $(&quot;.box-mask&quot;).fadeIn(500);            center($(&quot;.box&quot;));            //载入弹出窗口上的按钮事件            checkEvent($(this).parent(), $(&quot;.btnSure&quot;), $(&quot;.btnCancel&quot;));        });        function center(obj) {            //obj这个参数是弹出框的整个对象            var screenWidth = $(window).width(), screenHeigth = $(window).height();            //获取屏幕宽高            var scollTop = $(document).scrollTop();            //当前窗口距离页面顶部的距离            var objLeft = (screenWidth - obj.width()) / 2;            ///弹出框距离左侧距离            var objTop = (screenHeigth - obj.height()) / 2 + scollTop;            ///弹出框距离顶部的距离            obj.css({                left:objLeft + &quot;px&quot;,                top:objTop + &quot;px&quot;            });            obj.fadeIn(500);            //弹出框淡入            isOpen = 1;            //弹出框打开后这个变量置1 说明弹出框是打开装填            //当窗口大小发生改变时            $(window).resize(function() {                //只有isOpen状态下才执行                if (isOpen == 1) {                    //重新获取数据                    screenWidth = $(window).width();                    screenHeigth = $(window).height();                    var scollTop = $(document).scrollTop();                    objLeft = (screenWidth - obj.width()) / 2;                    var objTop = (screenHeigth - obj.height()) / 2 + scollTop;                    obj.css({                        left:objLeft + &quot;px&quot;,                        top:objTop + &quot;px&quot;                    });                    obj.fadeIn(500);                }            });            //当滚动条发生改变的时候            $(window).scroll(function() {                if (isOpen == 1) {                    //重新获取数据                    screenWidth = $(window).width();                    screenHeigth = $(window).height();                    var scollTop = $(document).scrollTop();                    objLeft = (screenWidth - obj.width()) / 2;                    var objTop = (screenHeigth - obj.height()) / 2 + scollTop;                    obj.css({                        left:objLeft + &quot;px&quot;,                        top:objTop + &quot;px&quot;                    });                    obj.fadeIn(500);                }            });        }        //导入两个按钮事件 obj整个页面的内容对象，obj1为确认按钮，obj2为取消按钮        function checkEvent(obj, obj1, obj2) {            //确认后删除页面所有东西            obj1.click(function() {                //移除所有父标签内容                obj.remove();                //调用closed关闭弹出框                closed($(&quot;.box-mask&quot;), $(&quot;.box&quot;));            });            //取消按钮事件            obj2.click(function() {                //调用closed关闭弹出框                closed($(&quot;.box-mask&quot;), $(&quot;.box&quot;));            });        }        //关闭弹出窗口事件        function closed(obj1, obj2) {            obj1.fadeOut(500);            obj2.fadeOut(500);            isOpen = 0;        }    });</code></pre><p>至于视频内容的切换，和上一篇差不多，也可以去我的github上看实例<a href="https://github.com/TanYiBing/zenith" target="_blank" rel="noopener">https://github.com/TanYiBing/zenith</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接着上一篇的内容，现在我播放视频不希望跳转到一个新的视频播放页面这么麻烦了，我想要通过点击直接在本页面进行播放。最后决定的是在全屏加上一个遮罩，视频控制住在屏幕的正中央进行播放。直接上我的代码吧：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box
      
    
    </summary>
    
      <category term="CSS" scheme="http://tanyibing.com/categories/CSS/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
      <category term="HTTP" scheme="http://tanyibing.com/tags/HTTP/"/>
    
      <category term="CSS" scheme="http://tanyibing.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>静态页面之间传值</title>
    <link href="http://tanyibing.com/2018/08/22/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/"/>
    <id>http://tanyibing.com/2018/08/22/静态页面之间传值/</id>
    <published>2018-08-22T14:40:46.000Z</published>
    <updated>2018-08-23T08:43:36.035Z</updated>
    
    <content type="html"><![CDATA[<p>今天在工作中需要实现视频的播放功能，我需要从视频的聚合页通过点击来跳转到视频播放页面来进行播放。因为视频是托管在POLYV平台上的，视频以.swf的格式保存的话就不能直接使用video标签，而是需要使用特定的方法来实现视频的播放功能，我最后选择的是视频平台上的多终端样式，具体代码如下：</p><pre><code>&lt;script src=&apos;//player.polyv.netscriptpolyvplayer.min.js&apos;&gt;&lt;/script&gt;&lt;div id=&apos;plv_228d7015db12fcd9a62b5abc1f76540f_2&apos;&gt;&lt;/div&gt;&lt;script&gt;    var player = polyvObject(&apos;#plv_228d7015db12fcd9a62b5abc1f76540f_2&apos;).videoPlayer({            &apos;width&apos;:&apos;600&apos;,         &apos;height&apos;:&apos;338&apos;,        &apos;vid&apos; : &apos;228d7015db12fcd9a62b5abc1f76540f_2&apos;       });&lt;/script&gt;</code></pre><p>我的视频聚合页中的一个例子是:</p><pre><code>&lt;a href=&quot;&quot; class=&quot;vedioCard&quot;&gt;    &lt;img src=&quot;xxx.jpg&quot; class=&quot;ved&quot;&gt;    &lt;div class=&quot;deti&quot;&gt;江苏的启东&lt;/div&gt;&lt;/a&gt;</code></pre><p>紧接着我在a标签里面加上传递参数的url：</p><pre><code>&lt;a href=&quot;./video.html?vid=228d7015db9fd7dbd831b586d395e7fb_2&quot; class=&quot;vedioCard&quot;&gt;    &lt;img src=&quot;xxx.jpg&quot; class=&quot;ved&quot;&gt;    &lt;div class=&quot;deti&quot;&gt;江苏的启东&lt;/div&gt;&lt;/a&gt;</code></pre><p>vid就是我在播放页面想要获取的参数，因为视频的播放需要这个参数。<br>接下来我需要在播放页面使用<code>$.query.get（param）</code>方法来获取我想要的东西，这看上去就是和jquery有关，没错！这是jquery的一个插件，插件的代码我也拿过来使用：</p><pre><code>new function(settings) {  var $separator = settings.separator || &apos;&amp;&apos;;  var $spaces = settings.spaces === false ? false : true;  var $suffix = settings.suffix === false ? &apos;&apos; : &apos;[]&apos;;  var $prefix = settings.prefix === false ? false : true;  var $hash = $prefix ? settings.hash === true ? &quot;#&quot; : &quot;?&quot; : &quot;&quot;;  var $numbers = settings.numbers === false ? false : true;  jQuery.query = new function() {    var is = function(o, t) {    return o != undefined &amp;&amp; o !== null &amp;&amp; (!!t ? o.constructor == t : true);  };  var parse = function(path) {    var m, rx = /\[([^[]*)\]/g, match = /^([^[]+)(\[.*\])?$/.exec(path), base = match[1], tokens = [];    while (m = rx.exec(match[2])) tokens.push(m[1]);    return [base, tokens];  };  var set = function(target, tokens, value) {    var o, token = tokens.shift();    if (typeof target != &apos;object&apos;) target = null;    if (token === &quot;&quot;) {      if (!target) target = [];      if (is(target, Array)) {        target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value));    } else if (is(target, Object)) {      var i = 0;      while (target[i++] != null);      target[--i] = tokens.length == 0 ? value : set(target[i], tokens.slice(0), value);    } else {      target = [];      target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value));    }  } else if (token &amp;&amp; token.match(/^\s*[0-9]+\s*$/)) {    var index = parseInt(token, 10);    if (!target) target = [];    target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value);  } else if (token) {    var index = token.replace(/^\s*|\s*$/g, &quot;&quot;);    if (!target) target = {};    if (is(target, Array)) {      var temp = {};      for (var i = 0; i &lt; target.length; ++i) {        temp[i] = target[i];      }      target = temp;    }    target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value);    } else {      return value;    }    return target;  };  var queryObject = function(a) {  var self = this;  self.keys = {};  if (a.queryObject) {    jQuery.each(a.get(), function(key, val) {      self.SET(key, val);    });  } else {    jQuery.each(arguments, function() {      var q = &quot;&quot; + this;      q = q.replace(/^[?#]/,&apos;&apos;);      q = q.replace(/[;&amp;]$/,&apos;&apos;);      if ($spaces) q = q.replace(/[+]/g,&apos; &apos;);      jQuery.each(q.split(/[&amp;;]/), function(){        var key = decodeURIComponent(this.split(&apos;=&apos;)[0] || &quot;&quot;);        var val = decodeURIComponent(this.split(&apos;=&apos;)[1] || &quot;&quot;);        if (!key) return;        if ($numbers) {          if (/^[+-]?[0-9]+\.[0-9]*$/.test(val))            val = parseFloat(val);          else if (/^[+-]?[0-9]+$/.test(val))            val = parseInt(val, 10);        }        val = (!val &amp;&amp; val !== 0) ? true : val;        if (val !== false &amp;&amp; val !== true &amp;&amp; typeof val != &apos;number&apos;)          val = val;        self.SET(key, val);      });    });  }  return self;};queryObject.prototype = {  queryObject: true,  has: function(key, type) {    var value = this.get(key);    return is(value, type);  },  GET: function(key) {    if (!is(key)) return this.keys;    var parsed = parse(key), base = parsed[0], tokens = parsed[1];    var target = this.keys[base];    while (target != null &amp;&amp; tokens.length != 0) {      target = target[tokens.shift()];    }    return typeof target == &apos;number&apos; ? target : target || &quot;&quot;;  },  get: function(key) {    var target = this.GET(key);    if (is(target, Object))      return jQuery.extend(true, {}, target);    else if (is(target, Array))      return target.slice(0);    return target;  },  SET: function(key, val) {    var value = !is(val) ? null : val;    var parsed = parse(key), base = parsed[0], tokens = parsed[1];    var target = this.keys[base];    this.keys[base] = set(target, tokens.slice(0), value);    return this;  },  set: function(key, val) {    return this.copy().SET(key, val);  },  REMOVE: function(key) {    return this.SET(key, null).COMPACT();  },  remove: function(key) {    return this.copy().REMOVE(key);  },  EMPTY: function() {    var self = this;    jQuery.each(self.keys, function(key, value) {      delete self.keys[key];    });    return self;  },  load: function(url) {    var hash = url.replace(/^.*?[#](.+?)(?:\?.+)?$/, &quot;$1&quot;);    var search = url.replace(/^.*?[?](.+?)(?:#.+)?$/, &quot;$1&quot;);    return new queryObject(url.length == search.length ? &apos;&apos; : search, url.length == hash.length ? &apos;&apos; : hash);  },  empty: function() {    return this.copy().EMPTY();  },  copy: function() {    return new queryObject(this);  },  COMPACT: function() {    function build(orig) {      var obj = typeof orig == &quot;object&quot; ? is(orig, Array) ? [] : {} : orig;      if (typeof orig == &apos;object&apos;) {        function add(o, key, value) {          if (is(o, Array))            o.push(value);          else            o[key] = value;        }        jQuery.each(orig, function(key, value) {          if (!is(value)) return true;          add(obj, key, build(value));        });      }      return obj;    }    this.keys = build(this.keys);    return this;  },  compact: function() {    return this.copy().COMPACT();  },  toString: function() {    var i = 0, queryString = [], chunks = [], self = this;    var encode = function(str) {      str = str + &quot;&quot;;      if ($spaces) str = str.replace(/ /g, &quot;+&quot;);      return encodeURIComponent(str);    };    var addFields = function(arr, key, value) {      if (!is(value) || value === false) return;      var o = [encode(key)];      if (value !== true) {        o.push(&quot;=&quot;);        o.push(encode(value));      }      arr.push(o.join(&quot;&quot;));    };    var build = function(obj, base) {      var newKey = function(key) {        return !base || base == &quot;&quot; ? [key].join(&quot;&quot;) : [base, &quot;[&quot;, key, &quot;]&quot;].join(&quot;&quot;);      };      jQuery.each(obj, function(key, value) {        if (typeof value == &apos;object&apos;)           build(value, newKey(key));        else          addFields(chunks, newKey(key), value);        });      };      build(this.keys);      if (chunks.length &gt; 0) queryString.push($hash);      queryString.push(chunks.join($separator));      return queryString.join(&quot;&quot;);      }    };  return new queryObject(location.search, location.hash);  };}(jQuery.query || {});</code></pre><p>在有了这个插件之后我们就可以很轻松地拿到url中的参数了：</p><pre><code>let vid = $.query.get(&apos;vid&apos;);</code></pre><p>拿到参数之后只要像对待普通DOM元素一样对上面视频播放的那个div进行属性的修改，就可以播放不同的视频了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在工作中需要实现视频的播放功能，我需要从视频的聚合页通过点击来跳转到视频播放页面来进行播放。因为视频是托管在POLYV平台上的，视频以.swf的格式保存的话就不能直接使用video标签，而是需要使用特定的方法来实现视频的播放功能，我最后选择的是视频平台上的多终端样式，具
      
    
    </summary>
    
      <category term="HTTP" scheme="http://tanyibing.com/categories/HTTP/"/>
    
    
      <category term="URL" scheme="http://tanyibing.com/tags/URL/"/>
    
      <category term="HTTP" scheme="http://tanyibing.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Angular6在使用antd的layout之后没有css样式</title>
    <link href="http://tanyibing.com/2018/08/22/Angular6%E5%9C%A8%E4%BD%BF%E7%94%A8antd%E7%9A%84layout%E4%B9%8B%E5%90%8E%E6%B2%A1%E6%9C%89css%E6%A0%B7%E5%BC%8F/"/>
    <id>http://tanyibing.com/2018/08/22/Angular6在使用antd的layout之后没有css样式/</id>
    <published>2018-08-21T17:37:10.000Z</published>
    <updated>2018-09-07T06:49:19.787Z</updated>
    
    <content type="html"><![CDATA[<p>今天我在使用Angular6安装完antd之后，使用了layout模块，打开之后发现没有样式，最后解决方案如下：</p><p><strong>首先我们看看antd的官网</strong>：</p><p><a href="https://ng.ant.design/docs/getting-started/zh" target="_blank" rel="noopener">https://ng.ant.design/docs/getting-started/zh</a></p><p>当我们开始使用之前，我们需要引入css全局样式，但是引入的位置不正确就会导致我们的模块没有样式。</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p><strong>解决方案是在全局样式文件style.css的开头引入antd的css</strong></p><p><code>@importnode_modules/ng-zorro-antd/src/ng-zorro-antd.min.css</code></p><p><strong>如下图</strong>：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/angular/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我在使用Angular6安装完antd之后，使用了layout模块，打开之后发现没有样式，最后解决方案如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先我们看看antd的官网&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ng.ant.design/doc
      
    
    </summary>
    
      <category term="Angular" scheme="http://tanyibing.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://tanyibing.com/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://tanyibing.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>JS原型理解</title>
    <link href="http://tanyibing.com/2018/08/08/JS%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://tanyibing.com/2018/08/08/JS原型、原型链/</id>
    <published>2018-08-08T15:40:45.000Z</published>
    <updated>2018-08-28T09:03:12.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS原型和原型链"><a href="#JS原型和原型链" class="headerlink" title="JS原型和原型链"></a>JS原型和原型链</h2><h3 id="js原型"><a href="#js原型" class="headerlink" title="js原型"></a>js原型</h3><p>js原型和原型链一直是js中一个难点，也是面试时大概率的问题，看了网上很多的说法，好像都不是那么通俗易懂。我就用简单的方式来介绍介绍，本人是前端菜鸟，说错了欢迎大家提出来。</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/js/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>我理解中的原型是为了继承而产生的，为了防止污染全局变量，我们可以给Person的原型加上一个sayHello方法，这也是最简单的例子（自行脑补代码），这样我们就可以在Person的实例中共享sayHello这个方法。图中的每条线其实都可以用一个属性代替，我画出来你们就一目了然了。</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/js/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>我们可以看到，Person构造函数可以通过prototype属性访问它自己的原型对象的，而实例化出来的对象可以通过_proto_属性访问Peroson构造函数的原型对象._proto_属性其实是非标准的属性，也就是说这是浏览器为了方便才产生的属性，为了什么方便？当然是为了调试的方便啦，所以我们还是尽量不要在代码中使用_proto_，而在调试的时候使用。</p><h3 id="js原型链"><a href="#js原型链" class="headerlink" title="js原型链"></a>js原型链</h3><p>上面给的是一个简单的原型模型，我们知道，原型对象还有一个属性constructor，这个属性就是指向该对象的构造函数的。下面我们需要了解几个概念，以便我们清楚的知道原型链是什么：<br><br><strong>1.每个构造函数都有原型对象</strong><br><br><strong>2.每个对象都会有构造函数</strong><br><br><strong>3.每个构造函数的原型都是一个对象</strong><br><br><strong>4.那么这个原型对象也会有构造函数</strong><br><br><strong>5.那么这个原型对象的构造函数也会有原型对象</strong><br><br>这样就形成一个链式结构，也就是我们说的原型链</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/js/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>从图中我们就可以清楚的看到一个原型链结构，我们的原型其实也是个对象，对象也是由对象构造函数生成的，其实也就是之前的原型三角结构的延伸，可以看到，所有的对象的原型最顶层就是null。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS原型和原型链&quot;&gt;&lt;a href=&quot;#JS原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;JS原型和原型链&quot;&gt;&lt;/a&gt;JS原型和原型链&lt;/h2&gt;&lt;h3 id=&quot;js原型&quot;&gt;&lt;a href=&quot;#js原型&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://tanyibing.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://tanyibing.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>SEO自学笔记（五）</title>
    <link href="http://tanyibing.com/2018/08/02/SEO%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/08/02/SEO自学笔记（五）/</id>
    <published>2018-08-02T14:03:55.000Z</published>
    <updated>2018-08-02T14:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SEO自学笔记（五）"><a href="#SEO自学笔记（五）" class="headerlink" title="SEO自学笔记（五）"></a>SEO自学笔记（五）</h1><p>今天主要的工作是优化公司官网的关键词，去外网发外链，虽然心中质疑如今外链对优化还有没有作用，但还是做了，也积累了一些国外的外链资源，有需要的小伙伴也可以私聊我，我的企鹅是820567197.<br>言归正传，SEO抽空看了一些，只有一张笔记，发出来：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SEO自学笔记（五）&quot;&gt;&lt;a href=&quot;#SEO自学笔记（五）&quot; class=&quot;headerlink&quot; title=&quot;SEO自学笔记（五）&quot;&gt;&lt;/a&gt;SEO自学笔记（五）&lt;/h1&gt;&lt;p&gt;今天主要的工作是优化公司官网的关键词，去外网发外链，虽然心中质疑如今外链对优
      
    
    </summary>
    
      <category term="SEO" scheme="http://tanyibing.com/categories/SEO/"/>
    
    
      <category term="SEO" scheme="http://tanyibing.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>SEO自学笔记（四）</title>
    <link href="http://tanyibing.com/2018/08/01/SEO%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/08/01/SEO自学笔记（四）/</id>
    <published>2018-08-01T13:53:59.000Z</published>
    <updated>2018-08-01T13:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SEO自学笔记（四）"><a href="#SEO自学笔记（四）" class="headerlink" title="SEO自学笔记（四）"></a>SEO自学笔记（四）</h1><p>以下是今天的自学笔记：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SEO自学笔记（四）&quot;&gt;&lt;a href=&quot;#SEO自学笔记（四）&quot; class=&quot;headerlink&quot; title=&quot;SEO自学笔记（四）&quot;&gt;&lt;/a&gt;SEO自学笔记（四）&lt;/h1&gt;&lt;p&gt;以下是今天的自学笔记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure c
      
    
    </summary>
    
      <category term="SEO" scheme="http://tanyibing.com/categories/SEO/"/>
    
    
      <category term="SEO" scheme="http://tanyibing.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>SEO自学笔记（三）</title>
    <link href="http://tanyibing.com/2018/07/31/SEO%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/07/31/SEO自学笔记（三）/</id>
    <published>2018-07-31T13:58:21.000Z</published>
    <updated>2018-07-31T14:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SEO自学笔记（三）"><a href="#SEO自学笔记（三）" class="headerlink" title="SEO自学笔记（三）"></a>SEO自学笔记（三）</h1><p>自从github被微软收购之后，我用hexo来写博客就不是那么顺利了，就跟被墙一样，网站打开慢就不说了，昨晚一直hexo d命令报错，害得我把博客迁移了一遍，最后不知道怎么鬼使神差的上传好了。今天上传的时候又遇到了问题，搭了梯子才解决。在这吐槽一下，看到很多人已经把自己的项目都迁走了，感觉github的未来不是那么美好了。</p><p>言归正传，再上传一下我今天额外的SEO笔记：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SEO自学笔记（三）&quot;&gt;&lt;a href=&quot;#SEO自学笔记（三）&quot; class=&quot;headerlink&quot; title=&quot;SEO自学笔记（三）&quot;&gt;&lt;/a&gt;SEO自学笔记（三）&lt;/h1&gt;&lt;p&gt;自从github被微软收购之后，我用hexo来写博客就不是那么顺利了，就跟被
      
    
    </summary>
    
      <category term="SEO" scheme="http://tanyibing.com/categories/SEO/"/>
    
    
      <category term="SEO" scheme="http://tanyibing.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>SEO自学笔记（二）</title>
    <link href="http://tanyibing.com/2018/07/31/SEO%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/07/31/SEO自学笔记（二）/</id>
    <published>2018-07-31T13:40:04.000Z</published>
    <updated>2018-07-31T13:45:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SEO自学笔记（二）"><a href="#SEO自学笔记（二）" class="headerlink" title="SEO自学笔记（二）"></a>SEO自学笔记（二）</h1><p>紧接着第一天的内容，今天的学习笔记如下：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SEO自学笔记（二）&quot;&gt;&lt;a href=&quot;#SEO自学笔记（二）&quot; class=&quot;headerlink&quot; title=&quot;SEO自学笔记（二）&quot;&gt;&lt;/a&gt;SEO自学笔记（二）&lt;/h1&gt;&lt;p&gt;紧接着第一天的内容，今天的学习笔记如下：&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="SEO" scheme="http://tanyibing.com/categories/SEO/"/>
    
    
      <category term="SEO" scheme="http://tanyibing.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>SEO自学笔记（一）</title>
    <link href="http://tanyibing.com/2018/07/30/SEO%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tanyibing.com/2018/07/30/SEO自学笔记（一）/</id>
    <published>2018-07-30T14:28:13.000Z</published>
    <updated>2018-07-30T14:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SEO自学笔记（一）"><a href="#SEO自学笔记（一）" class="headerlink" title="SEO自学笔记（一）"></a>SEO自学笔记（一）</h1><p>最近在工作中要求学习一些SEO的技术来给主站进行一定的优化，所以自学了SEO的一些知识，我通过xmind思维导图做了一些笔记，下面就贴出我学习的过程：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/SEO/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SEO自学笔记（一）&quot;&gt;&lt;a href=&quot;#SEO自学笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;SEO自学笔记（一）&quot;&gt;&lt;/a&gt;SEO自学笔记（一）&lt;/h1&gt;&lt;p&gt;最近在工作中要求学习一些SEO的技术来给主站进行一定的优化，所以自学了SEO
      
    
    </summary>
    
      <category term="SEO" scheme="http://tanyibing.com/categories/SEO/"/>
    
    
      <category term="SEO" scheme="http://tanyibing.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>PHP中Session的清除和销毁</title>
    <link href="http://tanyibing.com/2018/03/26/PHP%E4%B8%ADSession%E7%9A%84%E6%B8%85%E9%99%A4%E5%92%8C%E9%94%80%E6%AF%81-1/"/>
    <id>http://tanyibing.com/2018/03/26/PHP中Session的清除和销毁-1/</id>
    <published>2018-03-26T09:48:30.000Z</published>
    <updated>2018-03-26T09:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP中session清除和销毁"><a href="#PHP中session清除和销毁" class="headerlink" title="PHP中session清除和销毁"></a>PHP中session清除和销毁</h1><p>今天在工作中使用session进行用户的登录验证操作，最后要进行用户注销的操作，也就是session的删除，所以查阅文档发现删除会话主要有删除单个会话、删除所有会话和结束当前会话的三种方式，以下就是三种清除session的具体方法：</p><h3 id="1-删除单个会话"><a href="#1-删除单个会话" class="headerlink" title="1.删除单个会话"></a>1.删除单个会话</h3><p>删除单个会话其实就是删单个会话的变量，和数组的操作一样，直接注销$_SESSION数组的某个元素即可。<br>例如：$_SESSION[“session_name”]变量，可以使用unset()函数，代码如下所示：<br><br><code>unset($_SESSION[&quot;session_name&quot;]);</code><br><br>注意：在使用unset()时，要注意$SESSION数组中的元素一定不可以可略，即不可以一次注销整个数组，这样会禁止整个会话的功能，一旦使用会将全局变量$_SESSION全局变量销毁，而且没有办法将其恢复，用户也不可能再注册$_SESSION变量，在php文档中也可以发现警告</p><blockquote><p><strong>Caution</strong>请不要使用unset($、_SESSION)来释放整个$_SESSION， 因为它将会禁用通过全局$_SESSION去注册会话变量</p></blockquote><h3 id="2-删除所有会话"><a href="#2-删除所有会话" class="headerlink" title="2.删除所有会话"></a>2.删除所有会话</h3><p>如果想吧某个用户在session中注册的所有变量都删除，也就是一次删除所有的会话变量，可以通过将一个空数组赋值给$_SESSION来实现，其代码显示如下：<br><br><code>$_SESSION = array();</code><br><br>也可以使用session_unset 来释放所有的会话变量,使用方法如下：<br><br><code>void session_unset ( void )</code><br><br>该函数没有返回值。</p><h3 id="3-删除当前会话"><a href="#3-删除当前会话" class="headerlink" title="3.删除当前会话"></a>3.删除当前会话</h3><p>如果整个会话已经结束，首先应该注销所有会话变量，然后使用 session_destroy()函数清除结束当前的会话，并清空会话中的所有资源，彻底销毁 Session，其代码如下显示：<br><br><code>session_destroy()；</code><br><br>相对于 session_start() 函数 （创建 Session 文件），session_destroy()函数用来关闭 Session 的运作 （删除 Session 文件），如果成功则返回 TURE，销毁 Session 资料失败则返回 FALSE。但该函数并不会释放和当前 Session 相关的变量，也不会删除保存在客户端 Cookie 中的 Session ID 。<br>下面是我在代码中实际使用的方法：<br></p><pre>if(isset($_SESSION['username'])){    $_SESSION = array();    if(isset($_COOKIE[session_name()])){       setcookie(session_name(),'',time()-3600);    }     session_destroy();}</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP中session清除和销毁&quot;&gt;&lt;a href=&quot;#PHP中session清除和销毁&quot; class=&quot;headerlink&quot; title=&quot;PHP中session清除和销毁&quot;&gt;&lt;/a&gt;PHP中session清除和销毁&lt;/h1&gt;&lt;p&gt;今天在工作中使用sessio
      
    
    </summary>
    
      <category term="php" scheme="http://tanyibing.com/categories/php/"/>
    
    
      <category term="php" scheme="http://tanyibing.com/tags/php/"/>
    
      <category term="session" scheme="http://tanyibing.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面渲染完成</title>
    <link href="http://tanyibing.com/2018/02/20/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90/"/>
    <id>http://tanyibing.com/2018/02/20/从输入URL到页面渲染完成/</id>
    <published>2018-02-20T10:09:24.000Z</published>
    <updated>2018-09-06T02:46:55.518Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>转载自<a href="http://chauncywu.com" target="_blank" rel="noopener">www.chauncywu.com</a></em></strong></p><h1 id="从输入URL到页面渲染完成"><a href="#从输入URL到页面渲染完成" class="headerlink" title="从输入URL到页面渲染完成"></a>从输入URL到页面渲染完成</h1><p><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="noopener">原文-英文</a><br><a href="http://blog.csdn.net/allenliu6/article/details/70313492" target="_blank" rel="noopener">译文</a></p><blockquote><p>推荐阅读《图解HTTP》</p></blockquote><h2 id="各种协议与HTTP协议的关系-参照该图理解下文"><a href="#各种协议与HTTP协议的关系-参照该图理解下文" class="headerlink" title="各种协议与HTTP协议的关系(参照该图理解下文)"></a>各种协议与HTTP协议的关系(参照该图理解下文)</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/0-1.png" alt="0-1" title="">                </div>                <div class="image-caption">0-1</div>            </figure><h2 id="1-输入URL地址"><a href="#1-输入URL地址" class="headerlink" title="1. 输入URL地址"></a>1. 输入URL地址</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/1-1.png" alt="1-1" title="">                </div>                <div class="image-caption">1-1</div>            </figure><h2 id="2-浏览器根据域名查询IP地址"><a href="#2-浏览器根据域名查询IP地址" class="headerlink" title="2. 浏览器根据域名查询IP地址"></a>2. 浏览器根据域名查询IP地址</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/2-1.png" alt="2-1" title="">                </div>                <div class="image-caption">2-1</div>            </figure><p>从要访问的域名中获取IP地址，DNS查询的步骤如下：</p><ol><li>从浏览器缓存中查询。浏览器会存储一定时间的DNS记录，操作系统不会告诉浏览器每个DNS记录的保存时限，不同浏览器设置保存时限为一个固定值（不同浏览器情况不同，一般在2-30分钟）。</li><li>从操作系统缓存中查询。如果浏览器中没有包含想要的缓存记录，那浏览器就会发起操作系统请求，继续查询操作系统缓存</li><li>从路由器中查询DNS缓存。请求持续发送到你的路由，它通常会有自己的DNS缓存。</li><li>从ISP中查询DNS缓存。下一个被查询地方是ISP缓存DNS的服务器。</li><li>域名服务器递归查询。首先从root域名服务器中查询如.com域名服务器，然后逐步向前查询，.com顶级域名服务器到Facebook的域名服务器。一般来说，.com级别的都已经在缓存中了，所以一般不会进行对root域名服务器的查询。下面给出一张递归查询的图。<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h4>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</li></ol><h4 id="DNS查询的两种方式：递归查询和迭代查询"><a href="#DNS查询的两种方式：递归查询和迭代查询" class="headerlink" title="DNS查询的两种方式：递归查询和迭代查询"></a>DNS查询的两种方式：递归查询和迭代查询</h4><h5 id="1、递归解析"><a href="#1、递归解析" class="headerlink" title="1、递归解析"></a>1、递归解析</h5><p>当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。<br>此时有两种方式，如图所示的是递归方式。<br>局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。<br>最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/2-2.png" alt="2-2" title="">                </div>                <div class="image-caption">2-2</div>            </figure><h5 id="2、迭代解析"><a href="#2、迭代解析" class="headerlink" title="2、迭代解析"></a>2、迭代解析</h5><p>当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。<br>局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。<br>也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。<br>比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/2-3.png" alt="2-3" title="">                </div>                <div class="image-caption">2-3</div>            </figure><h4 id="DNS域名称空间的组织方式"><a href="#DNS域名称空间的组织方式" class="headerlink" title="DNS域名称空间的组织方式"></a>DNS域名称空间的组织方式</h4><p>我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。<br>按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/2-4.jpg" alt="2-4" title="">                </div>                <div class="image-caption">2-4</div>            </figure><h2 id="3-浏览器发送HTTP请求到web服务器"><a href="#3-浏览器发送HTTP请求到web服务器" class="headerlink" title="3. 浏览器发送HTTP请求到web服务器"></a>3. 浏览器发送HTTP请求到web服务器</h2><p>向 <code>http://facebook.com/</code> 发出GET请求</p><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>在请求中，HTTP报文首部由方法、URI、HTTP版本、HTTP首部字段等构成。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/3-1.png" alt="3-1" title="">                </div>                <div class="image-caption">3-1</div>            </figure><h3 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/3-2.png" alt="3-2" title="">                </div>                <div class="image-caption">3-2</div>            </figure><h4 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h4><h5 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h5><ul><li><p>第一次握手：<br>  客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认；</p></li><li><p>第二次握手：<br>  服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。</p></li><li><p>第三次握手：<br>  客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/3-2-1.png" alt="3-2-1" title="">                </div>                <div class="image-caption">3-2-1</div>            </figure><h5 id="为什需要三次握手？"><a href="#为什需要三次握手？" class="headerlink" title="为什需要三次握手？"></a>为什需要三次握手？</h5><p>《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”</p><p>书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。<br>本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</p><p>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p><p>例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p><h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><ul><li><p>第一次挥手：<br>  Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p></li><li><p>第二次挥手：<br>  Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p></li><li><p>第三次挥手：<br>  Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p></li><li><p>第四次挥手：<br>  Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/3-2-2.png" alt="3-2-2" title="">                </div>                <div class="image-caption">3-2-2</div>            </figure><h5 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h5><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p><p>而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p><h5 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h5><p>客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/3-2-3.jpg" alt="3-2-3" title="">                </div>                <div class="image-caption">3-2-3</div>            </figure><h3 id="负责传输的IP协议"><a href="#负责传输的IP协议" class="headerlink" title="负责传输的IP协议"></a>负责传输的IP协议</h3><ul><li>IP间的通信依赖MAC地址</li><li>ARP协议：(Address Resolution Protocol)用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-从输入URL到页面渲染完成/3-3.png" alt="3-3" title="">                </div>                <div class="image-caption">3-3</div>            </figure><h2 id="4-Facebook服务器返回一个永久重定向响应"><a href="#4-Facebook服务器返回一个永久重定向响应" class="headerlink" title="4. Facebook服务器返回一个永久重定向响应"></a>4. Facebook服务器返回一个永久重定向响应</h2><p>服务器会发送一个301永久重定向响应来告诉浏览器访问 <code>http://www.facebook.com/</code> 而不是 <code>http://facebook.com/</code>。</p><p>为什么服务器坚持重定向而不是直接给予浏览器用户需要的结果，这有很多有意思原因:</p><ul><li>一个原因是搜索引擎排名，如果有两个URLs指向同一个页面，比如 <code>http://www.igoro.com/</code> 和 <code>http://igoro.com/</code> ,搜索引擎会认为这是两个不同的网站，结果他们两个每个都有一部分访问量，但是也只能拥有更低的搜索引擎排名。如果使用了301定位，搜索引擎将会识别重定向，进而将同一来源的多个链接算作一个。</li><li>另一个原因是，同样的内容多个URLs还不利于缓存，同样的内容拥有多个名字，潜在造成缓存浪费。</li></ul><h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><h4 id="301和302的区别："><a href="#301和302的区别：" class="headerlink" title="301和302的区别："></a>301和302的区别：</h4><p>301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。</p><p>他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址换为重定向之后的网址；</p><p>302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO 302好于301</p><h4 id="重定向原因："><a href="#重定向原因：" class="headerlink" title="重定向原因："></a>重定向原因：</h4><ul><li>网站调整（如改变网页目录结构）；</li><li>网页被移到一个新地址；</li><li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。<br>  这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</li></ul><h4 id="什么时候进行301或者302跳转呢？"><a href="#什么时候进行301或者302跳转呢？" class="headerlink" title="什么时候进行301或者302跳转呢？"></a>什么时候进行301或者302跳转呢？</h4><p>当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。</p><p>清晰明确而言：使用301跳转的大概场景如下：</p><p>1、 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。<br>2、 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。<br>3、 空间服务器不稳定，换空间的时候。</p><h2 id="5-浏览器会跟踪重定向地址"><a href="#5-浏览器会跟踪重定向地址" class="headerlink" title="5. 浏览器会跟踪重定向地址"></a>5. 浏览器会跟踪重定向地址</h2><p>浏览器知道了 <code>http://www.facebook.com/</code> 是真正应该访问的URL，所以就发送了另外一个GET请求。</p><h2 id="6-服务器处理请求"><a href="#6-服务器处理请求" class="headerlink" title="6. 服务器处理请求"></a>6. 服务器处理请求</h2><p>服务器会接收这个GET请求，并且返回一个响应结果</p><h3 id="怎么存储数据是每个动态网站都会面临的有趣难题"><a href="#怎么存储数据是每个动态网站都会面临的有趣难题" class="headerlink" title="怎么存储数据是每个动态网站都会面临的有趣难题"></a>怎么存储数据是每个动态网站都会面临的有趣难题</h3><p>小网站会经常有一个SQL数据库来存储他们的数据，但是网站存储数据量过大或者流量过大后就必须将数据库分布在多台机器，解决的方法有很多种</p><p>包括sharding(在主键基础上划分表到多个数据库中)，复制和使用简化的弱语义一致性数据库</p><h3 id="推迟一些任务到批处理作业是廉价保持数据更新的的一种技术。"><a href="#推迟一些任务到批处理作业是廉价保持数据更新的的一种技术。" class="headerlink" title="推迟一些任务到批处理作业是廉价保持数据更新的的一种技术。"></a>推迟一些任务到批处理作业是廉价保持数据更新的的一种技术。</h3><p>例如，Facebook必须尽快更新新闻供应，但数据支持的“你可能认识的人”功能可能只需要每晚进行更新（作者猜测是这样）。批处理作业的更新导致存在一些旧的相对不重要的数据，但是使数据更新更快更简单。</p><h2 id="7-服务器返回一个HTML响应"><a href="#7-服务器返回一个HTML响应" class="headerlink" title="7.服务器返回一个HTML响应"></a>7.服务器返回一个HTML响应</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,</span><br><span class="line">    pre-check=0</span><br><span class="line">Expires: Sat, 01 Jan 2000 00:00:00 GMT</span><br><span class="line">P3P: CP=&quot;DSP LAW&quot;</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">X-Cnection: close</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 12 Feb 2010 09:05:55 GMT</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整个完整的响应是36KB，其中大部分处理后由blob类型传送<br>内容编码头部告诉浏览器响应体使用了gzip压缩算法。在解析blob后，你就会看到你期望的HTML了。</p><h2 id="8-浏览器开始渲染HTML"><a href="#8-浏览器开始渲染HTML" class="headerlink" title="8. 浏览器开始渲染HTML"></a>8. 浏览器开始渲染HTML</h2><p>在浏览器接收完整HTML文件前，浏览器就开始渲染页面了。</p><h2 id="9-浏览器发送嵌入在HTML中的对象的请求"><a href="#9-浏览器发送嵌入在HTML中的对象的请求" class="headerlink" title="9. 浏览器发送嵌入在HTML中的对象的请求"></a>9. 浏览器发送嵌入在HTML中的对象的请求</h2><p>随着浏览器渲染HTML，浏览器会注意到有些标签需要请求其他URLs的资源，浏览器将会发送一个GET请求来重新获取每个文件 。</p><h2 id="10-浏览器发送异步请求"><a href="#10-浏览器发送异步请求" class="headerlink" title="10. 浏览器发送异步请求"></a>10. 浏览器发送异步请求</h2><p>在web2.0时代，即使在页面渲染后客户端还是持续与服务器端通信。</p><p>例如，当你的朋友上线或下线时，Facebook聊天功能将会持续更新你已经登录的朋友列表。为了更新这个列表，你浏览器上运行的JS将会发送异步请求到服务器，异步请求是发送给特殊URL的GET或POST请求。在Facebook的例子中，客户端会发送一个POST请求到 <code>http://www.facebook.com/ajax/chat/buddy_list.php</code> ，获取你在线的朋友列表</p><p>这个模式被称为AJAX，是“Asynchronous JavaScript And XML”,的缩写，虽然不太清楚为什么服务器必须将响应格式化为xml。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><p><a href="http://blog.csdn.net/czp11210/article/details/25193791" target="_blank" rel="noopener">当你访问淘宝的时候，发生了什么？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;转载自&lt;a href=&quot;http://chauncywu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.chauncywu.com&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;从输入URL到页面渲染完
      
    
    </summary>
    
      <category term="HTTP" scheme="http://tanyibing.com/categories/HTTP/"/>
    
    
      <category term="URL" scheme="http://tanyibing.com/tags/URL/"/>
    
      <category term="HTTP" scheme="http://tanyibing.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>hadoop单机安装、运行</title>
    <link href="http://tanyibing.com/2017/12/28/hadoop%E5%8D%95%E6%9C%BA%E9%85%8D%E7%BD%AE%E3%80%81%E8%BF%90%E8%A1%8C/"/>
    <id>http://tanyibing.com/2017/12/28/hadoop单机配置、运行/</id>
    <published>2017-12-28T14:28:13.000Z</published>
    <updated>2018-09-06T02:48:46.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1513179599832&di=5338ae758687dfbf1514313e6c522592&imgtype=0&src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F793015%2F201611%2F793015-20161127231256315-1152955812.png" alt="hadoop" title="">                </div>                <div class="image-caption">hadoop</div>            </figure><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><p><strong>Tanyibing</strong>，this is for <em>14级软件工程专业</em>，<em>My email <a href="mailto:&#116;&#x61;&#x6e;&#x79;&#105;&#98;&#105;&#x6e;&#x67;&#49;&#57;&#x39;&#x35;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#116;&#x61;&#x6e;&#x79;&#105;&#98;&#105;&#x6e;&#x67;&#49;&#57;&#x39;&#x35;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;</a> link</em> </p><h3 id="Hadoop环境准备工作"><a href="#Hadoop环境准备工作" class="headerlink" title="Hadoop环境准备工作"></a>Hadoop环境准备工作</h3><ul><li><strong>VMware版本VMware-workstation-full-12.5.7-5813279(版本自己选择)Xshell5自己选择是否使用</strong></li><li><strong>CentOS版本CentOS-6.4-x86_64-bin-DVD1(本人的是64位，其他版本未测试)</strong></li><li><strong>Hadoop版本hadoop-2.6.0(安装完系统后直接命令行安装)</strong></li><li><strong>jdk版本jdk-8u45-linux-x64.tar</strong></li><li><strong>需要了解基本的linux和vim的使用</strong></li></ul><h3 id="资源位置"><a href="#资源位置" class="headerlink" title="资源位置"></a>资源位置</h3><p><strong>百度网盘:<a href="https://pan.baidu.com/s/1i5s2eFF" target="_blank" rel="noopener">https://pan.baidu.com/s/1i5s2eFF</a></strong><br><strong>密码:n3jq</strong></p><p><strong>CentOS镜像下载地址<a href="http://mirror.nsc.liu.se/centos-store/6.4/isos/x86_64/" target="_blank" rel="noopener">http://mirror.nsc.liu.se/centos-store/6.4/isos/x86_64/</a></strong></p><h2 id="VMware安装以及CentOS安装"><a href="#VMware安装以及CentOS安装" class="headerlink" title="VMware安装以及CentOS安装"></a>VMware安装以及CentOS安装</h2><h3 id="VMware安装步骤省略"><a href="#VMware安装步骤省略" class="headerlink" title="VMware安装步骤省略"></a>VMware安装步骤省略</h3><h3 id="CentOS安装"><a href="#CentOS安装" class="headerlink" title="CentOS安装"></a>CentOS安装</h3><p>1.点击新建虚拟机</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>2.选择稍后操作系统</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>3.选择64位CentOS的系统</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>4.选择安装位置(最好不要放C盘)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>5.默认配置就好，点击下一步</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>6.点击自定义硬件</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>7.配置虚拟机的内存，我们的实验1G即可，电脑好的选择2G也可</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>8.选择虚拟化cpu(使用本机真实cpu)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>9.选择加载的镜像，选1盘，如果自己下载的话2盘是一些软件，不需要加载</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>10.<strong>桥接和NAT模式才能上网，我选择的是桥接(使用自己的真实网卡)</strong></p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>11.选择第一个选项(安装或升级系统)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>12.这一步选skip跳过即可</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>13.选择简体中文，点击下一步</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>14.选择英国美式，下一步</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>15.选择默认的基本存储设备，下一步</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>16.<strong>必须选择是，忽略所有数据</strong></p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>17.默认就行，下一步</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>18.自己输入密码（6位，字母数字），选择无论如何使用(因为我设置的密码不是安全的)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>19.为了更好的了解linux，现在进行分盘(挂载点)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>20.首先分给/home 2G(选择空闲点击创建，然后挂载点选/home)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>21.必须给/boot一定的空间(系统使用，及时其他出现问题也能正常开机，一般200M即可)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>22.接着给swap分4G空间(不是在挂载点选择，而是在文件系统类型选择)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>23.最后所有空间都分给 / 挂载点(根目录)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>24.选择将修改写入磁盘，点击下一步</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>25.默认即可，下一步</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>26.由于minimal存在一些兼容问题，选择Basic Server版本，点击下一步进行安装</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>27.安装完成，点击重新引导，重启虚拟机</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>28.先输入用户名：root 回车，接着输入密码(密码是不显示的，输入完回车就行)</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>29.现在一个虚拟机就终于安装完成了</p><h2 id="jdk、hadoop的解压"><a href="#jdk、hadoop的解压" class="headerlink" title="jdk、hadoop的解压"></a>jdk、hadoop的解压</h2><p><strong>1.将jdk解压到 /opt 下</strong></p><blockquote><pre><code>tar -zxvf jdk-8u45-linux-x64.tar.gz -C /opt</code></pre></blockquote><p><em>注意如果你的虚拟机自带openjdk需要先卸载</em></p><blockquote><pre><code>rpm -qa | grep java //检查机器上的jdk</code></pre></blockquote><p>应该显示这一类的结果：</p><blockquote><pre><code>java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64javapackages-tools-3.4.1-11.el7.noarchjava-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64</code></pre></blockquote><p>使用下面的命令删除上面列出的内容：</p><blockquote><pre><code>rpm -e --nodeps + 上面出现的内容</code></pre></blockquote><p><strong>2.将hadoop解压到 /opt/hadoop 下</strong></p><blockquote><pre><code>tar -zxvf hadoop-2.6.0-x64.tar.gz -C /opt/hadoop</code></pre><p><em>没有hadoop目录的自己在/opt下创建</em></p></blockquote><p>在/root /hadoop/目录下，建立tmp、hdfs/name、hdfs/data目录，执行如下命令：</p><blockquote><pre><code>mkdir /opt/hadoop/tmp mkdir /opt/hadoop/hdfs mkdir /opt/hadoop/hdfs/data mkdir /opt/hadoop/hdfs/name </code></pre></blockquote><p>##ssh的安装、无密码配置</p><p><strong>1.检查</strong></p><p>CentOS 默认已安装了 SSH client、SSH server，打开终端执行如下命令进行检验：</p><blockquote><pre><code>rpm -qa | grep ssh </code></pre></blockquote><p>成功显示出client、server版本的话则无需安装，若需要安装，则可以通过 yum 进行安装（安装过程中会让你输入 [y/N]，输入 y 即可）：</p><blockquote><pre><code>sudo yum install openssh-clientssudo yum install openssh-server</code></pre></blockquote><p>接着执行如下命令测试一下 SSH 是否可用：</p><blockquote><pre><code>ssh localhost</code></pre></blockquote><p>此时会有提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码，就登陆到本机了。</p><p><strong>2.ssh无密码配置</strong></p><p>上面这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。</p><p>首先输入 exit 退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中：</p><blockquote><pre><code>exit                           # 退出刚才的 ssh localhostcd ~/.ssh/                     # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa              # 会有提示，都按回车就可以cat id_rsa.pub &gt;&gt; authorized_keys  # 加入授权chmod 600 ./authorized_keys    # 修改文件权限</code></pre></blockquote><p>此时再用 ssh localhost 命令，无需输入密码就可以直接登陆了。</p><h2 id="jdk、hadoop的配置"><a href="#jdk、hadoop的配置" class="headerlink" title="jdk、hadoop的配置"></a>jdk、hadoop的配置</h2><p><strong>1.环境变量的配置</strong></p><blockquote><pre><code>vim /etc/profile加入如下配置：     export JAVA_HOME=/opt/jdk1.8.0_45export HADOOP_HOME=/opt/hadoop/hadoop-2.6.0exportCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:exportPATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:</code></pre></blockquote><p>保存后，不要忘记执行如下命令使配置生效：</p><blockquote><pre><code>source /etc/profile</code></pre></blockquote><p><strong>2.hosts文件的修改</strong></p><blockquote><pre><code>vim /etc/hosts最后加入如下内容：127.0.0.1    自己的主机名</code></pre></blockquote><p><strong>3.hadoop配置</strong></p><p>进入/opt/hadoop/hadoop-2.6.0/etc/hadoop目录</p><h5 id="1-在hadoop-env-sh和-yarn-env-sh的开头添加如下环境变量-一定要添加"><a href="#1-在hadoop-env-sh和-yarn-env-sh的开头添加如下环境变量-一定要添加" class="headerlink" title="1)在hadoop-env.sh和 yarn-env.sh的开头添加如下环境变量(一定要添加)"></a>1)在hadoop-env.sh和 yarn-env.sh的开头添加如下环境变量(一定要添加)</h5><blockquote><pre><code>export JAVA_HOME=/opt/jdk1.8.0_45 </code></pre></blockquote><h5 id="2-配置core-site-xml"><a href="#2-配置core-site-xml" class="headerlink" title="2)配置core-site.xml"></a>2)配置core-site.xml</h5><blockquote><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;fs.default.name&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;        &lt;description&gt;HDFS的URI，文件系统://namenode标识:端口号&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/opt/hadoop/tmp&lt;/value&gt;        &lt;description&gt;namenode上本地的hadoop临时文件夹&lt;/description&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre></blockquote><h5 id="3-配置hdfs-site-xml"><a href="#3-配置hdfs-site-xml" class="headerlink" title="3)配置hdfs-site.xml"></a>3)配置hdfs-site.xml</h5><blockquote><pre><code>&lt;configuration&gt;    &lt;!—hdfs-site.xml--&gt;    &lt;property&gt;        &lt;name&gt;dfs.name.dir&lt;/name&gt;        &lt;value&gt;/opt/hadoop/hdfs/name&lt;/value&gt;        &lt;description&gt;namenode上存储hdfs名字空间元数据 &lt;/descriptio&gt;              &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.data.dir&lt;/name&gt;        &lt;value&gt;/opt/hadoop/hdfs/data&lt;/value&gt;        &lt;description&gt;datanode上数据块的物理存储位置&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;        &lt;description&gt;副本个数，配置默认是3,应小于datanode机器数量&lt;/description&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre></blockquote><h5 id="4-配置yarn-site-xml"><a href="#4-配置yarn-site-xml" class="headerlink" title="4)配置yarn-site.xml"></a>4)配置yarn-site.xml</h5><blockquote><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;        &lt;value&gt;${yarn.resourcemanager.hostname}:8099&lt;/value&gt;    &lt;/propert&gt;     &lt;/configuration&gt;</code></pre></blockquote><p>#####4)配置mapred-site.xml </p><p>目录下没有mapred-site.xml，只有mapred-site.xml.template(模板)，所以将其复制重命名为mapred-site.xml:</p><blockquote><pre><code>cp mapred-site.xml.template mapred-site.xml</code></pre></blockquote><p>然后再配置mapred-site.xml:</p><blockquote><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;        &lt;value&gt;yarn&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre></blockquote><h5 id="5-配置yarn-site-xml"><a href="#5-配置yarn-site-xml" class="headerlink" title="5)配置yarn-site.xml"></a>5)配置yarn-site.xml</h5><blockquote><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;        &lt;value&gt;${yarn.resourcemanager.hostname}:8099&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre></blockquote><h2 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h2><p><strong>1.格式化namenode</strong></p><blockquote><pre><code>hadoop namenode -format</code></pre></blockquote><p><strong>2.启动hadoop</strong></p><blockquote><pre><code>start-all.sh</code></pre></blockquote><p><strong>3.启动验证</strong></p><blockquote><pre><code>jps</code></pre><p>应该输出如下的结果:</p></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p>在浏览器输入虚拟机的ip地址，例如：192.168.31.0:50070，能够打开如下网页：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2017-12-20-hadoop单机配置、运行/30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote><p><strong><em>至此，hadoop环境安装已经全部完成</em></strong></p><h2 id="hadoop下运行MapReduce代码"><a href="#hadoop下运行MapReduce代码" class="headerlink" title="hadoop下运行MapReduce代码"></a><strong><em>hadoop下运行MapReduce代码</em></strong></h2><p><strong>在此，使用WordCount的旧版api版本演示</strong></p><p><strong>1.编写WordCount.java,包含Mapper类和Reducec类</strong></p><blockquote><pre><code>import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;public class WordCount {   public static class WordCountMap extends           Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {       private final IntWritable one = new IntWritable(1);       private Text word = new Text();       public void map(LongWritable key, Text value, Context context)               throws IOException, InterruptedException {           String line = value.toString();           StringTokenizer token = new StringTokenizer(line);           while (token.hasMoreTokens()) {               word.set(token.nextToken());               context.write(word, one);           }       }   }   public static class WordCountReduce extends           Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {       public void reduce(Text key, Iterable&lt;IntWritable&gt; values,               Context context) throws IOException, InterruptedException {           int sum = 0;           for (IntWritable val : values) {               sum += val.get();           }           context.write(key, new IntWritable(sum));       }   }   public static void main(String[] args) throws Exception {       Configuration conf = new Configuration();       Job job = new Job(conf);       job.setJarByClass(WordCount.class);       job.setJobName(&quot;wordcount&quot;);       job.setOutputKeyClass(Text.class);       job.setOutputValueClass(IntWritable.class);       job.setMapperClass(WordCountMap.class);       job.setReducerClass(WordCountReduce.class);       job.setInputFormatClass(TextInputFormat.class);       job.setOutputFormatClass(TextOutputFormat.class);       FileInputFormat.addInputPath(job, new Path(args[0]));       FileOutputFormat.setOutputPath(job, new Path(args[1]));       job.waitForCompletion(true);   }}</code></pre></blockquote><p><strong>2.编译WordCount.java文件</strong></p><blockquote><p>javac WordCount.java -d 指定到你希望的目录下</p></blockquote><p>此时目录下应该多出三个文件：<em>WordCount.class</em>、<em>WordCount$WordCountMap.class</em>、WordCount$WordCountReduce.class</p><p><strong>3.将以上的.class文件打包成.Jar文件</strong></p><blockquote><pre><code>jar -cvf 你希望指定的名字.jar *.class</code></pre></blockquote><p><strong>4.创建hadoop的input和output目录</strong></p><blockquote><pre><code>hadoop fs -mkdir inputhadoop fs -mkdir output</code></pre></blockquote><p><strong>5.将要输入的文件放进input目录下</strong></p><blockquote><pre><code>hadoop fs -put 你要放入计算的文件 input</code></pre></blockquote><p><strong>6.hadoop运行Jar文件并计算结果</strong></p><blockquote><pre><code>hadoop jar WordCount.Jar WordCount input/file output(hadoop jar jar包路径 执行的主函数名(主类名，main方法所在类名) 输入目录名 输出目录名)</code></pre></blockquote><p><strong>7.查看结果(前提是不报错，成功运行完)</strong></p><p>成功的话，output目录下会出现一个part-r-xxxx</p><blockquote><pre><code>hadoop fs cat output/part-r-00000 #查看提交的结果</code></pre></blockquote><h2 id="附-xshell5、VMware-tools使用安装"><a href="#附-xshell5、VMware-tools使用安装" class="headerlink" title="附(xshell5、VMware tools使用安装)"></a>附(xshell5、VMware tools使用安装)</h2><p><strong><em>VMware Tools可以让虚拟机和你的主机之间共享一个文件夹,具体操作不在此赘述，点击链接自行按教程安装<a href="https://jingyan.baidu.com/article/8ebacdf070c40c49f75cd558.html" target="_blank" rel="noopener">VMware Tools安装</a></em></strong></p><p><strong><em>Xshell可以方便开发,具体操作不在此赘述，点击链接自行按教程安装<a href="http://blog.csdn.net/white_gs/article/details/52263365" target="_blank" rel="noopener">Xshell安装</a></em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;云计算&quot;&gt;&lt;a href=&quot;#云计算&quot; class=&quot;headerlink&quot; title=&quot;云计算&quot;&gt;&lt;/a&gt;云计算&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbo
      
    
    </summary>
    
      <category term="hadoop" scheme="http://tanyibing.com/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://tanyibing.com/tags/hadoop/"/>
    
      <category term="java" scheme="http://tanyibing.com/tags/java/"/>
    
      <category term="VMware" scheme="http://tanyibing.com/tags/VMware/"/>
    
      <category term="Windows" scheme="http://tanyibing.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://tanyibing.com/2017/12/25/hello-world/"/>
    <id>http://tanyibing.com/2017/12/25/hello-world/</id>
    <published>2017-12-25T02:28:13.000Z</published>
    <updated>2018-08-21T16:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo" scheme="http://tanyibing.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://tanyibing.com/tags/hexo/"/>
    
  </entry>
  
</feed>
