[{"title":"Jade怎么玩","date":"2018-09-13T02:24:18.000Z","path":"2018/09/13/Jade怎么玩/","text":"前端想要用模板，那就看看Jade吧，打开我们的Jade官网，上去看看呢，结果发现官网真的很水，水在哪呢？特喵的，给的代码没有一个注意缩进的，这也就导致后面很多模板使用jade命令时报错，有失水准啊！ 好在咋们国人搞的还是比较靠谱：点这可以学习Jade 你不会真以为我要写个技术博客吧，我只是来吐槽下，Jade很简单，自己去学吧，几分钟就会了。","tags":[{"name":"Jade","slug":"Jade","permalink":"http://tanyibing.com/tags/Jade/"}]},{"title":"Generator函数","date":"2018-09-12T08:09:54.000Z","path":"2018/09/12/Generator函数/","text":"Generator函数昨天的Promise对象就是一种异步编程解决方案，今天再看一种方案，这就是Generator函数。网上有很多关于Generator的介绍，例如： Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator的创建接下来我们看一下怎么定义一个Generator函数： function* helloWorldGenerator() { yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;; } var hw = helloWorldGenerator(); 我们发现在function关键字和函数名称之间有个星号，这表示这是一个Generator函数。但这样还不行，进入函数我们发现使用了yield表达式，定义了不同的内部状态(yield在英语中就是“产生”的意思)。这样我们一共定义了三个状态：hello、word和一个return语句。 Generator的调用Generator函数返回的是一个遍历器对象，也就是说我们需要调用next方法来遍历函数中的状态： hw.next() // { value: &apos;hello&apos;, done: false } hw.next() / { value: &apos;world&apos;, done: false } hw.next() // { value: &apos;ending&apos;, done: true } hw.next() / { value: undefined, done: true } 上面一共运行了四次next方法。 第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 Generator函数的作用这个东西看上去好像没啥用，那么它到底能干点啥呢？ 把异步回调变成‘同步’代码例如我们写个ajax代码： ajax(&apos;http://url-1&apos;, data1, function (err, result) { if (err) { return handle(err); } ajax(&apos;http://url-2&apos;, data2, function (err, result) { if (err) { return handle(err); } ajax(&apos;http://url-3&apos;, data3, function (err, result) { if (err) { return handle(err); } return success(result); }); }); }); 这个代码简直不想看，那么我们可以用Generator来改造下： try { r1 = yield ajax(&apos;http://url-1&apos;, data1); r2 = yield ajax(&apos;http://url-2&apos;, data2); r3 = yield ajax(&apos;http://url-3&apos;, data3); success(r3); } catch (err) { handle(err); } 这样看上去好多了，但不是真正的同步代码，至少看上去很像。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://tanyibing.com/tags/ECMAScript6/"}]},{"title":"Promise对象","date":"2018-09-11T08:07:08.000Z","path":"2018/09/11/Promise对象/","text":"Promise对象Promise的介绍Promise在ECMAScript6中被正式写进了语言标准，这是异步编程的一种解决方案，较之传统的函数回调和事件，Promise来得更加强大。Promise被理解成一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise有三个状态，分别是： pending：进行中 fulfilled：已成功 rejected：已失败 这三个状态是根据异步操作的结果来决定的，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。这三个状态一旦确定就不会在改变了。 Promise的使用创建怎么创建一个Promise实例呢： const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); 其中两个方法，resolve用来处理异步操作成功的结果，将其结果传递出去，在后面的then方法中去接受，reject用来处理操作失败的结果并传递出去，也可用then方法接收。 then方法的使用Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数： promise.then(function(value) { // success }, function(error) { // failure }); 其中第二个函数是可选的。这两个函数就是用来接收上面传出来的结果的。而且需要注意的是then方法返回是一个新的Promise，也就是说我们可以进行链式编程。 Promise执行顺序Promise在新建之后就会立即执行，举个例子： let promise = new Promise(function(resolve, reject) { console.log(&apos;a&apos;); resolve(); }); promise.then(function() { console.log(&apos;b&apos;); }); console.log(&apos;c&apos;); // a // c // b 上面的代码先输出a，因为Promise新建之后就立即执行，then方法在当前脚本所有同步任务执行完才执行，最后才会输出b。 Promise和其他技术昨天我看了RxJS，发现这两货好像有点像，一个是把所有数据都变成流进行操作。一个是一直返回Promise，通过then方法一直链式操作，那就比较一下吧。 操作 可观察对象 承诺 创建 new Observable((observer) =&gt; {observer.next(123);}); new Promise((resolve, reject) =&gt; {resolve(123);}); 转换 obs.map((value) =&gt; value * 2 ); promise.then((value) =&gt; value * 2); 订阅 sub = obs.subscribe((value) =&gt; {console.log(value)}); promise.then((value) =&gt; {console.log(value);}); 取消订阅 sub.unsubscribe(); 承诺被解析时隐式完成。 Promise的应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 const preloadImage = function (path) { return new Promise(function (resolve, reject) { const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); };","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://tanyibing.com/tags/ECMAScript6/"}]},{"title":"初入RxJS","date":"2018-09-10T03:21:19.000Z","path":"2018/09/10/初入RxJS/","text":"RxJS简介刚开始接触angular的时候就发现，RxJS在angular中是使用的最多的框架。它的全称是：Reactive Extension。这套框架其实是源自于微软，微软在2011年就已经开发出这套框架了，但真正火起来是在NetFlix，支持很多语言的一套响应式编程的框架，感兴趣可以去它的官网看看：reactivex.io，支持了这么多语言！！！ 它的优势在于：在思考的维度上加上时间考量。，这也是一个问题，导致更难理解！ ObservableObservable的性质Observable有三种状态，分别是： next：必要。用来处理每个送达值。在开始执行后可能执行零次或多次。 error：可选。用来处理错误通知。错误会中断这个可观察对象实例的执行过程。 complete：可选。用来处理执行完毕（complete）通知。当执行完毕后，这些值就会继续传给下一个处理器。 还有特殊的Observable：永不结束的、Never、Empty（结束但不发射）、Throw 本来是想写介绍点操作符的，但是我发现没啥意思，反正文档都能查到，那就记录点自己对Observable的理解吧，具体操作符到时候查api。其实Observable就是将数据以流的形式来进行处理，可以理解成node中的流，我们可以对流进行一系列的操作，最后我们再订阅这个流，对流里面的数据进行使用。 举个例子吧: const a: Array&lt;number&gt; = [1, 2, 3, 4]; const a$ = Rx.Observable.from(a).pipe(map( val =&gt; val * val)); const observer = { next: (val) =&gt; console.log(val); error： (err) =&gt; console.log(err); complete: () =&gt; console.log(`everything is completed`); } a$.subscribe(observer); 上面的例子会打印出： 1 4 9 16 因为我们对流中的数据进行了map操作，使它们自己乘以自己。这就是对流的一个简单处理，连pipe方法都和node中的流一样。 Observable的冷和热Observable有两种，一种是冷的，一种是热的。怎么去理解呢？下面的内容在angular的官网上并没有说明 冷的就是表示，每次你订阅之后我们都会从头执行一遍，就像看重播一样，点击之后都是重头开始播放； 热代表每次订阅之后大家之间的进度是一样的，就像看直播一样，打开之后都是最新时刻的通知。 未完待续。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular动画","date":"2018-09-07T06:48:12.000Z","path":"2018/09/07/angular动画/","text":"Angular动画在angular2的时候，angular动画还是个核心的组件库，但是到了angular4的时候，为了减小核心库的体积，所以移除出核心组件。但并不是不重要，它依然是angular中很重要的组成部分，而且也是官方提供的支持。 angular动画架构其实很简单，就是在组件里面定义数个触发器，每个触发器会有一系列的状态和过渡效果，其实这就是动画。 State &amp; Transiton（这两个是核心） 动画其实就是从一个状态过渡到另一个状态 状态本身包含形状、颜色、大小等等 State就是定义状态而Transition是定义如何过渡 Animate函数其实在Transition函数中，还会调用另一个函数，那就是Animate Animate规定了具体怎么样过渡，比如时间、过渡的速度等 Animate有多个重载形式 使用流程引入关键模块并声明import { BrowserModule } from &apos;@angular/platform-browser&apos;; import { BrowserAnimationsModule } from &apos;@angular/platform-browser/animations&apos;; @NgModule({ imports: [ BrowserModule, BrowserAnimationsModule ], }) export class AppModule { } 建议在imports中最后引入BrowserAnimationsModule模块，放在前面可能会踩坑。 定义各种状态拿个官网的例子来看看： @Component({ ... //这里是一些正常的定义 animations: [ trigger(&apos;heroState&apos;, [ state(&apos;inactive&apos;, style({ backgroundColor: &apos;#eee&apos;, transform: &apos;scale(1)&apos; })), state(&apos;active&apos;, style({ backgroundColor: &apos;#cfd8dc&apos;, transform: &apos;scale(1.1)&apos; })), transition(&apos;inactive =&gt; active&apos;, animate(&apos;100ms ease-in&apos;)), transition(&apos;active =&gt; inactive&apos;, animate(&apos;100ms ease-out&apos;)) ]) ] }) 这里定义了两个状态，一个是active还有个是incative，这两个状态分别有不同的style样式，transition定义了从不同状态过渡到另一个状态的过程。 附加到模板上template: ` &lt;ul&gt; &lt;li *ngFor=&quot;let hero of heroes&quot; [@heroState]=&quot;hero.state&quot; (click)=&quot;hero.toggleState()&quot;&gt; {{hero.name}} &lt;/li&gt; &lt;/ul&gt; ` 只要使用[@triggerName]语法加到模板上就行了。这就是一个简单的动画效果。 更多的深入知识，例如缓动函数、关键帧需要的话可以去官网看看，在这贴两个好玩的网址出来： https://easings.net/zh-cnhttp://cubic-bezier.com/#.17,.67,.83,-0.63","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular实战中踩过的坑（不定时更新）","date":"2018-09-07T04:08:48.000Z","path":"2018/09/07/angular实战中踩过的坑（不定时更新）/","text":"动态表单中踩过的坑2018-9-7问题：今天在写动态表单时遇到个问题，我在控制器中生成的formControl死活就是拿不到我输入的值。 分析：生成formControl的代码肯定没有问题： let fb = new FormBuilder(); this.formModel = fb.group({ title: [&apos;&apos;, Validators.minLength(3)], price: [null, this.positiveNumberValidator], category: [&apos;-1&apos;] }); 对吧，是没有问题，那肯定就是出在绑定模板的时候，于是我们认真看看吧。 问题根源： 发现了吧，这个Name由于打快了，打成了小写！低级错误！以后拼写细心点！ 版本更新问题问题：我想要做个商品筛选的功能，其中我需要使用debounceTime方法来对我的输入行为产生一个延时的处理，我的调用方法如下： 引入的是： import ‘rxjs/RW’; 结果引入报错。 分析：既然引入报错肯定是更新过了，目录结构发生变化了，甚至连方法的使用也有可能改变了，还是去官方找找吧。 问题根源：一查果然是更新的问题，而且不出意料，方法也需要修改下，经过修改后引入的方式如下： import { debounceTime } from ‘rxjs/operators’; 方法也需要改进成下面这种:","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"Koa中使用Cookie & Session","date":"2018-09-06T02:43:21.000Z","path":"2018/09/06/Koa中使用Cookie-Session/","text":"koa中cookie和session使用 cookie介绍cookie 是存储于访问者的计算机中的变量（客户端）。可以让我们用同一个浏览器访问同一个域名的时候共享数据。那为什么不使用http呢？很简单，因为HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。 cookie用处随便举几个例子： 存储用户信息，例如登陆信息。 浏览历史记录。 猜你喜欢的功能。 10天免登陆。 多个页面之间的数据传递。 实现购物车功能。 Koa Cookie的使用Koa中设置Cookie的值ctx.cookies.set(name, value, [options]) 通过options设置cookie name的value: options名称 options值 maxAge 一个数字表示从 Date.now() 得到的毫秒数。 expires cookie 过期的 Date path cookie 路径, 默认是’/‘。 secure 安全 cookie 默认 false，设置成 true 表示只有 https 可以访问。 httpOnly 是否只是服务器可访问 cookie, 默认是 true overwrite 一个布尔值，表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（不管路径或域）是否在设置此 Cookie 时从Set-Cookie 标头中过滤掉。 Koa中设置中文Cookieconsole.log(new Buffer(&apos;hello, world!&apos;).toString(&apos;base64&apos;));// 转换成 base64 字符串：aGVsbG8sIHdvcmxkIQ== console.log(new Buffer(&apos;aGVsbG8sIHdvcmxkIQ==&apos;, &apos;base64&apos;).toString());// 还原 base64 字符串：hello, world! Session介绍session 是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 Session 的工作流程当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session 对象，生成一个类似于 key,value的键值对，然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的Session(value)。 客户的信息都保存在Session中。 koa-session 的使用npm install koa-session --save 引入 express-sessionconst session = require(&apos;koa-session&apos;); 设置官方文档提供的中间件app.keys = [&apos;some secret hurr&apos;]; const CONFIG = { key: &apos;koa:sess&apos;, //cookie key (default is koa:sess) maxAge: 86400000, // cookie 的过期时间 maxAge in ms (default is 1 days) overwrite: true, //是否可以 overwrite (默认 default true) httpOnly: true, //cookie 是否只有服务器端可以访问 httpOnly or not (default true) signed: true, //签名默认 true rolling: false, //在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） renew: false, //(boolean) renew session when session is nearly expired, }; app.use(session(CONFIG, app)); Cookie 和 Session 区别 cookie 数据存放在客户的浏览器上，session 数据放在服务器上。 cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗考虑到安全应当使用 session。 session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE。 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。","tags":[{"name":"Node","slug":"Node","permalink":"http://tanyibing.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://tanyibing.com/tags/Koa/"}]},{"title":"分享按钮功能的实现","date":"2018-09-05T09:07:22.000Z","path":"2018/09/05/分享按钮功能的实现/","text":"Facebook分享功能事项今天需要实现一个点击按钮进行分享的功能，而且需要是多平台，之前了解过应该是通过调用各个平台的api进行实现的，没办法，去网上找找方法吧。 首先找个Facebook的实现看看效果，当你只是想分享一个链接到facebook中的时候，我们只需要将分享的url作为参数的形式传递到facebook网站即可，如下： “http://www.facebook.com/sharer/sharer.php?u=&quot; + url; 当然也可以当成参数的形式传递： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;share_button&quot; type=&quot;button&quot; value=&quot;share to facebook&quot; /&gt; &lt;script type=&quot;text/JavaScript&quot;&gt; function popupwindow(url, title, w, h) { wLeft = window.screenLeft ? window.screenLeft : window.screenX; wTop = window.screenTop ? window.screenTop : window.screenY; var left = wLeft + (window.innerWidth / 2) - (w / 2); var top = wTop + (window.innerHeight / 2) - (h / 2); return window.open(url, title, &apos;toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=&apos; + w + &apos;, height=&apos; + h + &apos;, top=&apos; + top + &apos;, left=&apos; + left); } window.onload = function () { document.getElementById(&apos;share_button&apos;).onclick = function(){ var shareUrl = &quot;http://www.facebook.com/sharer/sharer.php?u=https://www.google.com&quot;; popupwindow(shareUrl, &apos;Facebook&apos;, 600, 400); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 上面虽然分享成功了，但是分享的内容显得很死板，只有一些文字，如何自定义我们的内容呢？我们需要在被分享的网站的页面上添加一些meta标签，facebook会自己从所分享的页面上去抓取这些标签里的内容，你可以自定义图片、描述等等。 在定义了这些之后就更加生动了： &lt;meta property=&quot;og:title&quot; content=&quot;百度&quot;&gt; &lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt; &lt;meta property=&quot;og:image&quot; content=&quot;www.baidu.com/img/bd_logo1.png&quot;&gt; &lt;meta property=&quot;og:description&quot; content=&quot;百度一下，你就知道&quot;&gt; 当然，你可能想动态的去生成这些东西，这就复杂一些，需要用到facebook中的Javascript SDK: &lt;script&gt; window.fbAsyncInit = function() { FB.init({ appId : &apos;your-app-id&apos;, autoLogAppEvents : true, xfbml : true, version : &apos;v2.10&apos; }); FB.AppEvents.logPageView(); }; (function(d, s, id){ var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) {return;} js = d.createElement(s); js.id = id; js.src = &quot;//connect.facebook.net/en_US/sdk.js&quot;; fjs.parentNode.insertBefore(js, fjs); }(document, &apos;script&apos;, &apos;facebook-jssdk&apos;)); &lt;/script&gt; 在他们的官网可以看更多。 我们还可以通过facebook develop来检测你要分享的网站的效果，并且在这里可以生成使用sdk所需要的appid，而且可以在这里看到网址的被转发数，点击数之类的。 这样就完成facebook的分享功能了，但他喵的是不是也太麻烦了，果断找找有没有别的方法，难道你还真以为我会一个个写下去！！！？？？结果还真找到了一个方法，那就是Mob上面的ShareSDK啦。 怎么实现？首先在里面找到你需要的简单的，首先在下图中找到你要的，然后傻瓜式写代码就行了 &lt;!--MOB SHARE BEGIN--&gt; &lt;div class=&quot;-mob-share-ui-button -mob-share-open&quot;&gt;分享&lt;/div&gt; &lt;div class=&quot;-mob-share-ui&quot; style=&quot;display: none&quot;&gt; &lt;ul class=&quot;-mob-share-list&quot;&gt; &lt;li class=&quot;-mob-share-weibo&quot;&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qzone&quot;&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qq&quot;&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-douban&quot;&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-facebook&quot;&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-twitter&quot;&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;-mob-share-close&quot;&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;-mob-share-ui-bg&quot;&gt;&lt;/div&gt; &lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey=你的appkey&quot;&gt;&lt;/script&gt; &lt;!--MOB SHARE END--&gt; 这是最简单的一种，至于怎么扩展，文档写的很清楚，也很傻瓜式，我就不再傻瓜式的写出来了，影响我的形象。啦啦啦啦！！！","tags":[{"name":"Web SDK","slug":"Web-SDK","permalink":"http://tanyibing.com/tags/Web-SDK/"}]},{"title":"angular应用的构建和部署","date":"2018-09-04T02:11:32.000Z","path":"2018/09/04/angular应用的构建和部署/","text":"第一步 构建我们知道我们的angular应用是使用Typescript进行编写的，而浏览器不能直接运行Typescript，而且我们的样式可能是使用scss编写的，我们需要将这所有的一切进行整合，构建成浏览器能看得懂的文件。索性的是angular cli工具已经帮我们准备好了一切，我们只要执行一条命令就行了： ng build 然后我们就得到了这样一个dist文件夹，这样我们就已经构建好了。 第二步 部署部署简单啊，例如node的服务器，直接新建一个目录，然后把dist里面的文件都复制进去就行了，这样就算是部署完成了。 多环境配置为了让我们的项目能在多种环境下都能运行，我们需要做多环境配置，具体配置方法还在研究中！","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular中的两种表单","date":"2018-09-03T06:44:55.000Z","path":"2018/09/03/angular中的两种表单/","text":"表单forms是前端中很重要的一块内容，Angular中同样如此。在Angular中，有两种表单的形式，一种是模板驱动表单，还有一种是响应式表单。接下来就简单的介绍一下： 模版驱动表单区别：只能在模板中操作，不能在代码中操作。不说了，直接上个表单： &lt;form #myForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;div&gt;用户名：&lt;input ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;div&gt;手机号：&lt;input ngModel name=&quot;mobile&quot; type=&quot;number&quot;&gt;&lt;/div&gt; &lt;div ngModelGroup=&quot;passwordsGroup&quot;&gt; &lt;div&gt;密码：&lt;input ngModel name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/div&gt; &lt;div&gt;确认密码：&lt;input ngModel name=&quot;pconfirm&quot; type=&quot;password&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt; &lt;/form&gt; 响应式表单区别：只能在代码中操作，不能在模板中操作。响应式表单一共分为两步： 创建数据模型由三个类组成：FormControl、FormGroup、FormArray，怎么创建呢？直接贴出代码： export class ReactiveFormComponent implements OnInit { username: FormControl = new FormControl(&apos;username&apos;); formModel: FormGroup = new FormGroup({ dateRange: new FormGroup({ from: new FormControl(), to: new FormControl() }), emails: FormArray = new FormArray([ new FormControl(&quot;a@a.com&quot;), new FormControl(&quot;b@b.com&quot;) ]); }); } 使用响应式表单指令绑定表单模版 html &lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt; &lt;div formGroupName=&quot;dateRange&quot;&gt; 起始日期：&lt;input type=&quot;date&quot; formControlName=&quot;from&quot;&gt; 截止日期：&lt;input type=&quot;date&quot; formControlName=&quot;to&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;ul formArryName=&quot;emails&quot;&gt; &lt;li *ngFor=&quot;let e of this.formModel.get(&apos;emails&apos;).controls; let i = index;&quot;&gt; &lt;input type=&quot;text&quot; [formControlName]=&quot;i&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button type=&quot;button&quot; (click)=&quot;addEmail()&quot;&gt;增加email&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; js addEmail(){ let emails = this.formModel.get(&quot;emails&quot;) as FormArray; emails.push(new FormControl()); } 这样看上去是不是代码很多，有个简化的方法就是使用FormBuilder，使用首先要引入，然后再constructor中注册，然后给个对比吧： profileForm = new FormGroup({ firstName: new FormControl(&apos;&apos;), lastName: new FormControl(&apos;&apos;), address: new FormGroup({ street: new FormControl(&apos;&apos;), city: new FormControl(&apos;&apos;), state: new FormControl(&apos;&apos;), zip: new FormControl(&apos;&apos;) }) }); 上面的等同于： profileForm = this.fb.group({ firstName: [&apos;&apos;], lastName: [&apos;&apos;], address: this.fb.group({ street: [&apos;&apos;], city: [&apos;&apos;], state: [&apos;&apos;], zip: [&apos;&apos;] }), }); FormGroup用this.fb.group替代，FormContrl用[&#39;&#39;]替代,怎么进行校验，我的天，又是好多字，今天就先这样吧！！！反正是我自己看的，我记得就行了！！！哈哈哈！！！","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular生命周期钩子","date":"2018-09-02T14:40:24.000Z","path":"2018/09/02/angular生命周期钩子/","text":"Angular中每个组件都有它的生命周期，从创建、渲染，到变更检测，再到最后的销毁过程过程，Angular一共提供了八个生命周期钩子，他们按照顺序分别是：constructor、ngOnChanges、ngOnInit、ngDoCheck、ngAfterContentInit、ngAfterContentChecked、ngAfterViewInit、ngAfterViewChecked、ngOnDestroy，其中有的钩子在生命周期内只调用一次，有的则可以反复调用（变更检测机制中需要调用方法）。如下图： 其中红色的表示只调一次，绿色的则可以被多次调用。我们将介绍其中重要的几个方法。 ngOnChanges:这个钩子在父组件初始化或修改子组件的输入属性时会被调用。想要理解这个方法为什么会被调用或不被调用，我们需要了解可变对象和不可变对象，在js中，字符串是不可变对象，但一个对象是一个可变对象，至于为什么，请自行百度。最后的结论是：当输入属性是变对象例如对象时，对象的属性发生变化并不会触发ngOnChanges方法；当输入属性是不可变对象例如字符串时，字符串改变会触发ngOnChanges方法。还需要注意一点就是：ngOnChanges方法首次调用一定是发生在ngOninit方法之前的。 ngDoCheck:变更检测可以说是Angular中最复杂的模块： angular有两种变更检测机制，一种是Default策略，一种是OnPush策略。Default策略会在组件发生变化时去检查组件树中所有组件，而使用OnPush的组件只会在其输入属性发生变化时去检查它。当我们对性能要求比较高的时候，例如有大量的表格数据在时时发生变化时，这两种策略的正确选择就显得尤为重要。在ngOnChanges中我们知道 当输入属性是可变对象例如对象时，对象的属性发生变化并不会触发ngOnChanges方法。 那么怎么检测对象的属性呢，这时就需要用到ngDoCheck方法了。check的调用十分频繁，发生一点点动静都会调用check方法，就比如我们的鼠标光标切换input但是没有改变值框这类的动作，组件树上所有的有check关键字钩子都会调用，所以，我们的所有check方法一定要小心，一定要高效，一定要轻量级。 ngAfterViewInit &amp; ngAfterViewChecked:顾名思义，这两个方法都是跟组件的视图密切相关的，前者是在视图都组建完毕之后才调用，后者是在视图发生变化时调用，值得注意的是： 这两个方法都是在视图组建完毕之后被调用的； 如果父组件存在子组件，那么父组件的这两个方法会在所有子组件的视图都组建完毕后调用； 不要早在这两个方法里面去改变视图中绑定的东西，这样做会报错。如果真的需要修改，需要写在一个timeout方法里面。 ngAfterContentInit &amp; ngAfterContentChecked:要使用这两个方法，就得再说到一个ng-content投影，什么是内容投影呢？就是从组件外部导入HTML内容，并把它插在组件中指定位置上的一种途径，举个例子，我们在子组件模板中这样定义一个投影点： &lt;ng-content&gt;&lt;/ng-content&gt; 这样我们在父组件中可以定义： &lt;app-child&gt; //这里面可以写想投影到子组件的内容 &lt;/app-child&gt; 这样我们就将父组件中的内容投影到了子组件中。不仅如此，我们还能同时投影多个内容，在父组件中这样定义： &lt;app-child&gt; //这里面可以写想投影到子组件的内容 &lt;div class=&apos;header&apos;&gt;{{title}}&lt;/div&gt; &lt;div class=&apos;footer&apos;&gt;{{content}}&lt;/div&gt; &lt;/app-child&gt; 然后再子组件中可以这样接收： &lt;ng-content select=&apos;.header&apos;&gt;&lt;/ng-content&gt; &lt;ng-content select=&apos;.footer&apos;&gt;&lt;/ng-content&gt; 这样我们不仅将两个HTML片段投影到子组件中，还将父组件控制器中的title、content通过插值表达式投影到了子组件中。ngAfterContentInit和ngAfterViewInit不同的是：ngAfterViewInit不能够改变视图中绑定的值，而在ngAfterContentInit中是可以的，不会报错。因为在ngAfterContentInit的时候，视图还没有组装完毕，只是投影进来的内容被组装完毕了。 ngOnDestroy组件什么时候被销毁呢，就是路由到别处的时候，当前组件会被销毁，创建新的路由的组件。在这一般是用来释放那些不会被垃圾收集器自动回收的各类资源的地方。取消那些对可观察对象和 DOM 事件的订阅。停止定时器。注销该指令曾注册到全局服务或应用级服务中的各种回调函数。如果不这么做，就会有导致内存泄露的风险。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular中组件之间如何通信(二)","date":"2018-09-01T11:19:43.000Z","path":"2018/09/01/angular中组件之间如何通信（二）/","text":"接着上一篇的内容，上一篇最后说到有公共父组件的组件之间是如何通信的，最后还有一个问题没有解决。但是在这之前我需要补充一下，父组件和子组件之间的通信还有一种方式，那就是通过本地变量或者使用@ViewChiad来进行传递，举个例子： export class childComponent { private sayHello() { console.log(&apos;Hello&apos;); } } 我在子组件中定义这样一个方法，我怎么在父组件中调用呢，一个是通过本地变量的方法： &lt;app-child #child1&gt;&lt;/app-child&gt; &lt;button (click)=&quot;child1.syaHello()&quot;&gt;sayHello&lt;/button&gt; 我在父组件的模板中使用子组件并加上#child1这个属性，然后就可以在父组件的模版中直接调用子组件的方法了。但是我们发现父组件的控制器并不能调用到这个方法，于是，我们就可以使用@ViewChiad： export class ParentComponent { @ViewChild(&apos;child1&apos;) private child: ChildComponent;//声明一个子组件 sayBay() { this.child.sayHello(); } } 这样我们就实现了在父组件的控制器中调用子组件的方法。 接下来我们就讨论一下最后一个问题：当组件之间没有公共的父组件时，它们应该如何通信呢？答案就是使用服务进行通信。。。loading","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular中组件之间如何通信","date":"2018-08-31T07:27:24.000Z","path":"2018/08/31/angular中组件之间如何通信/","text":"在angular中，我们会设计很多的component组件，也就生成了组件树，组件之间有可能是父子组件，或者兄弟组件，或者彼此都没有关系。那么这么多组件之间该如何通讯呢？下面我们就简答的了解了解。 父子组件之间的通讯父子之间的通讯比较简单，我们需要用到@Input输入属性和@Output输出属性。当我们需要从父组件向子组件传递信息时，我们首先需要为子组件定义一个属性： export class childComponent { @Input() hero: Hero; } 被@Input修饰的属性就即将接受从父组件传过来的信息。具体怎么传值呢？我们在父组件中通过子组件的属性进行传值： &lt;app-child [hero]=&quot;控制器中的属性值&quot;&gt;&lt;/app-child&gt; 我们在父组件的模板中调用子组件时，只要在子组件中对hero属性进行绑定就行了。是不是很简单？而从子组件向父组件传值也很简单，其实就是一个反向的过程，我们需要借助EventEmitter的订阅和广播的功能就可以了，首先我们在子组件中定义要传输出去的属性值： export class childComponent { @Output() voted = new EventEmitter&lt;boolean&gt;(); didVote = false; vote(agreed: boolean) { this.voted.emit(agreed); this.didVote = true; } } 我们将要输出的是通过EventEmitter进行实例化，然后在需要的时候触发.emit(agreed)事件就能将数据传出去。那接下来我们需要在父组件中进行接收： &lt;app-child (voted)=&quot;onVoted($event)&quot;&gt;&lt;/app-child&gt; 我们在父组件模板中的子组件上加上一个事件绑定，并且在父组件中定义onVoted()方法： export class ParentComponent { agreed = 0; disagreed = 0; onVoted(event: boolean) {//event就是传递过来的数据 agreed ? this.agreed++ : this.disagreed++; } 在父组件的方法中的参数就是我们从子组件中拿到的数据。这样就成功的传递出了信息。但是需要注意的是：默认情况下父组件模板中捕获事件的名字和子组件中输出属性的名字是一样的，都是voted！！！但是我们也可以通过输出属性来重命名： @Output(&apos;XXX&apos;)//这样就可以改掉输出属性的名字，同样的捕获事件的名字也要同步改过来。 中间人模式父子组件之间传递数据容易实现，但是当我们的组件不是父子关系的时候我们应该怎么传递数据？这就要用到我们的中间人模式了。 中间人模式最简单的一种关系就是两个组件有共同的父组件，也就是两个组件是兄弟关系。但是这个比喻不贴切，他们只是拥有共同的父组件，其实他们两之间谁都不认识谁。那么他们之间怎么通信呢？就把父组件当成中间人就行了： export class childOneComponent { @Output() voted = new EventEmitter&lt;boolean&gt;(); didVote = false; vote(agreed: boolean) { this.voted.emit(agreed); this.didVote = true; } } 首先还是一个组件中输出一个属性，并在适当的时触发广播的行为，将我们的数据发送出去。接着需要在父组件中监听voted这个事件： &lt;app-child-one (voted)=&quot;veteHandler($event)&quot;&gt;&lt;/app-child-one&gt; 我们的另一个子组件需要有个输入属性： export class childTwoComponent { @Input() voteCount; } 既然是我们的中间人，它就应该先接收它收到的数据，然后将数据再传给需要的人。这就很简单啦： export class ParentComponent { voteCount; veteHandler(event: boolean) {//event就是传递过来的数据 this.voteCount = event; } 我想你已经猜到下一步应该怎么办了，我们将父组件接受的数据传给另一个子组件就行了，怎么传？通过属性绑定来传递啊： &lt;app-child-one (voted)=&quot;veteHandler($event)&quot;&gt;&lt;/app-child-one&gt; &lt;app-child-two [voteCount]=&quot;voteCount&quot;&gt;&lt;/app-child-two&gt; 这样我这个中间人的职责就完成啦，成功将一个组件传递给另一个组件。而且他们两互相之间根本不知情。 那么没有共同的父组件的组件之间难道就不能通讯了吗？答案肯定是不是的，我将在下一篇博客中回答！","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular数据绑定","date":"2018-08-30T14:56:05.000Z","path":"2018/08/30/angular数据绑定/","text":"Angular数据绑定是Angular中最常见的，绑定的方式有单向数据绑定和双向数据绑定。单向的数据绑定通常有以下几种方式： 1.使用插值表达式将一个表达式的值显示在模板上： &lt;h1&gt;{{titke}}&lt;/h1&gt; 2.使用方括号将HTML标签的一个属性绑定到一个表达式上： &lt;img [src] = &quot;imgUrl&quot;&gt; 其实我们的属性绑定和我们的插值表达式是一样的，我们举个例子; &lt;img [src] = &quot;imgUrl&quot;&gt; &lt;img src = {{imgUrl}}&gt; 这两种写法其实都一样，插值的表达式都会被Angular转化成属性绑定。在这还有一个需要理解的东西就是HTML属性和DOM属性的区别，举个例子： &lt;input value=&quot;hello&quot; (click)=&quot;doOnInput($event)&quot;&gt; 我们的控制器定义一下我们的输入事件： doOnInput(event: any) { console.log(event.target.value);//打印DOM属性的值 console.log(event.target.getAttribute(&apos;value&apos;);//打印HTML属性的值 } 我们可以发现DOM属性的值是随着你改变输入的值而一直在改变的，而HTML属性的值一直是hello，因为HTML是初始化DOM属性的值的，不能改变，而DOM属性的值可以改变。 HTML属性和DOM属性的关系如下： 少量HTML属性和DOM属性之间有1:1的映射，比如id。 有些HTML属性没有对应的DOM属性，如colspan。 有些DOM属性没有对应的HTML属性，如textContent。 就算名字相同，HTML属性和DOM属性也不是一样东西。 HTML属性的值指定了初始值；DOM属性的值表示当前值.DOM属性的值可以改变；HTML属性的值不能改变。 模板绑定是通过DOM属性和事件来工作的，而不是HTML属性。 以上是DOM属性的绑定，下面介绍下HTML属性的绑定简单的举个例子： &lt;td [attr.colspan]={{1+1}}&gt; 因为colspan是个DOM属性没有的HTML属性，所以我们在前面加上attr这个前缀来表示它是HTML属性。 更多的我们可以通过[ngClass]或者[class.classname]、[class]这种来控制部分或者全部的类名，以此来达到控制样式的效果。ngclass的表达式需要接收一个对象，对象中通过{cssClassName: Boolen}这种键值对来表示该类是否要加上，true表示加上，false代表移除，这就是CSS类绑定。 类似的，我们还可以通过css样式绑定，不过不再是class开头了，而是style开头，举个栗子： &lt;div [style.color]=&quot; isDev? &apos;red&apos;: &apos;blue&apos;&quot;&gt; 其中的isDev就是控制器来控制的。和上面css类绑定一样，这只是单一样式的绑定，所以我们还有个[ngStyle]来批量控制，它也是接受一个对象，但和css类不同的是，这个对象里面定义的是样式的键值对，例如{color: red,background: black} 3.上面这两个绑定方式都是控制器向模板传输数据，下面这种是模板向控制器传输数据，也就是事件绑定： &lt;button (click)=&quot;onClickEvent($event)&quot;&gt;点击执行&lt;/button&gt; //小括号表示这是一个事件绑定 //小括号中的是事件的名称 //等号后面双引号中的是事件发生时执行的表达式 //如果处理事件的方法需要了解事件的属性，我们就可以给方法加上$event参数 我们的事件绑定中也可以不是一个方法调用，而是一个属性赋值： &lt;button (click)=&quot;saved = true&quot;&gt; 这样我们就能够直接给控制器中的saved属性赋值为true。 接下来我们看一下最重要的双向数据绑定 盒子里面装香蕉 这句话是官网文档上面说的，就是指[(ngModel)]是方括号包着小括号，其实从上面就能看出，控制器传值给模板是方括号，模板传值给控制器是小括号，两个融合到一起就是双向数据绑定了，举个栗子： &lt;input [value]=&quot;currentHero.name&quot; (input)=&quot;currentHero.name=$event.target.value&quot; &gt; 下面这个而其实就是一个双向数据绑定，但是显得太过笨重，于是有了下面这种写法： &lt;input [(ngModel)]=&quot;currentHero.name&quot;&gt; 这样就能够同步输入和显示了，最常用的地方就是我们的表单元素了。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular中如何引入第三方库","date":"2018-08-29T15:06:42.000Z","path":"2018/08/29/angular中如何引入第三方库/","text":"当我们想要在angular项目中引入第三方的库的时候我们应该怎么操作？就拿jquery来说吧： 第一步我们需要在项目目录下安装自己所需要的包： npm install --save jquery --save和--save-dev的区别就不多描述了，安装完成之后我们就可以在项目下的node_modules下面看到它了。 第二步我们需要把我们下载好的包加入到angular的配置文件中，在6.x之前，这个配置文件的名称是.angular-cli.json，但是在6.x之后就不是这个名字了，而是换成了angular.json，打开这个文件我们就能看到一系列的配置信息。我们需要将自己下载的包的路径引用到styles和scripts数组下面： 在这里填入正确的路径就可以了。这样jquery或者你需要的第三方包就被加入到angular项目中了。 但是我们现在还是不能直接使用jquery，因为angular是使用typescript开发的，而jquery的本质是javascript，Typescript是不能直接使用的。我们还需要安装类型描述文件让Typescript认识jquery。 第三步我们通过命令来安装jquery的类型描述文件： npm install @types/jquery(这个名字是你需要安装的包的名字) --save-dev 这样我们就能够使用jquery的命令了。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"rem的正确使用姿势","date":"2018-08-27T14:14:03.000Z","path":"2018/08/27/rem的正确使用姿势/","text":"最近用的比较多的就是rem了，所以写一篇rem的文章来记录下使用rem来制作移动端的页面的关键之处。 首先简单的阐述下px、em、rem三者之间的关系： px：像素是相对于显示器屏幕分辨率而言的相对长度单位。pc端使用px倒也无所谓，可是在移动端，因为手机分辨率种类颇多，不可能一个个去适配，这时px就显得非常无力，所以就要考虑em和rem。 em：继承父级的，假设html的font-size默认为16px，body字体大小定义为50%，那么在body里字体大小就是1em=8px了。可当你又定义了一个div，然后把字体设置成了50%，请问，现在div下的1em等于多少？因为继承了父级的值，现在这个div里的1em=4px，这么嵌套下去的话，抱歉，我数学不好！所以rem就出现了。 rem：是em的升级版，rem只会相对html的值，不会受到父级的影响，这样的好处在于：从em里的例子来讲，1rem始终会等于8px。使用的时候不需要重新计算rem此时的大小。rem因为是css3增加的，所以ie8或以下请无视（始终想不明白，为什么国人至今对微软都放弃的ie这么恋恋不舍）。 使用方法：首先在css中先全局声明font-size=625%,这里为什么用625%呢？因为100%=16px,1px=6.25%,所以100px=625%，1rem=100px。这样在后面使用的时候就方便很多。需要注意的是，rem是相对于根元素html的font-size，也就是说只需要设置根元素html的百分比就行了： html{font-size: 625%;} 还可以动态的来设置rem，例如使用媒体查询： @media screen and (min-width: 320px) { html {font-size: 14px;} } @media screen and (min-width: 360px) { html {font-size: 16px;} } @media screen and (min-width: 400px) { html {font-size: 18px;} } @media screen and (min-width: 440px) { html {font-size: 20px;} } @media screen and (min-width: 480px) { html {font-size: 22px;} } @media screen and (min-width: 640px) { html {font-size: 28px;} } 或者利用js计算当前设备来设置： (function (doc, win) { var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function () { var clientWidth = docEl.clientWidth; if (!clientWidth) return; if(clientWidth&gt;=640){ docEl.style.fontSize = &apos;100px&apos;; }else{ //这里的640是根据设计图实际大小来的 docEl.style.fontSize = 100 * (clientWidth / 640) + &apos;px&apos;; } }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false); })(document, window); 后来看到一个关于手淘的文章，有了下面这种最佳的方法，通过js计算当前设备的DPR，动态设置在html标签上，并动态的设置html的font-size，利用css选择器根据DPR来设置不同DPR下的字体的大小： function(win, lib) { var timer, doc = win.document, docElem = doc.documentElement, vpMeta = doc.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;), flexMeta = doc.querySelector(&apos;meta[name=&quot;flexible&quot;]&apos;), dpr = 0, scale = 0, flexible = lib.flexible || (lib.flexible = {}); // 设置了 viewport meta if (vpMeta) { console.warn(&quot;将根据已有的meta标签来设置缩放比例&quot;); var initial = vpMeta.getAttribute(&quot;content&quot;).match(/initial\\-scale=([\\d\\.]+)/); if (initial) { scale = parseFloat(initial[1]); // 已设置的 initialScale dpr = parseInt(1 / scale); // 设备像素比 devicePixelRatio } // 设置了 flexible Meta }else if (flexMeta) { var flexMetaContent = flexMeta.getAttribute(&quot;content&quot;); if (flexMetaContent) { var initial = flexMetaContent.match(/initial\\-dpr=([\\d\\.]+)/), maximum = flexMetaContent.match(/maximum\\-dpr=([\\d\\.]+)/); if (initial) { dpr = parseFloat(initial[1]); scale = parseFloat((1 / dpr).toFixed(2)); } if (maximum) { dpr = parseFloat(maximum[1]); scale = parseFloat((1 / dpr).toFixed(2)); } } } // viewport 或 flexible // meta 均未设置 if (!dpr &amp;&amp; !scale) { // QST // 这里的 第一句有什么用 ? // 和 Android 有毛关系 ? var u = (win.navigator.appVersion.match(/android/gi), win.navigator.appVersion.match(/iphone/gi)), _dpr = win.devicePixelRatio; // 所以这里似乎是将所有 Android 设备都设置为 1 了 dpr = u ? ( (_dpr &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) ? 3 : (_dpr &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) ? 2 : 1 ) : 1; scale = 1 / dpr; } docElem.setAttribute(&quot;data-dpr&quot;, dpr); // 插入 viewport meta if (!vpMeta) { vpMeta = doc.createElement(&quot;meta&quot;); vpMeta.setAttribute(&quot;name&quot;, &quot;viewport&quot;); vpMeta.setAttribute(&quot;content&quot;, &quot;initial-scale=&quot; + scale + &quot;, maximum-scale=&quot; + scale + &quot;, minimum-scale=&quot; + scale + &quot;, user-scalable=no&quot;); if (docElem.firstElementChild) { docElem.firstElementChild.appendChild(vpMeta) } else { var div = doc.createElement(&quot;div&quot;); div.appendChild(vpMeta); doc.write(div.innerHTML); } } function setFontSize() { var winWidth = docElem.getBoundingClientRect().width; if (winWidth / dpr &gt; 540) { (winWidth = 540 * dpr); } // 根节点 fontSize 根据宽度决定 var baseSize = winWidth / 10; docElem.style.fontSize = baseSize + &quot;px&quot;; flexible.rem = win.rem = baseSize; } // 调整窗口时重置 win.addEventListener(&quot;resize&quot;, function() { clearTimeout(timer); timer = setTimeout(setFontSize, 300); }, false); // 这一段是我自己加的 // orientationchange 时也需要重算下吧 win.addEventListener(&quot;orientationchange&quot;, function() { clearTimeout(timer); timer = setTimeout(setFontSize, 300); }, false); // pageshow // keyword: 倒退 缓存相关 win.addEventListener(&quot;pageshow&quot;, function(e) { if (e.persisted) { clearTimeout(timer); timer = setTimeout(setFontSize, 300); } }, false); // 设置基准字体 if (&quot;complete&quot; === doc.readyState) { doc.body.style.fontSize = 12 * dpr + &quot;px&quot;; } else { doc.addEventListener(&quot;DOMContentLoaded&quot;, function() { doc.body.style.fontSize = 12 * dpr + &quot;px&quot;; }, false); } setFontSize(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = setFontSize; flexible.rem2px = function(d) { var c = parseFloat(d) * this.rem; if (&quot;string&quot; == typeof d &amp;&amp; d.match(/rem$/)) { c += &quot;px&quot;; } return c; }; flexible.px2rem = function(d) { var c = parseFloat(d) / this.rem; if (&quot;string&quot; == typeof d &amp;&amp; d.match(/px$/)) { c += &quot;rem&quot;; } return c; } }(window, window.lib || (window.lib = {}));","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://tanyibing.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://tanyibing.com/tags/CSS/"}]},{"title":"全屏遮罩播放视频","date":"2018-08-23T08:48:28.000Z","path":"2018/08/23/全屏遮罩播放视频/","text":"接着上一篇的内容，现在我播放视频不希望跳转到一个新的视频播放页面这么麻烦了，我想要通过点击直接在本页面进行播放。最后决定的是在全屏加上一个遮罩，视频控制住在屏幕的正中央进行播放。直接上我的代码吧： &lt;div class=&quot;box-mask&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;input class=&quot;btnCancel&quot; type=&quot;button&quot; value=&quot;关闭&quot;&gt; &lt;script src=&apos;//player.polyv.net/script/polyvplayer.min.js&apos;&gt;&lt;/script&gt; &lt;div id=&apos;&apos; class=&quot;demo&quot;&gt;&lt;/div&gt; &lt;script&gt; let videoDiv = $(&apos;.box div&apos;); $(&quot;.btnDel&quot;).click(function() { let vid = $(this).attr(&apos;id&apos;); console.log(vid); let plv = &apos;plv_&apos; + vid; let plvObj = &apos;#&apos; + plv; $(videoDiv).attr(&apos;id&apos;, plv); let plvConfig = { &apos;width&apos;:&apos;100%&apos;, &apos;height&apos;:&apos;100%&apos;, &apos;vid&apos; : vid } let player = polyvObject(plvObj).videoPlayer(plvConfig); }); &lt;/script&gt; &lt;/div&gt; 这是我的遮罩和视频播放模块的DOM结构，其中.btnDel就是我们点击进入遮罩的入口。紧接着我放出我的css样式： .box-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; opacity: 0.7; filter: alpha(opacity=50); z-index: 99; display: none; } .box { position: absolute; width: 1000px; height: 620px; line-height:620px; text-align: center; z-index: 101; display: none; } .demo{ width:100%; height:100%; margin:0 auto; } .btnCancel { float: right; width: 50px; height: 30px; } 紧接着我要实现通过点击来实现遮罩的开启和关闭，并且要考虑下鼠标滚轮的滚动和浏览器窗口的大小改变这些情况： $(document).ready(function() { var isOpen = 0; //全局变量，判断是否已经打开弹出框 $(&quot;.btnDel&quot;).click(function() { //$(&quot;.box-mask&quot;).css({&quot;display&quot;:&quot;block&quot;}); $(&quot;.box-mask&quot;).fadeIn(500); center($(&quot;.box&quot;)); //载入弹出窗口上的按钮事件 checkEvent($(this).parent(), $(&quot;.btnSure&quot;), $(&quot;.btnCancel&quot;)); }); function center(obj) { //obj这个参数是弹出框的整个对象 var screenWidth = $(window).width(), screenHeigth = $(window).height(); //获取屏幕宽高 var scollTop = $(document).scrollTop(); //当前窗口距离页面顶部的距离 var objLeft = (screenWidth - obj.width()) / 2; ///弹出框距离左侧距离 var objTop = (screenHeigth - obj.height()) / 2 + scollTop; ///弹出框距离顶部的距离 obj.css({ left:objLeft + &quot;px&quot;, top:objTop + &quot;px&quot; }); obj.fadeIn(500); //弹出框淡入 isOpen = 1; //弹出框打开后这个变量置1 说明弹出框是打开装填 //当窗口大小发生改变时 $(window).resize(function() { //只有isOpen状态下才执行 if (isOpen == 1) { //重新获取数据 screenWidth = $(window).width(); screenHeigth = $(window).height(); var scollTop = $(document).scrollTop(); objLeft = (screenWidth - obj.width()) / 2; var objTop = (screenHeigth - obj.height()) / 2 + scollTop; obj.css({ left:objLeft + &quot;px&quot;, top:objTop + &quot;px&quot; }); obj.fadeIn(500); } }); //当滚动条发生改变的时候 $(window).scroll(function() { if (isOpen == 1) { //重新获取数据 screenWidth = $(window).width(); screenHeigth = $(window).height(); var scollTop = $(document).scrollTop(); objLeft = (screenWidth - obj.width()) / 2; var objTop = (screenHeigth - obj.height()) / 2 + scollTop; obj.css({ left:objLeft + &quot;px&quot;, top:objTop + &quot;px&quot; }); obj.fadeIn(500); } }); } //导入两个按钮事件 obj整个页面的内容对象，obj1为确认按钮，obj2为取消按钮 function checkEvent(obj, obj1, obj2) { //确认后删除页面所有东西 obj1.click(function() { //移除所有父标签内容 obj.remove(); //调用closed关闭弹出框 closed($(&quot;.box-mask&quot;), $(&quot;.box&quot;)); }); //取消按钮事件 obj2.click(function() { //调用closed关闭弹出框 closed($(&quot;.box-mask&quot;), $(&quot;.box&quot;)); }); } //关闭弹出窗口事件 function closed(obj1, obj2) { obj1.fadeOut(500); obj2.fadeOut(500); isOpen = 0; } }); 至于视频内容的切换，和上一篇差不多，也可以去我的github上看实例https://github.com/TanYiBing/zenith.","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://tanyibing.com/tags/CSS/"},{"name":"HTTP","slug":"HTTP","permalink":"http://tanyibing.com/tags/HTTP/"}]},{"title":"静态页面之间传值","date":"2018-08-22T14:40:46.000Z","path":"2018/08/22/静态页面之间传值/","text":"今天在工作中需要实现视频的播放功能，我需要从视频的聚合页通过点击来跳转到视频播放页面来进行播放。因为视频是托管在POLYV平台上的，视频以.swf的格式保存的话就不能直接使用video标签，而是需要使用特定的方法来实现视频的播放功能，我最后选择的是视频平台上的多终端样式，具体代码如下： &lt;script src=&apos;//player.polyv.netscriptpolyvplayer.min.js&apos;&gt;&lt;/script&gt; &lt;div id=&apos;plv_228d7015db12fcd9a62b5abc1f76540f_2&apos;&gt;&lt;/div&gt; &lt;script&gt; var player = polyvObject(&apos;#plv_228d7015db12fcd9a62b5abc1f76540f_2&apos;).videoPlayer({ &apos;width&apos;:&apos;600&apos;, &apos;height&apos;:&apos;338&apos;, &apos;vid&apos; : &apos;228d7015db12fcd9a62b5abc1f76540f_2&apos; }); &lt;/script&gt; 我的视频聚合页中的一个例子是: &lt;a href=&quot;&quot; class=&quot;vedioCard&quot;&gt; &lt;img src=&quot;xxx.jpg&quot; class=&quot;ved&quot;&gt; &lt;div class=&quot;deti&quot;&gt;江苏的启东&lt;/div&gt; &lt;/a&gt; 紧接着我在a标签里面加上传递参数的url： &lt;a href=&quot;./video.html?vid=228d7015db9fd7dbd831b586d395e7fb_2&quot; class=&quot;vedioCard&quot;&gt; &lt;img src=&quot;xxx.jpg&quot; class=&quot;ved&quot;&gt; &lt;div class=&quot;deti&quot;&gt;江苏的启东&lt;/div&gt; &lt;/a&gt; vid就是我在播放页面想要获取的参数，因为视频的播放需要这个参数。接下来我需要在播放页面使用$.query.get（param）方法来获取我想要的东西，这看上去就是和jquery有关，没错！这是jquery的一个插件，插件的代码我也拿过来使用： new function(settings) { var $separator = settings.separator || &apos;&amp;&apos;; var $spaces = settings.spaces === false ? false : true; var $suffix = settings.suffix === false ? &apos;&apos; : &apos;[]&apos;; var $prefix = settings.prefix === false ? false : true; var $hash = $prefix ? settings.hash === true ? &quot;#&quot; : &quot;?&quot; : &quot;&quot;; var $numbers = settings.numbers === false ? false : true; jQuery.query = new function() { var is = function(o, t) { return o != undefined &amp;&amp; o !== null &amp;&amp; (!!t ? o.constructor == t : true); }; var parse = function(path) { var m, rx = /\\[([^[]*)\\]/g, match = /^([^[]+)(\\[.*\\])?$/.exec(path), base = match[1], tokens = []; while (m = rx.exec(match[2])) tokens.push(m[1]); return [base, tokens]; }; var set = function(target, tokens, value) { var o, token = tokens.shift(); if (typeof target != &apos;object&apos;) target = null; if (token === &quot;&quot;) { if (!target) target = []; if (is(target, Array)) { target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value)); } else if (is(target, Object)) { var i = 0; while (target[i++] != null); target[--i] = tokens.length == 0 ? value : set(target[i], tokens.slice(0), value); } else { target = []; target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value)); } } else if (token &amp;&amp; token.match(/^\\s*[0-9]+\\s*$/)) { var index = parseInt(token, 10); if (!target) target = []; target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value); } else if (token) { var index = token.replace(/^\\s*|\\s*$/g, &quot;&quot;); if (!target) target = {}; if (is(target, Array)) { var temp = {}; for (var i = 0; i &lt; target.length; ++i) { temp[i] = target[i]; } target = temp; } target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value); } else { return value; } return target; }; var queryObject = function(a) { var self = this; self.keys = {}; if (a.queryObject) { jQuery.each(a.get(), function(key, val) { self.SET(key, val); }); } else { jQuery.each(arguments, function() { var q = &quot;&quot; + this; q = q.replace(/^[?#]/,&apos;&apos;); q = q.replace(/[;&amp;]$/,&apos;&apos;); if ($spaces) q = q.replace(/[+]/g,&apos; &apos;); jQuery.each(q.split(/[&amp;;]/), function(){ var key = decodeURIComponent(this.split(&apos;=&apos;)[0] || &quot;&quot;); var val = decodeURIComponent(this.split(&apos;=&apos;)[1] || &quot;&quot;); if (!key) return; if ($numbers) { if (/^[+-]?[0-9]+\\.[0-9]*$/.test(val)) val = parseFloat(val); else if (/^[+-]?[0-9]+$/.test(val)) val = parseInt(val, 10); } val = (!val &amp;&amp; val !== 0) ? true : val; if (val !== false &amp;&amp; val !== true &amp;&amp; typeof val != &apos;number&apos;) val = val; self.SET(key, val); }); }); } return self; }; queryObject.prototype = { queryObject: true, has: function(key, type) { var value = this.get(key); return is(value, type); }, GET: function(key) { if (!is(key)) return this.keys; var parsed = parse(key), base = parsed[0], tokens = parsed[1]; var target = this.keys[base]; while (target != null &amp;&amp; tokens.length != 0) { target = target[tokens.shift()]; } return typeof target == &apos;number&apos; ? target : target || &quot;&quot;; }, get: function(key) { var target = this.GET(key); if (is(target, Object)) return jQuery.extend(true, {}, target); else if (is(target, Array)) return target.slice(0); return target; }, SET: function(key, val) { var value = !is(val) ? null : val; var parsed = parse(key), base = parsed[0], tokens = parsed[1]; var target = this.keys[base]; this.keys[base] = set(target, tokens.slice(0), value); return this; }, set: function(key, val) { return this.copy().SET(key, val); }, REMOVE: function(key) { return this.SET(key, null).COMPACT(); }, remove: function(key) { return this.copy().REMOVE(key); }, EMPTY: function() { var self = this; jQuery.each(self.keys, function(key, value) { delete self.keys[key]; }); return self; }, load: function(url) { var hash = url.replace(/^.*?[#](.+?)(?:\\?.+)?$/, &quot;$1&quot;); var search = url.replace(/^.*?[?](.+?)(?:#.+)?$/, &quot;$1&quot;); return new queryObject(url.length == search.length ? &apos;&apos; : search, url.length == hash.length ? &apos;&apos; : hash); }, empty: function() { return this.copy().EMPTY(); }, copy: function() { return new queryObject(this); }, COMPACT: function() { function build(orig) { var obj = typeof orig == &quot;object&quot; ? is(orig, Array) ? [] : {} : orig; if (typeof orig == &apos;object&apos;) { function add(o, key, value) { if (is(o, Array)) o.push(value); else o[key] = value; } jQuery.each(orig, function(key, value) { if (!is(value)) return true; add(obj, key, build(value)); }); } return obj; } this.keys = build(this.keys); return this; }, compact: function() { return this.copy().COMPACT(); }, toString: function() { var i = 0, queryString = [], chunks = [], self = this; var encode = function(str) { str = str + &quot;&quot;; if ($spaces) str = str.replace(/ /g, &quot;+&quot;); return encodeURIComponent(str); }; var addFields = function(arr, key, value) { if (!is(value) || value === false) return; var o = [encode(key)]; if (value !== true) { o.push(&quot;=&quot;); o.push(encode(value)); } arr.push(o.join(&quot;&quot;)); }; var build = function(obj, base) { var newKey = function(key) { return !base || base == &quot;&quot; ? [key].join(&quot;&quot;) : [base, &quot;[&quot;, key, &quot;]&quot;].join(&quot;&quot;); }; jQuery.each(obj, function(key, value) { if (typeof value == &apos;object&apos;) build(value, newKey(key)); else addFields(chunks, newKey(key), value); }); }; build(this.keys); if (chunks.length &gt; 0) queryString.push($hash); queryString.push(chunks.join($separator)); return queryString.join(&quot;&quot;); } }; return new queryObject(location.search, location.hash); }; }(jQuery.query || {}); 在有了这个插件之后我们就可以很轻松地拿到url中的参数了： let vid = $.query.get(&apos;vid&apos;); 拿到参数之后只要像对待普通DOM元素一样对上面视频播放的那个div进行属性的修改，就可以播放不同的视频了。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://tanyibing.com/tags/HTTP/"},{"name":"URL","slug":"URL","permalink":"http://tanyibing.com/tags/URL/"}]},{"title":"Angular6在使用antd的layout之后没有css样式","date":"2018-08-21T17:37:10.000Z","path":"2018/08/22/Angular6在使用antd的layout之后没有css样式/","text":"今天我在使用Angular6安装完antd之后，使用了layout模块，打开之后发现没有样式，最后解决方案如下： 首先我们看看antd的官网： https://ng.ant.design/docs/getting-started/zh 当我们开始使用之前，我们需要引入css全局样式，但是引入的位置不正确就会导致我们的模块没有样式。 解决方案是在全局样式文件style.css的开头引入antd的css @importnode_modules/ng-zorro-antd/src/ng-zorro-antd.min.css 如下图：","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"JS原型理解","date":"2018-08-08T15:40:45.000Z","path":"2018/08/08/JS原型、原型链/","text":"JS原型和原型链js原型js原型和原型链一直是js中一个难点，也是面试时大概率的问题，看了网上很多的说法，好像都不是那么通俗易懂。我就用简单的方式来介绍介绍，本人是前端菜鸟，说错了欢迎大家提出来。 我理解中的原型是为了继承而产生的，为了防止污染全局变量，我们可以给Person的原型加上一个sayHello方法，这也是最简单的例子（自行脑补代码），这样我们就可以在Person的实例中共享sayHello这个方法。图中的每条线其实都可以用一个属性代替，我画出来你们就一目了然了。 我们可以看到，Person构造函数可以通过prototype属性访问它自己的原型对象的，而实例化出来的对象可以通过_proto_属性访问Peroson构造函数的原型对象._proto_属性其实是非标准的属性，也就是说这是浏览器为了方便才产生的属性，为了什么方便？当然是为了调试的方便啦，所以我们还是尽量不要在代码中使用_proto_，而在调试的时候使用。 js原型链上面给的是一个简单的原型模型，我们知道，原型对象还有一个属性constructor，这个属性就是指向该对象的构造函数的。下面我们需要了解几个概念，以便我们清楚的知道原型链是什么：1.每个构造函数都有原型对象2.每个对象都会有构造函数3.每个构造函数的原型都是一个对象4.那么这个原型对象也会有构造函数5.那么这个原型对象的构造函数也会有原型对象这样就形成一个链式结构，也就是我们说的原型链 从图中我们就可以清楚的看到一个原型链结构，我们的原型其实也是个对象，对象也是由对象构造函数生成的，其实也就是之前的原型三角结构的延伸，可以看到，所有的对象的原型最顶层就是null。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"}]},{"title":"SEO自学笔记（五）","date":"2018-08-02T14:03:55.000Z","path":"2018/08/02/SEO自学笔记（五）/","text":"SEO自学笔记（五）今天主要的工作是优化公司官网的关键词，去外网发外链，虽然心中质疑如今外链对优化还有没有作用，但还是做了，也积累了一些国外的外链资源，有需要的小伙伴也可以私聊我，我的企鹅是820567197.言归正传，SEO抽空看了一些，只有一张笔记，发出来：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"SEO自学笔记（四）","date":"2018-08-01T13:53:59.000Z","path":"2018/08/01/SEO自学笔记（四）/","text":"SEO自学笔记（四）以下是今天的自学笔记：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"SEO自学笔记（三）","date":"2018-07-31T13:58:21.000Z","path":"2018/07/31/SEO自学笔记（三）/","text":"SEO自学笔记（三）自从github被微软收购之后，我用hexo来写博客就不是那么顺利了，就跟被墙一样，网站打开慢就不说了，昨晚一直hexo d命令报错，害得我把博客迁移了一遍，最后不知道怎么鬼使神差的上传好了。今天上传的时候又遇到了问题，搭了梯子才解决。在这吐槽一下，看到很多人已经把自己的项目都迁走了，感觉github的未来不是那么美好了。 言归正传，再上传一下我今天额外的SEO笔记：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"SEO自学笔记（二）","date":"2018-07-31T13:40:04.000Z","path":"2018/07/31/SEO自学笔记（二）/","text":"SEO自学笔记（二）紧接着第一天的内容，今天的学习笔记如下：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"SEO自学笔记（一）","date":"2018-07-30T14:28:13.000Z","path":"2018/07/30/SEO自学笔记（一）/","text":"SEO自学笔记（一）最近在工作中要求学习一些SEO的技术来给主站进行一定的优化，所以自学了SEO的一些知识，我通过xmind思维导图做了一些笔记，下面就贴出我学习的过程：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"PHP中Session的清除和销毁","date":"2018-03-26T09:48:30.000Z","path":"2018/03/26/PHP中Session的清除和销毁-1/","text":"PHP中session清除和销毁今天在工作中使用session进行用户的登录验证操作，最后要进行用户注销的操作，也就是session的删除，所以查阅文档发现删除会话主要有删除单个会话、删除所有会话和结束当前会话的三种方式，以下就是三种清除session的具体方法： 1.删除单个会话删除单个会话其实就是删单个会话的变量，和数组的操作一样，直接注销$_SESSION数组的某个元素即可。例如：$_SESSION[“session_name”]变量，可以使用unset()函数，代码如下所示：unset($_SESSION[&quot;session_name&quot;]);注意：在使用unset()时，要注意$SESSION数组中的元素一定不可以可略，即不可以一次注销整个数组，这样会禁止整个会话的功能，一旦使用会将全局变量$_SESSION全局变量销毁，而且没有办法将其恢复，用户也不可能再注册$_SESSION变量，在php文档中也可以发现警告 Caution请不要使用unset($、_SESSION)来释放整个$_SESSION， 因为它将会禁用通过全局$_SESSION去注册会话变量 2.删除所有会话如果想吧某个用户在session中注册的所有变量都删除，也就是一次删除所有的会话变量，可以通过将一个空数组赋值给$_SESSION来实现，其代码显示如下：$_SESSION = array();也可以使用session_unset 来释放所有的会话变量,使用方法如下：void session_unset ( void )该函数没有返回值。 3.删除当前会话如果整个会话已经结束，首先应该注销所有会话变量，然后使用 session_destroy()函数清除结束当前的会话，并清空会话中的所有资源，彻底销毁 Session，其代码如下显示：session_destroy()；相对于 session_start() 函数 （创建 Session 文件），session_destroy()函数用来关闭 Session 的运作 （删除 Session 文件），如果成功则返回 TURE，销毁 Session 资料失败则返回 FALSE。但该函数并不会释放和当前 Session 相关的变量，也不会删除保存在客户端 Cookie 中的 Session ID 。下面是我在代码中实际使用的方法： if(isset($_SESSION['username'])){ $_SESSION = array(); if(isset($_COOKIE[session_name()])){ setcookie(session_name(),'',time()-3600); } session_destroy(); }","tags":[{"name":"php","slug":"php","permalink":"http://tanyibing.com/tags/php/"},{"name":"session","slug":"session","permalink":"http://tanyibing.com/tags/session/"}]},{"title":"从输入URL到页面渲染完成","date":"2018-02-20T10:09:24.000Z","path":"2018/02/20/从输入URL到页面渲染完成/","text":"转载自www.chauncywu.com 从输入URL到页面渲染完成原文-英文译文 推荐阅读《图解HTTP》 各种协议与HTTP协议的关系(参照该图理解下文) 0-1 1. 输入URL地址 1-1 2. 浏览器根据域名查询IP地址 2-1 从要访问的域名中获取IP地址，DNS查询的步骤如下： 从浏览器缓存中查询。浏览器会存储一定时间的DNS记录，操作系统不会告诉浏览器每个DNS记录的保存时限，不同浏览器设置保存时限为一个固定值（不同浏览器情况不同，一般在2-30分钟）。 从操作系统缓存中查询。如果浏览器中没有包含想要的缓存记录，那浏览器就会发起操作系统请求，继续查询操作系统缓存 从路由器中查询DNS缓存。请求持续发送到你的路由，它通常会有自己的DNS缓存。 从ISP中查询DNS缓存。下一个被查询地方是ISP缓存DNS的服务器。 域名服务器递归查询。首先从root域名服务器中查询如.com域名服务器，然后逐步向前查询，.com顶级域名服务器到Facebook的域名服务器。一般来说，.com级别的都已经在缓存中了，所以一般不会进行对root域名服务器的查询。下面给出一张递归查询的图。扩展什么是DNS？DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 DNS查询的两种方式：递归查询和迭代查询1、递归解析当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。 2-2 2、迭代解析当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。 2-3 DNS域名称空间的组织方式我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例: 2-4 3. 浏览器发送HTTP请求到web服务器向 http://facebook.com/ 发出GET请求 HTTP请求报文在请求中，HTTP报文首部由方法、URI、HTTP版本、HTTP首部字段等构成。 3-1 确保可靠性的TCP协议 3-2 扩展TCP三次握手 第一次握手： 客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认； 第二次握手： 服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。 第三次握手： 客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。 3-2-1 为什需要三次握手？《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。 假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。 例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。 TCP四次挥手 第一次挥手： Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手： Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手： Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手： Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 3-2-2 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 什么是反向代理？客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 3-2-3 负责传输的IP协议 IP间的通信依赖MAC地址 ARP协议：(Address Resolution Protocol)用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址 3-3 4. Facebook服务器返回一个永久重定向响应服务器会发送一个301永久重定向响应来告诉浏览器访问 http://www.facebook.com/ 而不是 http://facebook.com/。 为什么服务器坚持重定向而不是直接给予浏览器用户需要的结果，这有很多有意思原因: 一个原因是搜索引擎排名，如果有两个URLs指向同一个页面，比如 http://www.igoro.com/ 和 http://igoro.com/ ,搜索引擎会认为这是两个不同的网站，结果他们两个每个都有一部分访问量，但是也只能拥有更低的搜索引擎排名。如果使用了301定位，搜索引擎将会识别重定向，进而将同一来源的多个链接算作一个。 另一个原因是，同样的内容多个URLs还不利于缓存，同样的内容拥有多个名字，潜在造成缓存浪费。 扩展301和302的区别：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO 302好于301 重定向原因： 网站调整（如改变网页目录结构）； 网页被移到一个新地址； 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 什么时候进行301或者302跳转呢？当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。 清晰明确而言：使用301跳转的大概场景如下： 1、 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。2、 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。3、 空间服务器不稳定，换空间的时候。 5. 浏览器会跟踪重定向地址浏览器知道了 http://www.facebook.com/ 是真正应该访问的URL，所以就发送了另外一个GET请求。 6. 服务器处理请求服务器会接收这个GET请求，并且返回一个响应结果 怎么存储数据是每个动态网站都会面临的有趣难题小网站会经常有一个SQL数据库来存储他们的数据，但是网站存储数据量过大或者流量过大后就必须将数据库分布在多台机器，解决的方法有很多种 包括sharding(在主键基础上划分表到多个数据库中)，复制和使用简化的弱语义一致性数据库 推迟一些任务到批处理作业是廉价保持数据更新的的一种技术。例如，Facebook必须尽快更新新闻供应，但数据支持的“你可能认识的人”功能可能只需要每晚进行更新（作者猜测是这样）。批处理作业的更新导致存在一些旧的相对不重要的数据，但是使数据更新更快更简单。 7.服务器返回一个HTML响应123456789101112HTTP/1.1 200 OKCache-Control: private, no-store, no-cache, must-revalidate, post-check=0, pre-check=0Expires: Sat, 01 Jan 2000 00:00:00 GMTP3P: CP=&quot;DSP LAW&quot;Pragma: no-cacheContent-Encoding: gzipContent-Type: text/html; charset=utf-8X-Cnection: closeTransfer-Encoding: chunkedDate: Fri, 12 Feb 2010 09:05:55 GMT... 整个完整的响应是36KB，其中大部分处理后由blob类型传送内容编码头部告诉浏览器响应体使用了gzip压缩算法。在解析blob后，你就会看到你期望的HTML了。 8. 浏览器开始渲染HTML在浏览器接收完整HTML文件前，浏览器就开始渲染页面了。 9. 浏览器发送嵌入在HTML中的对象的请求随着浏览器渲染HTML，浏览器会注意到有些标签需要请求其他URLs的资源，浏览器将会发送一个GET请求来重新获取每个文件 。 10. 浏览器发送异步请求在web2.0时代，即使在页面渲染后客户端还是持续与服务器端通信。 例如，当你的朋友上线或下线时，Facebook聊天功能将会持续更新你已经登录的朋友列表。为了更新这个列表，你浏览器上运行的JS将会发送异步请求到服务器，异步请求是发送给特殊URL的GET或POST请求。在Facebook的例子中，客户端会发送一个POST请求到 http://www.facebook.com/ajax/chat/buddy_list.php ，获取你在线的朋友列表 这个模式被称为AJAX，是“Asynchronous JavaScript And XML”,的缩写，虽然不太清楚为什么服务器必须将响应格式化为xml。 相关阅读：当你访问淘宝的时候，发生了什么？","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://tanyibing.com/tags/HTTP/"},{"name":"URL","slug":"URL","permalink":"http://tanyibing.com/tags/URL/"}]},{"title":"hadoop单机安装、运行","date":"2017-12-28T14:28:13.000Z","path":"2017/12/28/hadoop单机配置、运行/","text":"云计算 hadoop 配置步骤Tanyibing，this is for 14级软件工程专业，My email &#x74;&#x61;&#110;&#x79;&#105;&#98;&#x69;&#110;&#x67;&#49;&#x39;&#57;&#x35;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109; link Hadoop环境准备工作 VMware版本VMware-workstation-full-12.5.7-5813279(版本自己选择)Xshell5自己选择是否使用 CentOS版本CentOS-6.4-x86_64-bin-DVD1(本人的是64位，其他版本未测试) Hadoop版本hadoop-2.6.0(安装完系统后直接命令行安装) jdk版本jdk-8u45-linux-x64.tar 需要了解基本的linux和vim的使用 资源位置百度网盘:https://pan.baidu.com/s/1i5s2eFF密码:n3jq CentOS镜像下载地址http://mirror.nsc.liu.se/centos-store/6.4/isos/x86_64/ VMware安装以及CentOS安装VMware安装步骤省略CentOS安装1.点击新建虚拟机 2.选择稍后操作系统 3.选择64位CentOS的系统 4.选择安装位置(最好不要放C盘) 5.默认配置就好，点击下一步 6.点击自定义硬件 7.配置虚拟机的内存，我们的实验1G即可，电脑好的选择2G也可 8.选择虚拟化cpu(使用本机真实cpu) 9.选择加载的镜像，选1盘，如果自己下载的话2盘是一些软件，不需要加载 10.桥接和NAT模式才能上网，我选择的是桥接(使用自己的真实网卡) 11.选择第一个选项(安装或升级系统) 12.这一步选skip跳过即可 13.选择简体中文，点击下一步 14.选择英国美式，下一步 15.选择默认的基本存储设备，下一步 16.必须选择是，忽略所有数据 17.默认就行，下一步 18.自己输入密码（6位，字母数字），选择无论如何使用(因为我设置的密码不是安全的) 19.为了更好的了解linux，现在进行分盘(挂载点) 20.首先分给/home 2G(选择空闲点击创建，然后挂载点选/home) 21.必须给/boot一定的空间(系统使用，及时其他出现问题也能正常开机，一般200M即可) 22.接着给swap分4G空间(不是在挂载点选择，而是在文件系统类型选择) 23.最后所有空间都分给 / 挂载点(根目录) 24.选择将修改写入磁盘，点击下一步 25.默认即可，下一步 26.由于minimal存在一些兼容问题，选择Basic Server版本，点击下一步进行安装 27.安装完成，点击重新引导，重启虚拟机 28.先输入用户名：root 回车，接着输入密码(密码是不显示的，输入完回车就行) 29.现在一个虚拟机就终于安装完成了 jdk、hadoop的解压1.将jdk解压到 /opt 下 tar -zxvf jdk-8u45-linux-x64.tar.gz -C /opt 注意如果你的虚拟机自带openjdk需要先卸载 rpm -qa | grep java //检查机器上的jdk 应该显示这一类的结果： java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64 javapackages-tools-3.4.1-11.el7.noarch java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64 使用下面的命令删除上面列出的内容： rpm -e --nodeps + 上面出现的内容 2.将hadoop解压到 /opt/hadoop 下 tar -zxvf hadoop-2.6.0-x64.tar.gz -C /opt/hadoop 没有hadoop目录的自己在/opt下创建 在/root /hadoop/目录下，建立tmp、hdfs/name、hdfs/data目录，执行如下命令： mkdir /opt/hadoop/tmp mkdir /opt/hadoop/hdfs mkdir /opt/hadoop/hdfs/data mkdir /opt/hadoop/hdfs/name ##ssh的安装、无密码配置 1.检查 CentOS 默认已安装了 SSH client、SSH server，打开终端执行如下命令进行检验： rpm -qa | grep ssh 成功显示出client、server版本的话则无需安装，若需要安装，则可以通过 yum 进行安装（安装过程中会让你输入 [y/N]，输入 y 即可）： sudo yum install openssh-clients sudo yum install openssh-server 接着执行如下命令测试一下 SSH 是否可用： ssh localhost 此时会有提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码，就登陆到本机了。 2.ssh无密码配置 上面这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。 首先输入 exit 退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中： exit # 退出刚才的 ssh localhost cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 会有提示，都按回车就可以 cat id_rsa.pub &gt;&gt; authorized_keys # 加入授权 chmod 600 ./authorized_keys # 修改文件权限 此时再用 ssh localhost 命令，无需输入密码就可以直接登陆了。 jdk、hadoop的配置1.环境变量的配置 vim /etc/profile加入如下配置： export JAVA_HOME=/opt/jdk1.8.0_45 export HADOOP_HOME=/opt/hadoop/hadoop-2.6.0 exportCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar: exportPATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin: 保存后，不要忘记执行如下命令使配置生效： source /etc/profile 2.hosts文件的修改 vim /etc/hosts最后加入如下内容： 127.0.0.1 自己的主机名 3.hadoop配置 进入/opt/hadoop/hadoop-2.6.0/etc/hadoop目录 1)在hadoop-env.sh和 yarn-env.sh的开头添加如下环境变量(一定要添加) export JAVA_HOME=/opt/jdk1.8.0_45 2)配置core-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;description&gt;HDFS的URI，文件系统://namenode标识:端口号&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/tmp&lt;/value&gt; &lt;description&gt;namenode上本地的hadoop临时文件夹&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 3)配置hdfs-site.xml &lt;configuration&gt; &lt;!—hdfs-site.xml--&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/hdfs/name&lt;/value&gt; &lt;description&gt;namenode上存储hdfs名字空间元数据 &lt;/descriptio&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/hdfs/data&lt;/value&gt; &lt;description&gt;datanode上数据块的物理存储位置&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;description&gt;副本个数，配置默认是3,应小于datanode机器数量&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 4)配置yarn-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;${yarn.resourcemanager.hostname}:8099&lt;/value&gt; &lt;/propert&gt; &lt;/configuration&gt; #####4)配置mapred-site.xml 目录下没有mapred-site.xml，只有mapred-site.xml.template(模板)，所以将其复制重命名为mapred-site.xml: cp mapred-site.xml.template mapred-site.xml 然后再配置mapred-site.xml: &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 5)配置yarn-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;${yarn.resourcemanager.hostname}:8099&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 启动hadoop1.格式化namenode hadoop namenode -format 2.启动hadoop start-all.sh 3.启动验证 jps 应该输出如下的结果: 在浏览器输入虚拟机的ip地址，例如：192.168.31.0:50070，能够打开如下网页： 至此，hadoop环境安装已经全部完成 hadoop下运行MapReduce代码在此，使用WordCount的旧版api版本演示 1.编写WordCount.java,包含Mapper类和Reducec类 import java.io.IOException; import java.util.StringTokenizer; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.input.TextInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat; public class WordCount { public static class WordCountMap extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; { private final IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); StringTokenizer token = new StringTokenizer(line); while (token.hasMoreTokens()) { word.set(token.nextToken()); context.write(word, one); } } } public static class WordCountReduce extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; { public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { int sum = 0; for (IntWritable val : values) { sum += val.get(); } context.write(key, new IntWritable(sum)); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = new Job(conf); job.setJarByClass(WordCount.class); job.setJobName(&quot;wordcount&quot;); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); job.setMapperClass(WordCountMap.class); job.setReducerClass(WordCountReduce.class); job.setInputFormatClass(TextInputFormat.class); job.setOutputFormatClass(TextOutputFormat.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); job.waitForCompletion(true); } } 2.编译WordCount.java文件 javac WordCount.java -d 指定到你希望的目录下 此时目录下应该多出三个文件：WordCount.class、WordCount$WordCountMap.class、WordCount$WordCountReduce.class 3.将以上的.class文件打包成.Jar文件 jar -cvf 你希望指定的名字.jar *.class 4.创建hadoop的input和output目录 hadoop fs -mkdir input hadoop fs -mkdir output 5.将要输入的文件放进input目录下 hadoop fs -put 你要放入计算的文件 input 6.hadoop运行Jar文件并计算结果 hadoop jar WordCount.Jar WordCount input/file output (hadoop jar jar包路径 执行的主函数名(主类名，main方法所在类名) 输入目录名 输出目录名) 7.查看结果(前提是不报错，成功运行完) 成功的话，output目录下会出现一个part-r-xxxx hadoop fs cat output/part-r-00000 #查看提交的结果 附(xshell5、VMware tools使用安装)VMware Tools可以让虚拟机和你的主机之间共享一个文件夹,具体操作不在此赘述，点击链接自行按教程安装VMware Tools安装 Xshell可以方便开发,具体操作不在此赘述，点击链接自行按教程安装Xshell安装","tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://tanyibing.com/tags/hadoop/"},{"name":"java","slug":"java","permalink":"http://tanyibing.com/tags/java/"},{"name":"VMware","slug":"VMware","permalink":"http://tanyibing.com/tags/VMware/"},{"name":"Windows","slug":"Windows","permalink":"http://tanyibing.com/tags/Windows/"}]},{"title":"Hello World","date":"2017-12-25T02:28:13.000Z","path":"2017/12/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://tanyibing.com/tags/hexo/"}]}]