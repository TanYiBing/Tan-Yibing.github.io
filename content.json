[{"title":"【翻译】调试Rxjs（一）：工具","date":"2018-11-19T12:34:46.000Z","path":"2018/11/19/【翻译】调试Rxjs（一）：工具/","text":"[翻译] 调试Rxjs（一）：工具 原文：Debugging RxJS, Part 1: Tooling 我是一个 Rxjs 的信仰者，我在我所有的项目中都使用 Rxjs。有了 Rxjs，我发现很多曾经觉得乏味的事都变得痛快。但是有一件事不是这样：调试。 Rxjs 中异步的本质在组合之后让调试变得更具挑战性：没有太多的状态（state）供你检查，并且调用堆栈（call stack）也帮不了太大的忙。我过去使用的方法是在整个代码多处添加 do 操作符并且记录，以此来检查那些组合的 Observable 产生的值。这并不是我想要的方法，因为： 当我在调试时修改代码，我不得不进行更多的日志记录工作； 当调试结束之后，我必须删除日志记录或者注释掉它； 当在一个正常的组合Observable中存在‘拍扁’的操作时，如何进行日志记录需要格外的小心。 就算是专门有的 log 操作符，结果也不会很理想。 最近，我留了一些时间来为 Rxjs 构建一个调试工具，我觉得这个工具必须具备以下的功能： 应该尽可能的不显眼； 不需要通过修改代码来进行调试； 在调试结束后，不需要删除或注释掉调试的代码； 应该可以轻松的启用和禁用日志记录； 它应该提供与浏览器控制台的一些集成————用于打开/关闭调试用能和检查状态等。 如果想要更完美，还要一些东西： 它应该支持暂停 Observable； 它应该支持修改 Observable 或者它们发出的值； 它应该支持控制台意外的日志记录机制； 它应该是可扩展的; 它应该在某种程度上可以捕获可视化订阅依赖关系所需的数据。 考虑到这些功能，我建立了 rxjs-spy。 核心概念rxjs-spy 引入了 tag 操作符，将字符串标记与 Observable 相关联。这个操作符不会以任何方式更改 Observable 的行为或值。 tag 操作符可以被单独导入-import \"rxjs-spy/add/operator/tag\"```-并且其他的 `rxjs-spy` 方法可以在生产环境下省略，所以唯一的开销就是字符串注释。1234567891011121314151617181920212223242526272829303132大多数工具的方法接受匹配器，以确定它们将应用于哪些标记的 `Observable` 。匹配器可以是传递标签本身的简单字符串，正则表达式或谓词。通过调用 `spy` 来配置工具时，它会修改 `Observable.prototype.subscribe` 来监听所有的 `subscriptions`, `notifications ` 和 `unsubscriptions`。这也就是意味着，只有已经被订阅的 `Observable` 才会被监听。`rxjs-spy` 公开了一个旨在从代码中调用的模块API和一个用于在浏览器控制台中交互使用的控制台API。大多数时候，我早早地在应用程序启动代码里条用模块API的方法，并使用控制台API进行剩余的调试。## 控制台API功能在调试时，我通常使用浏览器的控制台来检查和操作标记的 `Observables`。控制台API功能最容易通过示例解释：```jsimport &#123; Observable &#125; from \"rxjs/Observable\";import &#123; spy &#125; from \"rxjs-spy\";import \"rxjs/add/observable/interval\";import \"rxjs/add/operator/map\";import \"rxjs/add/operator/mapTo\";import \"rxjs-spy/add/operator/tag\";spy();const interval = new Observable .interval(2000) .tag(\"interval\");const people = interval .map((value) =&gt; &#123; const names = [\"alice\", \"bob\"]; return names[value % names.length]; &#125;) .tag(\"people\") .subscribe(); rxjs-spy 中的控制台API通过 rxSpy 在全局暴露。 调用 rxSpy.show() 将显示所有已经被标记的 Observable 的列表，指示其状态（incomplete，complete 或者 errored），订阅者（subscribers）的数量和最近发出的值（如果已经发出一个值）。控制台输出将如下所示： Console_1 要显示特定标记的 Observable 的信息，可以将标记名称或者正则表达式传递给 show： Console_2 可以通过调用 rxSpy.log 来显示被标记的 Observable 的日志信息： Console_3 log 不带参数调用将会显示所有标记的 Observable 的日志记录。 模块API中的大多数方法都返回一个撤销功能，可以调用该功能来撤销方法调用。在控制台中，管理起来很繁琐，所以还有另一种选择。 调用 rxSpy.undo() 将显示已经调用的方法的列表： Console_4 调用 rxSpy.undo 并传递与方法调用关联的数字将看到该调用的撤销函数被执行。例如，调用 rxSpy.undo(3) 将看到被标记为 interval 的 Observable 的记录被撤销之后的结果： Console_5 有时，在调试时修改 Observable 或其值时，这个方法就很有用。控制台API包含一种 let 方法，其功能与 RxJS 中的 let 操作符大致相同。它的实现方式是通过调用 let 方法对标记的 Observable 的当前和未来的订阅者产生影响。例如。以下调用将看到 people Observable 发射 mallory 而不是 alice 或 bob: Console_6 与 log 方法一样，let 可以撤消对该方法的调用： Console_7 能够在调试时暂停一个 Observable 对我来说几乎是不可或缺的。调用 rxSpy.pause 将暂停一个标记的 Observable，并返回一个可用于控制和检查 Observable 的通知（notifications）的 deck： Console_8 在该 deck 上调用 log 将显示 Observable 是否暂停，并显示被暂停的通知（notifications）。（通知是 Notification 使用 materialize 操作符获得的rxjs实例） Console_9 在 deck 上调用 step 将发出一个被暂停住的通知（notifications）： Console_10 调用 resume 将发出所有被暂停的通知（notifications），并将恢复 Observable： Console_11 调用 pause 将看到 Observable 重新进入暂停状态： Console_12 很容易忘记将返回的 deck 分配给变量，因此控制台API包含一个 deck 方法，和 undo 方法行为相似。调用它将显示 pause 调用的列表： Console_13 调用它并传递与调用相关联的数字将返回相对应的 deck ： Console_14 像 log 和 let 的调用一样，pause 的调用也可以撤销。撤销 pause 的调用将看到标记的 Observable 恢复正常： Console_15 希望以上的例子可以对 rxjs-spy 的控制台API进行一个概述。Debugging RxJS 的后续部分将重点介绍 rxjs-spy 的具体功能以及如何使用它们来解决实际的调试问题。 对我来说，rxjs-spy 肯定让调试Rxjs不再那么繁琐。 更多信息rxjs-spy 的代码可以在 GitHub上找到，并且有一个在线的控制台API示例。 该包可以通过NPM进行安装。 有关本系列的一下篇文章，正在翻译中，敬请期待。。。","tags":[{"name":"Rxjs","slug":"Rxjs","permalink":"http://tanyibing.com/tags/Rxjs/"}]},{"title":"api接口跨域问题","date":"2018-11-08T06:55:20.000Z","path":"2018/11/08/api接口跨域问题/","text":"今天在自己的项目中想要提供一些api，暴露出来想要提供数据，下面是我的api接口，很简单： const router = require(&apos;koa-router&apos;)(); router.get(&apos;/&apos;, async (ctx) =&gt; { ctx.body = &apos;api&apos;; }); router.get(&apos;/catelist&apos;, async (ctx) =&gt; { let catelist = await DB.find(&apos;articlecate&apos;, {}); ctx.body = { result: catelist } }); module.exports = router.routes(); 我们一般调用会怎么写呢？如下： $(function(){ $(&apos;#button&apos;).click(function(){ $.getJSON(&apos;http://localhost:8000/api/catelist&apos;, function(data){ onsole.log(data); }) }) }) 我们通过点击一个按钮来接收数据。但是一旦我们跨域之后这样子就没办法了。啥叫跨域呢，就是当我们的域名、端口、协议中只要有一个不一致，就请求不到数据啦，那一般的解决方法怎么整呢？我们可以用jsonp。 jsonp是个什么原理呢？就是利用script src可以跨域的特性来实现。拢共分两步： 本地写一个回调函数 在远程执行这个回调函数，把远程的数据传到本地 下面给个例子： function xxxx(data){ console.log(data); } 咋们先写个函数，然后用个script来远程调用下： &lt;script src=&quot;http://localhost:8000/api/catelist?callback=xxxx&quot;&gt;&lt;/script&gt; 没错，咋们在后面加上callback就行啦。再看一个jquery版本的： $(function(){ var url=&apos;http://localhost:8000/api/catelist&apos;; $.ajax({ url:url, dataType:&apos;jsonp&apos;, /*定义jsonp请求*/ data:&apos;&apos;, /*get传值*/ jsonp:&apos;callback&apos;, /*回调函数的参数*/ success:function(data) { console.log(data); }, timeout:3000 /*超时时间*/ }); }) 但是这样做有一个前提，那就是后台要允许jsonp，但这样的话会极度不安全，怎么解决呢，我们一般是加上数字签名来保证安全。","tags":[{"name":"Node","slug":"Node","permalink":"http://tanyibing.com/tags/Node/"},{"name":"Ajax","slug":"Ajax","permalink":"http://tanyibing.com/tags/Ajax/"}]},{"title":"帝国CMS使用总结","date":"2018-11-07T08:53:15.000Z","path":"2018/11/07/帝国CMS使用总结/","text":"公司的后台是使用的帝国CMS，想要干好活，总得会用啊。好吧，摸摸索索的用了一段时间，也草草的总结一下吧。 首先后台啥最重要，肯定是数据，所以系统模型也可以叫数据模型也就显得很重要，里面的字段要考虑的周到一些，以便复用，否则改起来就很蛋疼了。 帝国CMS中还有两个灵魂般的东西：“万能标签（ecmsinfo）”、“灵动标签（e:loop）”，这两玩意儿其中之一只要会了，模版都是一把唆。明天我得找个时间好好看一下这个武功秘籍。 以上两个基本是最重要的东东了，数据加模版，站就起来了。但因为不是自己写的后台系统，所以有些东西还是要去改代码的，比如分页这个玩意，你说说你要在前端实现分页你该咋整，又不能去查数据库，所以就还是要找到相应的代码，改一改样式啥的，建站的话基本就只需要这些知识吧，像类似采集啥玩意儿的目前为止还没有遇到过，所以不管了。","tags":[{"name":"CMS","slug":"CMS","permalink":"http://tanyibing.com/tags/CMS/"}]},{"title":"bootstrap使用总结","date":"2018-11-06T13:05:57.000Z","path":"2018/11/06/bootstrap使用总结/","text":"好久咩有写博客了，因为最近在撸很多页面，使用的是Bootstrap，因为设计没有给我两套设计图，所以只能使用这个框架来兼容移动端。现在也可以总结下我使用过程中掌握了啥新知识： 因为我用的是3这个大版本，所以设备还是分为四种：xs（768）、sm（768-992）、md（992-1200）、lg（1200）。不用说了，这是栅格系统的核心，通过媒体查询来将一行分为12列的。每个col都会带有左右两边15px的padding。 container和container-fluid的区别是container-fluid是撑满整个屏幕的宽度，但是他两都有左右两边各15px的padding，为的是防止文字显示触摸到屏幕边界，如果不想要这个padding，可以在container和container-fluid中加上row，因为row的左右margin都是-15px，正好抵消padding。关于这个padding和margin其实可以很巧妙的使用，如果我们想在column中嵌套column，先把要被嵌套的column放到row中，再把row放到作为容器的column中，而不需要在放置一个container。这也是因为Bootstrap在一开始便说了: 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 还有一点是container和container-fluid是不能嵌套的，这一点我发现公司之前的项目中很多地方都没有注意。 我们还可以通过col-xxx-offset-xx、col-xxx-pull-xx、col-xxx-pull-xx来实现跳过xx列、向右推xx列、向左推xx列的效果。 当我的有先样式在移动端实在是不好展现的时候，这时我们就需要两个不一样的结构，一个在大屏上展示，一个在小屏上展示。这就需要用到visibile-xs-xxx、hide-xs-xxx、visibile-xs-block/inline/block-inline这些来控制展示。 还有一点是form表单一定要添加label然后可以通过设置.sr-only来隐藏，这是为了给盲人更好的体验，同时也是seo的一种技巧。 以上是一些零零散散的感悟。我在工作的时候发现，有些人不能拎清自适应和响应式的区别，嘴里老说着‘自适应、自适应’，却只拿出一套设计图。其实响应式才是一套设计适应所有端，而自适用是需要多套设计图的。 在开发过程中发现有的地方的结构在移动端就是不好看，就需要改变结构，一旦地方多了的话其实不如设计两套。 还有一点就是bootstrap的定制，定制比较方便，可以节省很多代码，其实还有更好的方法就是修改源码，这样的话我们的自由度更高，可以更加深入的定制。","tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://tanyibing.com/tags/Bootstrap/"}]},{"title":"angular写一个联动表单控件","date":"2018-10-18T11:48:48.000Z","path":"2018/10/18/angular写一个联动表单控件/","text":"首先展示下这个表单的样式： 这就是我们需要设计成的表单样式，从图中我们可以看出这个表单可以分成三个部分： 证件输入部分 出生日期部分 地址部分 我们不应该将这些部分都写在一起，因为这样我们的表单将会特别复杂，因为我们将所有的逻辑都写在了一起，而且也不适合复用。所有我们将这三个部分写成三个控件，下面就分别给出模版： 证件输入部分模版： &lt;div&gt; &lt;mat-form-field&gt; &lt;mat-select placeholder=&quot;证件类型&quot; (ngModelChange)=&quot;onIdTypeChange($event.value)&quot; [(ngModel)]=&quot;identity.identityType&quot;&gt; &lt;mat-option *ngFor=&quot;let type of identityTypes&quot; [value]=&quot;type.value&quot;&gt; {{type.label}} &lt;/mat-option&gt; &lt;/mat-select&gt; &lt;/mat-form-field&gt; &lt;/div&gt; &lt;div class=&quot;id-input&quot;&gt; &lt;mat-form-field&gt; &lt;input matInput type=&quot;text&quot; placeholder=&quot;证件号码&quot; (change)=&quot;onIdNoChange($event.target.value)&quot; [(ngModel)]=&quot;identity.identityNo&quot;&gt; &lt;mat-error&gt;证件号码输入有误&lt;/mat-error&gt; &lt;/mat-form-field&gt; &lt;/div&gt; 出生日期部分模版: &lt;div [formGroup]=&quot;form&quot;&gt; &lt;div&gt; &lt;mat-form-field&gt; &lt;input matInput [matDatepicker]=&quot;birthPicker&quot; type=&quot;text&quot; placeholder=&quot;出生日期&quot; formControlName=&quot;birthday&quot;&gt; &lt;mat-datepicker-toggle matSuffix [for]=&quot;birthPicker&quot;&gt;&lt;/mat-datepicker-toggle&gt; &lt;mat-datepicker #dueDatePicker&gt;&lt;/mat-datepicker&gt; &lt;mat-error&gt;日期不正确&lt;/mat-error&gt; &lt;/mat-form-field&gt; &lt;mat-datepicker touchUi=&quot;true&quot; #birthPicker&gt;&lt;/mat-datepicker&gt; &lt;/div&gt; &lt;ng-container formGroupName=&quot;age&quot;&gt; &lt;div&gt; &lt;mat-form-field&gt; &lt;input matInput type=&quot;number&quot; placeholder=&quot;年龄&quot; formControlName=&quot;ageNum&quot;&gt; &lt;/mat-form-field&gt; &lt;/div&gt; &lt;div&gt; &lt;mat-button-toggle-group formControlName=&quot;ageUnit&quot; [(ngModel)]=&quot;selectedUnit&quot;&gt; &lt;mat-button-toggle *ngFor=&quot;let unit of ageUnits&quot; [value]=&quot;unit.value&quot;&gt; {{ unit.label }} &lt;/mat-button-toggle&gt; &lt;/mat-button-toggle-group&gt; &lt;/div&gt; &lt;mat-error class=&quot;mat-body-2&quot; *ngIf=&quot;form.get(&apos;age&apos;).hasError(&apos;ageInvalid&apos;)&quot;&gt;年龄或单位不正确&lt;/mat-error&gt; &lt;/ng-container&gt; &lt;/div&gt; 地址部分模版: &lt;div class=&quot;address-group&quot;&gt; &lt;mat-form-field&gt; &lt;mat-select placeholder=&quot;请选择省份&quot; [(ngModel)]=&quot;_address.province&quot; (ngModelChange)=&quot;onProvinceChange()&quot;&gt; &lt;mat-option *ngFor=&quot;let p of provinces$ | async&quot; [value]=&quot;p&quot;&gt; {{ p }} &lt;/mat-option&gt; &lt;/mat-select&gt; &lt;/mat-form-field&gt; &lt;mat-form-field&gt; &lt;mat-select placeholder=&quot;请选择城市&quot; [(ngModel)]=&quot;_address.city&quot; (ngModelChange)=&quot;onCityChange()&quot;&gt; &lt;mat-option *ngFor=&quot;let c of cities$ | async&quot; [value]=&quot;c&quot;&gt; {{ c }} &lt;/mat-option&gt; &lt;/mat-select&gt; &lt;/mat-form-field&gt; &lt;mat-form-field&gt; &lt;mat-select placeholder=&quot;请选择区县&quot; [(ngModel)]=&quot;_address.district&quot; (ngModelChange)=&quot;onDistrictChange()&quot;&gt; &lt;mat-option *ngFor=&quot;let d of districts$ | async&quot; [value]=&quot;d&quot;&gt; {{ d }} &lt;/mat-option&gt; &lt;/mat-select&gt; &lt;/mat-form-field&gt; &lt;div class=&quot;street&quot;&gt; &lt;mat-form-field&gt; &lt;input matInput placeholder=&quot;街道地址&quot; [(ngModel)]=&quot;_address.street&quot; (ngModelChange)=&quot;onStreetChange()&quot;&gt; &lt;/mat-form-field&gt; &lt;/div&gt; &lt;/div&gt; 我使用的是material主题，模版看起来可能有点复杂。接下来我们分别看下每个模块需要实现的效果： 证件部分就是正常的输入，但是后面要实现一个联动的效果，因为省份证包含了很多信息。 年龄部分本身就需要一个联动，效果如下： 地区部分需要需要根据其他选择项进行筛选： 最后我们需要有一个根据身份证信息，得到我们地址和生日的联动，最终的效果如下： 效果我们有已经看到了，接下来就要对各个控件进行编写了： 证件部分: import { Component, OnInit, forwardRef, OnDestroy, ChangeDetectionStrategy } from &apos;@angular/core&apos;; import { NG_VALUE_ACCESSOR, NG_VALIDATORS, ControlValueAccessor, FormControl } from &apos;@angular/forms&apos;; import { Subscription, Subject, Observable, combineLatest } from &apos;rxjs&apos;; import { IdentityType, Identity } from &apos;../../domain&apos;; @Component({ selector: &apos;app-identity-input&apos;, templateUrl: &apos;./identity-input.component.html&apos;, styleUrls: [&apos;./identity-input.component.scss&apos;], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; IdentityInputComponent), multi: true, }, { provide: NG_VALIDATORS, useExisting: forwardRef(() =&gt; IdentityInputComponent), multi: true, } ], changeDetection: ChangeDetectionStrategy.OnPush, }) export class IdentityInputComponent implements ControlValueAccessor, OnInit, OnDestroy { identityTypes: { value: IdentityType, label: string }[] = [ { value: IdentityType.IdCard, label: &apos;身份证&apos; }, { value: IdentityType.Insurance, label: &apos;医保&apos; }, { value: IdentityType.Passport, label: &apos;护照&apos; }, { value: IdentityType.Military, label: &apos;军官证&apos; }, { value: IdentityType.Other, label: &apos;其它&apos; } ]; identity: Identity = { identityType: null, identityNo: null }; private _idType = new Subject&lt;IdentityType&gt;(); private _idNo = new Subject&lt;string&gt;(); private _sub: Subscription; private propagateChange = (_: any) =&gt; { }; constructor() { } ngOnInit() { const val$ = combineLatest(this.idType, this.idNo, (_type, _no) =&gt; { return { identityType: _type, identityNo: _no }; }); this._sub = val$.subscribe(v =&gt; { this.identity = v; this.propagateChange(v); }); } ngOnDestroy(): void { if (this._sub) { this._sub.unsubscribe(); } } writeValue(obj: any): void { } registerOnChange(fn: any): void { this.propagateChange = fn; } registerOnTouched(fn: any): void { } setDisabledState?(isDisabled: boolean): void { } // 验证表单，验证结果正确返回 null 否则返回一个验证结果对象 validate(c: FormControl): { [key: string]: any } { if (!c.value) { return null; } switch (c.value.identityType) { case IdentityType.IdCard: { return this.validateIdCard(c); } case IdentityType.Passport: { return this.validatePassport(c); } case IdentityType.Military: { return this.validateMilitary(c); } case IdentityType.Insurance: default: { return null; } } } onIdTypeChange(idType) { this._idType.next(idType); } onIdNoChange(idNo) { this._idNo.next(idNo); } private get idType(): Observable&lt;IdentityType&gt; { return this._idType.asObservable(); } private get idNo(): Observable&lt;string&gt; { return this._idNo.asObservable(); } private validateIdCard(c: FormControl): { [key: string]: any } { const val = c.value.identityNo; if (val.length !== 18) { return { idNotValid: true }; } const pattern = /^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}[x0-9]$/; return pattern.test(val) ? null : { idNotValid: true }; } private validatePassport(c: FormControl): { [key: string]: any } { const value = c.value.identityNo; if (value.length !== 9) { return { idNotValid: true }; } const pattern = /^[GgEe]\\d{8}$/; return pattern.test(value) ? null : { idNotValid: true }; } private validateMilitary(c: FormControl): { [key: string]: any } { const value = c.value.identityNo; const pattern = /[\\u4e00-\\u9fa5](字第)(\\d{4,8})(号?)$/; return pattern.test(value) ? null : { idNotValid: true }; } } 年龄部分: import { Component, forwardRef, OnInit, OnDestroy, Input } from &apos;@angular/core&apos;; import { FormGroup, NG_VALUE_ACCESSOR, NG_VALIDATORS, ControlValueAccessor, FormControl, FormBuilder } from &apos;@angular/forms&apos;; import { map, merge, filter, startWith, debounceTime, distinctUntilChanged } from &apos;rxjs/operators&apos;; import { Observable, Subscription, combineLatest } from &apos;rxjs&apos;; import { subDays, subMonths, subYears, differenceInDays, differenceInMonths, differenceInYears, isBefore, parse, format } from &apos;date-fns&apos;; import { isValidDate } from &apos;../../utils/date.util&apos;; export enum AgeUnit { Year = 0, Month, Day } export interface Age { age: number; unit: AgeUnit; } @Component({ selector: &apos;app-age-input&apos;, templateUrl: &apos;./age-input.component.html&apos;, styleUrls: [&apos;./age-input.component.scss&apos;], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; AgeInputComponent), multi: true // 允许令牌多对一 }, { provide: NG_VALIDATORS, useExisting: forwardRef(() =&gt; AgeInputComponent), multi: true } ] }) export class AgeInputComponent implements ControlValueAccessor, OnInit, OnDestroy { @Input() daysTop = 90; @Input() daysBottom = 0; @Input() monthsTop = 24; @Input() monthsBottom = 1; @Input() yearsTop = 150; @Input() yearsBottom = 1; @Input() format = &apos;YYYY-MM-DD&apos;; @Input() debounceTime = 300; selectedUnit = AgeUnit.Year; ageUnits = [ { value: AgeUnit.Year, label: &apos;岁&apos; }, { value: AgeUnit.Month, label: &apos;月&apos; }, { value: AgeUnit.Day, label: &apos;日&apos; } ]; form: FormGroup; sub: Subscription; private propagateChange = (_: any) =&gt; { }; constructor(private fb: FormBuilder) { } ngOnInit(): void { this.form = this.fb.group({ birthday: [&apos;&apos;, this.validateDate], age: this.fb.group({ ageNum: [&apos;&apos;], ageUnit: [AgeUnit.Year] }, { validator: this.validateAge(&apos;ageNum&apos;, &apos;ageUnit&apos;) }) }); const birthday = this.form.get(&apos;birthday&apos;); const ageNum = this.form.get(&apos;age&apos;).get(&apos;ageNum&apos;); const ageUnit = this.form.get(&apos;age&apos;).get(&apos;ageUnit&apos;); const birthday$ = birthday.valueChanges.pipe( map(d =&gt; { return { date: d, from: &apos;birthday&apos; }; }), debounceTime(this.debounceTime), distinctUntilChanged(), filter(_ =&gt; birthday.valid) ); const ageNum$ = ageNum.valueChanges.pipe( startWith(ageNum.value), debounceTime(this.debounceTime), distinctUntilChanged(), ); const ageUnit$ = ageUnit.valueChanges.pipe( startWith(ageUnit.value), debounceTime(this.debounceTime), distinctUntilChanged() ); // rxjs6版本中方法被改造了 const age$ = combineLatest(ageNum$, ageUnit$).pipe( map(([_n, _u]) =&gt; this.toDate({ age: _n, unit: _u })), map(d =&gt; { return { date: d, from: &apos;age&apos; }; }), filter(_ =&gt; this.form.get(&apos;age&apos;).valid) ); const merged$ = Observable.prototype.pipe( merge(birthday$, age$), filter(_ =&gt; this.form.valid) ); this.sub = merged$.subscribe(d =&gt; { const age = this.toAge(d.date); if (d.from === &apos;birthday&apos;) { if (age.age !== ageNum.value) { ageNum.patchValue(age.age, { emitEvent: false }); } if (age.unit !== ageUnit.value) { this.selectedUnit = age.unit; ageUnit.patchValue(age.age, { emitEvent: false }); } this.propagateChange(d.date); } else { const ageToCompare = this.toAge(this.form.get(&apos;birthday&apos;).value); if (age.age !== ageToCompare.age || age.unit !== ageToCompare.unit) { birthday.patchValue(d.date, { emitEvent: false }); this.propagateChange(d.date); } } }); } ngOnDestroy(): void { if (this.sub) { this.sub.unsubscribe(); } } writeValue(obj: any): void { if (obj) { const date = format(obj, this.format); this.form.get(&apos;birthday&apos;).patchValue(date); const age = this.toAge(date); this.form.get(&apos;age&apos;).get(&apos;ageNum&apos;).patchValue(age.age); this.form.get(&apos;age&apos;).get(&apos;ageUnit&apos;).patchValue(age.unit); } } registerOnChange(fn: any): void { this.propagateChange = fn; } registerOnTouched(fn: any): void { } setDisabledState?(isDisabled: boolean): void { } toAge(dateStr: string): Age { const date = parse(dateStr); const now = Date.now(); return isBefore(subDays(now, this.daysTop), date) ? { age: differenceInDays(now, date), unit: AgeUnit.Day } : isBefore(subMonths(now, this.monthsTop), date) ? { age: differenceInMonths(now, date), unit: AgeUnit.Month } : { age: differenceInYears(now, date), unit: AgeUnit.Year }; } toDate(age: Age): string { const now = Date.now(); switch (age.unit) { case AgeUnit.Year: { return format(subYears(now, age.age), this.format); } case AgeUnit.Month: { return format(subMonths(now, age.age), this.format); } case AgeUnit.Day: { return format(subDays(now, age.age), this.format); } default: { return null; } } } validate(c: FormControl): { [key: string]: any } { const val = c.value; if (!val) { return null; } if (isValidDate(val)) { return null; } return { dateOfBirthInvalid: true }; } // 表单验证器 validateAge(ageNumkey: string, ageUnitKey: string) { return (group: FormGroup): { [key: string]: any } =&gt; { const ageNum = group.controls[ageNumkey]; const ageUnit = group.controls[ageUnitKey]; let result = false; const ageNumVal = ageNum.value; switch (ageUnit.value) { case AgeUnit.Year: { result = ageNumVal &gt;= this.yearsBottom &amp;&amp; ageNumVal &lt; this.yearsTop; break; } case AgeUnit.Month: { result = ageNumVal &gt;= this.monthsBottom &amp;&amp; ageNumVal &lt; this.monthsTop; break; } case AgeUnit.Day: { result = ageNumVal &gt;= this.daysBottom &amp;&amp; ageNumVal &lt; this.daysTop; break; } default: { break; } } return result ? null : { ageInvalid: true }; }; } validateDate(c: FormControl): { [key: string]: any } { const val = c.value; return isValidDate(val) ? null : { birthdayInvalid: true }; } } 地区部分: import { Component, OnInit, forwardRef, ChangeDetectionStrategy, OnDestroy } from &apos;@angular/core&apos;; import { NG_VALUE_ACCESSOR, NG_VALIDATORS, ControlValueAccessor, FormControl } from &apos;@angular/forms&apos;; import { Subscription, Subject, combineLatest, Observable, of } from &apos;rxjs&apos;; import { Address } from &apos;../../domain/user.model&apos;; import { startWith, map } from &apos;rxjs/operators&apos;; import { getProvinces, getCitiesByProvince, getAreasByCity } from &apos;../../utils/area.util&apos;; @Component({ selector: &apos;app-area-list&apos;, templateUrl: &apos;./area-list.component.html&apos;, styleUrls: [&apos;./area-list.component.scss&apos;], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; AreaListComponent), multi: true, }, { provide: NG_VALIDATORS, useExisting: forwardRef(() =&gt; AreaListComponent), multi: true, }, ], changeDetection: ChangeDetectionStrategy.OnPush, }) export class AreaListComponent implements ControlValueAccessor, OnInit, OnDestroy { _address: Address = { province: &apos;&apos;, city: &apos;&apos;, district: &apos;&apos;, street: &apos;&apos; }; _province = new Subject(); _city = new Subject(); _district = new Subject(); _street = new Subject(); provinces$: Observable&lt;string[]&gt;; cities$: Observable&lt;string[]&gt;; districts$: Observable&lt;string[]&gt;; private _sub: Subscription; private propagateChange = (_: any) =&gt; { }; constructor() { } ngOnInit() { const province$ = this._province.asObservable().pipe(startWith(&apos;&apos;)); const city$ = this._city.asObservable().pipe(startWith(&apos;&apos;)); const district$ = this._district.asObservable().pipe(startWith(&apos;&apos;)); const street$ = this._street.asObservable().pipe(startWith(&apos;&apos;)); const val$ = combineLatest([province$, city$, district$, street$], (_p, _c, _d, _s) =&gt; { return { province: _p, city: _c, district: _d, street: _s }; }); this._sub = val$.subscribe(v =&gt; { this.propagateChange(v); }); this.provinces$ = of(getProvinces()); // 根据省份的选择得到城市列表 this.cities$ = province$.pipe( map((p: string) =&gt; getCitiesByProvince(p)) ); // 根据省份和城市的选择得到地区列表 this.districts$ = combineLatest(province$, city$, (p, c) =&gt; ({ province: p, city: c })).pipe( map(a =&gt; getAreasByCity(a.province, a.city)) ); } ngOnDestroy(): void { if (this._sub) { this._sub.unsubscribe(); } } // 设置初始值 writeValue(obj: Address): void { if (obj) { this._address = obj; if (this._address.province) { this._province.next(this._address.province); } if (this._address.city) { this._city.next(this._address.city); } if (this._address.district) { this._district.next(this._address.district); } if (this._address.street) { this._street.next(this._address.street); } } } registerOnChange(fn: any): void { this.propagateChange = fn; } registerOnTouched(fn: any): void { } setDisabledState?(isDisabled: boolean): void { } // 验证表单，验证结果正确返回 null 否则返回一个验证结果对象 validate(c: FormControl): { [key: string]: any } { const val = c.value; if (!val) { return null; } if (val.province &amp;&amp; val.city &amp;&amp; val.district &amp;&amp; val.street &amp;&amp; val.street.length &gt;= 4) { return null; } return { addressNotValid: true }; } onProvinceChange() { this._province.next(this._address.province); } onCityChange() { this._city.next(this._address.city); } onDistrictChange() { this._district.next(this._address.district); } onStreetChange() { this._street.next(this._address.street); } } 当然了，这些不是全部的代码，有些重复的功能我写成了单独的ts文件，有兴趣的可以去我的github上看。 这样我们只是完成了各个自定义控件，这样的好处是我们的控件可以重复使用，而且各部分逻辑都在各自的部分，所以最后我们需要一个整体来包含这些控件。 &lt;form [formGroup]=&quot;form&quot; (ngSubmit)=&quot;onSubmit(form, $event)&quot;&gt; &lt;mat-card&gt; &lt;mat-tab-group&gt; &lt;mat-tab label=&quot;帐号信息&quot;&gt; &lt;mat-card-header&gt; &lt;mat-card-title&gt;注册&lt;/mat-card-title&gt; &lt;/mat-card-header&gt; &lt;mat-card-content&gt; &lt;mat-form-field class=&quot;full-width&quot;&gt; &lt;input matInput placeholder=&quot;您的email*&quot; type=&quot;email&quot; formControlName=&quot;email&quot;&gt; &lt;/mat-form-field&gt; &lt;mat-form-field class=&quot;full-width&quot;&gt; &lt;input matInput placeholder=&quot;您的姓名*&quot; type=&quot;text&quot; formControlName=&quot;name&quot;&gt; &lt;/mat-form-field&gt; &lt;mat-form-field class=&quot;full-width&quot;&gt; &lt;input matInput placeholder=&quot;输入您的密码*&quot; type=&quot;password&quot; formControlName=&quot;password&quot;&gt; &lt;/mat-form-field&gt; &lt;mat-form-field class=&quot;full-width&quot;&gt; &lt;input matInput placeholder=&quot;重复输入您的密码*&quot; type=&quot;password&quot; formControlName=&quot;repeat&quot;&gt; &lt;/mat-form-field&gt; &lt;app-image-list-select [useSvgIcon]=&quot;true&quot; [cols]=&quot;6&quot; [title]=&quot;&apos;选择头像：&apos;&quot; [items]=&quot;items&quot; formControlName=&quot;avatar&quot;&gt; &lt;/app-image-list-select&gt; &lt;button mat-raised-button color=&quot;primary&quot; type=&quot;submit&quot;&gt;注册&lt;/button&gt; &lt;/mat-card-content&gt; &lt;mat-card-actions class=&quot;text-right&quot;&gt; &lt;p&gt;已有账户？&lt;a href=&quot;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;p&gt;忘记密码？&lt;a href=&quot;&quot;&gt;找回&lt;/a&gt;&lt;/p&gt; &lt;/mat-card-actions&gt; &lt;/mat-tab&gt; &lt;mat-tab label=&quot;个人信息&quot;&gt; &lt;div class=&quot;full-width control-padding&quot;&gt; &lt;app-identity-input formControlName=&quot;identity&quot; class=&quot;full-width control-padding&quot;&gt;&lt;/app-identity-input&gt; &lt;/div&gt; &lt;div class=&quot;full-width control-padding&quot;&gt; &lt;app-age-input formControlName=&quot;dateOfBirth&quot;&gt;&lt;/app-age-input&gt; &lt;/div&gt; &lt;div class=&quot;full-width control-padding&quot;&gt; &lt;app-area-list formControlName=&quot;address&quot;&gt;&lt;/app-area-list&gt; &lt;/div&gt; &lt;/mat-tab&gt; &lt;/mat-tab-group&gt; &lt;/mat-card&gt; &lt;/form&gt; 这个部分的处理逻辑如下： import { Component, OnInit, OnDestroy } from &apos;@angular/core&apos;; import { FormBuilder, Validators, FormGroup } from &apos;@angular/forms&apos;; import { debounceTime, filter } from &apos;rxjs/operators&apos;; import { Subscription } from &apos;rxjs&apos;; import { extractInfo, isValidAddr, getAddrByCode } from &apos;../../utils/identity.util&apos;; import { isValidDate } from &apos;../../utils/date.util&apos;; @Component({ selector: &apos;app-register&apos;, templateUrl: &apos;./register.component.html&apos;, styleUrls: [&apos;./register.component.scss&apos;] }) export class RegisterComponent implements OnInit, OnDestroy { items: string[]; form: FormGroup; sub: Subscription; private readonly avatarName = &apos;avatars&apos;; constructor(private fb: FormBuilder) { } ngOnInit() { const img = `${this.avatarName}:svg-${(Math.random() * 16).toFixed()}`; const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]; this.items = nums.map(val =&gt; `avatars:svg-${val}`); this.form = this.fb.group({ email: [&apos;wang@163.com&apos;, Validators.compose([Validators.email, Validators.required])], name: [&apos;&apos;], password: [&apos;&apos;], repeat: [&apos;&apos;], avatar: [img], dateOfBirth: [&apos;1990-01-01&apos;], address: [&apos;&apos;], identity: [&apos;&apos;] }); const id$ = this.form.get(&apos;identity&apos;).valueChanges.pipe( debounceTime(300), filter(_ =&gt; this.form.get(&apos;identity&apos;).valid) ); this.sub = id$.subscribe(id =&gt; { const info = extractInfo(id.identityNo); if (isValidAddr(info.addrCode)) { const addr = getAddrByCode(info.addrCode); this.form.get(&apos;address&apos;).patchValue(addr); } if (isValidDate(info.dateOfBirth)) { this.form.get(&apos;dateOfBirth&apos;).patchValue(info.dateOfBirth); } }); } ngOnDestroy(): void { if (this.sub) { this.sub.unsubscribe(); } } onSubmit({ value, valid }, ev: Event) { ev.preventDefault(); if (!valid) { return; } console.log(value); } } 这样就形成了一个完整的自定义表单控件，而且里面部分还可以拿出来单独使用。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"},{"name":"Material","slug":"Material","permalink":"http://tanyibing.com/tags/Material/"}]},{"title":"rxjs中的combineLatest","date":"2018-10-17T03:43:35.000Z","path":"2018/10/17/rxjs中的combineLatest/","text":"在Rxjs第六版之前，我们使用combineLatest这个operator时的方式如下： const age$ = Observable .combineLatest(ageNum$, ageUnit$, (_num, _unit) =&gt; this.toDate({age: _num, unit: _unit})) .map(d =&gt; ({date: d, from: &apos;age&apos;})) .filter(_ =&gt; this.form.get(&apos;age&apos;).valid); 但是，在Rxjs第六版中combineLatest这个operator被遗弃了，而是被改成一个function，然后配合pipe()使用，改造后的方法如下： const age$ = combineLatest(ageNum$, ageUnit$).pipe( map(([_n, _u]) =&gt; this.toDate({ age: _n, unit: _u })), map(d =&gt; { return { date: d, from: &apos;age&apos; }; }), filter(_ =&gt; this.form.get(&apos;age&apos;).valid) ); 这之间发生了明显的变化，首先调用的方式就不同，版本六之前是调用Observable.combineLatest，而在版本六之后直接就可以使用combineLatest()；还有一个不同就是参数不同了，原先的参数最后可以接受一个project，实现对元素的操作，但是第六版之后，我们需要pipe出来之后，使用map来对元素进行操作，而且元素是在一个数组里面的，这归根结底是因为返回的类型不一样了，operator返回的就是一个operator，而第六版之后返回的是一个Observable对象，我们可以继续对其进行操作。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Rxjs","slug":"Rxjs","permalink":"http://tanyibing.com/tags/Rxjs/"}]},{"title":"使用js实现图片的循环播放","date":"2018-10-14T05:38:01.000Z","path":"2018/10/14/使用js实现图片的循环播放/","text":"今天想要实现很多图片的循环播放，我们首先要把所有的图片放到一行上面，具体怎么写css在这就不啰嗦了，最后的html结构如下： &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;first&quot;&gt; &lt;li&gt; &lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;./images/2.jpg&quot; alt=&quot;&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;./images/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;second&quot;&gt; &lt;li&gt; &lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;./images/2.jpg&quot; alt=&quot;&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;./images/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 这里我设置了两个相同的图片ul是为了更好的实现无缝播放，紧接着js代码如下： window.onload = function () { var container = document.querySelector(&apos;.container&apos;); var first = document.querySelector(&apos;.first&apos;); var second = document.querySelector(&apos;.second&apos;); // 获得一个ul图片循环需要的长度 var length = ul1.offsetWidth; var x = 0; // 当一个循环结束时，将x重置为0，第二个ul其实就是起一个弥补上一个的空白的作用。 var fun = function () { first.style.left = x/100 + &apos;rem&apos;; second.style.left = (x + length)/100 + &apos;rem&apos;; x--; if ((x + length) == 0) { x = 0; } } var loop = setInterval(fun, 10); // 鼠标移上去暂停滚动 container.onmouseover = function () { clearInterval(loop); } // 鼠标移开继续滚动 container.onmouseout = function () { loop = setInterval(fun, 10); } } 注释里面解释啦，很简单。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"}]},{"title":"angular中select的change事件","date":"2018-10-11T14:53:39.000Z","path":"2018/10/11/angular中select的change事件/","text":"今天在使用material中的select组件的时候发现，我的select上面的change事件通过下面的方法并不能接收数据，模板如下： &lt;mat-form-field&gt; &lt;mat-select placeholder=&quot;请选择省份&quot; [(ngModel)]=&quot;_address.province&quot; (change)=&quot;onProvinceChange()&quot;&gt; &lt;mat-option *ngFor=&quot;let p of provinces$ | async&quot; [value]=&quot;p&quot;&gt; {{ p }} &lt;/mat-option&gt; &lt;/mat-select&gt; &lt;/mat-form-field&gt; 我想通过select的变化来控制其他数据的显示，但是change方法好像监听不到改变一样，最后通过度娘，找到了方法，将change事件改成ngModelChange就可以了： &lt;mat-form-field&gt; &lt;mat-select placeholder=&quot;请选择省份&quot; [(ngModel)]=&quot;_address.province&quot; (ngModelChange)=&quot;onProvinceChange()&quot;&gt; &lt;mat-option *ngFor=&quot;let p of provinces$ | async&quot; [value]=&quot;p&quot;&gt; {{ p }} &lt;/mat-option&gt; &lt;/mat-select&gt; &lt;/mat-form-field&gt; 这样就可以获得事件了。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"},{"name":"Material","slug":"Material","permalink":"http://tanyibing.com/tags/Material/"}]},{"title":"设置input中placeholder的字体颜色","date":"2018-10-10T14:22:46.000Z","path":"2018/10/10/设置input中placeholder的字体颜色/","text":"在一个有背景的div中创建一个form之后，我发现input的背景默认是白色的，这样的话就无法看到背景图，所以我将input的背景调成透明，并加上边框来凸显出input的存在： input { background: transparent; border: #ffffff solid 1px; } 这样我们的input框就呈现透明的状态。但是我发现input中的placeholder的颜色是黑色的，在我的背景下面不是特别清晰，所以我们需腰改变placeholder的字体颜色： ::-webkit-input-placeholder{/*Webkit browsers*/ color:#999; font-size:16px; } :-moz-placeholder{/*Mozilla Firefox 4 to 8*/ color:#999; font-size:16px; } ::moz-placeholder{/*Mozilla Firefox 19+*/ color:#999; font-size:16px; } :-ms-input-placeholder{/*Internet Explorer 10+*/ color:#999; font-size:16px; } 我们只要在：前面加上input或者textarea就可以改变placeholder的字体。它的兼容性如下：","tags":[{"name":"HTML","slug":"HTML","permalink":"http://tanyibing.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://tanyibing.com/tags/CSS/"}]},{"title":"在VScode中使用Git","date":"2018-10-09T13:31:16.000Z","path":"2018/10/09/在VScode中使用Git/","text":"在VsCode中使用Git来将我的修改保存到远程仓库的操作： 首先我们在Github上创建一个仓库，否则我们的项目没办法保存到远程仓库。 接下来我一般是在本地创建一个目录，并且用VsCode打开目录。 然后我们开始将本地目录和远程仓库关联起来，首先在VsCode中运行git init命令来将文件夹初始化成Git仓库。 然后我们运行git remote add origin XXX(你的github仓库地址),这样就完成了关联。 接着点击图中的master按钮，就可以看到我们的远程仓库，选择它，并在目录下进行工作。&gt; 我们也许需要定义一个.gitignore文件来忽略掉一些你不想展示给别人看的，或者不重要的文件。 别忘在工作区工作之后要提交更改，并且同步到远程仓库。","tags":[{"name":"VsCode","slug":"VsCode","permalink":"http://tanyibing.com/tags/VsCode/"},{"name":"Git","slug":"Git","permalink":"http://tanyibing.com/tags/Git/"}]},{"title":"MongoDB怎么导入数据","date":"2018-10-08T14:44:24.000Z","path":"2018/10/08/MongoDB怎么导入数据/","text":"使用node的过程中使用了MongoDB，在MongoDB中怎么直接将数据导入数据库呢？我们只需要一条命令就行了。 mongorestore -h dbhost -d dbname path 其中dbhost代表你的host，一般在自己的电脑上的话是127.0.0.1，dbname代表要导入的数据库，可以是不存在的，默认会创建一个新的数据库，path就是你的数据库数据存放的位置。路径中最好不要有中文，以防导入失败。这行命令不需要进入到数据库里面再执行，直接在cmd中运行就可以了。 想要导出的话也很简单，只要执行下面的命令： mongodump -h dbhost -d dbname -o dbdirectory -o dbdirectory是指导出到哪个目录。但是导出之前我们需要打开我们的数据路服务： mongod –dbpath yourpath 再执行上面的导出命令就OK啦。","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://tanyibing.com/tags/MongoDB/"}]},{"title":"ES6中的export & import","date":"2018-10-07T15:44:24.000Z","path":"2018/10/07/ES6中的export-import/","text":"上次说了一下exports和module.exports的区别，但是只讲了那一种状态，所以今天特意再来看看ES6中module的内容。 在ES6中，专门实现了模块化的功能。想要更仔细的阅读可以看一看阮一峰的《ESMAScript6入门》中的Module的语法。里面是这么说的： 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 由此可见ES6中的模块化功能还是很强大的。 export先看几种export的写法： // 第一种 输出两个变量 export var firstName = &apos;Michael&apos;; export var lastName = &apos;Jackson&apos;; // 第二种 和第一种一样，相同情况应该优先使用第二种。 var firstName = &apos;Michael&apos;; var lastName = &apos;Jackson&apos;; export {firstName, lastName, year}; // 第三种 输出函数或类 export function multiply(x, y) { return x * y; }; 上面的三种情况在注释里解释了，就按这种模式写。但是要注意的是不要写成下面的样子; // 报错 export 1; // 报错 var m = 1; export m; 这样写是直接输出，而不是通过接口，所以会报错。应该写成下面这样： // 写法一 export var m = 1; // 写法二 var m = 1; export {m}; // 写法三 var n = 1; export {n as m}; 同样的，function和class也要按这种接口的方式去写： // 报错 function f() {} export f; // 正确 export function f() {}; // 正确 function f() {} export {f}; import看几个import的写法： // 普通写法 import {firstName, lastName, year} from &apos;./profile.js&apos;; // 重命名写法 import { lastName as surname } from &apos;./profile.js&apos;; // 整体加载写法 import * as name from &apos;./profile.js&apos;; 这就是import的几种写法，不要妖来妖去的，例如使用表达式和变量、修改接口啊什么的操作，即使可以操作，也是极不推荐的，防止出现错误后找不到问题的根源。 export defaultexport default是一种默认输出的方式，他的形式如下： // 输出 export default function () { console.log(&apos;foo&apos;); } // 输入 import customName from &apos;./export-default&apos;; customName(); 可以发现，默认输出之后，引入时被当成匿名函数，我们可以给他起任意的名字。export default可以用在非匿名函数前面，但是在外部还是会被当成匿名函数来加载。还可以发现的是，使用默认输出之后，在import时不再需要大括号了，这是因为export default只能使用一次，所以在引入时可以不加大括号。 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 // 正确 export var a = 1; // 正确 var a = 1; export default a; // 错误 export default var a = 1; // 正确 export default 42; // 报错 export 42; 复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。例如下面： export { foo, bar } from &apos;my_module&apos;; // 可以简单理解为 import { foo, bar } from &apos;my_module&apos;; export { foo, bar }; 上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"}]},{"title":"发发牢骚","date":"2018-10-02T14:39:47.000Z","path":"2018/10/02/发发牢骚/","text":"今天在家吃饭，大家都聚在一起，喝了很多酒，也聊了很多家庭的问题。从小和家长之间的交流就很少，真正认真的交流就更加是屈指可数。更多的也是在争吵之中吐露心声，但也被冲动的情绪掩盖了。长大之后也多多少少思考过这些事情。过去这么久了，爷爷奶奶也转变了很多，我父亲对我的态度也有很大的改变。其实他们只是不会表达，不善于交流，但他们也是真心希望孩子们过得好。反思反思自己，还有很多地方没做好。以后在外工作要经常给家里带电话，回家也应该买些水果给爷爷奶奶、外公外婆。因为留给他们的时间不多了，能和我们在一起的日子更少。要多抽空回家陪陪他们，让他们不要太寂寞。不要等到最后子欲养而亲不待~~~","tags":[{"name":"balabala","slug":"balabala","permalink":"http://tanyibing.com/tags/balabala/"}]},{"title":"使用Rx.js和json-server模拟随机获取内容","date":"2018-09-29T09:03:56.000Z","path":"2018/09/29/使用Rx-js和json-server模拟随机获取内容/","text":"今天使用angular中的rx.js来将我们的数据转换成Observable，毕竟angular中到处都是Observable可观察对象这种方式，因为使用起来很方便。 我们没有真的后台怎么模拟接口呢，我直接使用了json-server，这个使用起来很方便，只需要写好一个模拟接口的json文件，然后执行命令就行了。首先我们安装： cnpm install --save-dev json-server 然后我们写一个json文件，紧接着执行一条命令： json-server ./mock/data.json 这样我就能在localhost:3000下面通过http请求到我的json文件啦。 紧接着我们把获取json文件功能封装成angular中的一个服务： import { Injectable, Inject } from &apos;@angular/core&apos;; import { Quote } from &apos;../domain/quote.model&apos;; import { Observable } from &apos;rxjs&apos;; import { HttpClient } from &apos;@angular/common/http&apos;; import { map } from &apos;rxjs/operators&apos;; @Injectable() export class QuoteService { constructor( private Http: HttpClient, @Inject(&apos;BASE_CONFIG&apos;) private config ) {} getQuote(): Observable&lt;Quote&gt; { const uri = `${this.config.uri}/quotes/${Math.floor(Math.random() * 10)}`; return this.Http.get(uri).pipe(map(res =&gt; res as Quote)); } } 这样我们就注册了一个我们自己的服务，而且我们同过随机请求uri可以实现随机获取内容中的一天。而且，我们最后在返回的时候，返回的是Observable类型的内容。在需要使用这些内容的组件内，我们只要注册这个服务就可以了： constructor(private quoteService$: QuoteService) { this.quoteService$ .getQuote() .subscribe(q =&gt; this.quote = q); } 我们在组件中注册这个服务之后，通过订阅的方式获取到了数据，这样是不是很简单。 我们使用quoteService$这样的写法是因为，这是一个流！","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Rxjs","slug":"Rxjs","permalink":"http://tanyibing.com/tags/Rxjs/"}]},{"title":"angular中自定义表单控件","date":"2018-09-28T15:51:23.000Z","path":"2018/09/28/angular中自定义表单控件/","text":"angular中有两种表单，一种是模版驱动的表单，还有一种是响应式的表单。如果我们的表单比较简单的话我们可以使用模版驱动型表单，但是一旦我么的表单复杂起来，那么响应式表单是我们的首选。 但是一旦我们的表单过于复杂之后，我们就需要将很多的逻辑写在一起，对于我们来说是件很糟糕的事情，所以，我们需要把复杂问题简单化，因此，我们可以自定义表单控件。 我需要实现一个如下的头像选择效果： 如果光是添加头像我们可以直接写，没必要写成控件，但是，我在之后的项目中可能也想给我其他表单添加图片也实现这样的功能，那我就需要封装一下，方便以后复用。 我在此就写一些删减后的代码，理清思路。首先我们给出我们自定义表单控件的模板： &lt;div&gt; &lt;mat-icon *ngIf=&quot;useSvgIcon else imgSelect&quot;&gt;&lt;/mat-icon&gt; &lt;ng-template #imgSelect&gt; &lt;img [src]=&quot;selected&quot; alt=&quot;image selected&quot;&gt; &lt;/ng-template&gt; &lt;/div&gt; &lt;div class=&quot;scroll-container&quot;&gt; &lt;mat-grid-list&gt; &lt;mat-grid-tile *ngFor=&quot;let item of items&quot;&gt; &lt;div class=&quot;image-container&quot;&gt; &lt;mat-icon [svgIcon]=&quot;item&quot; *ngIf=&quot;useSvgIcon else imgItem&quot;&gt;&lt;/mat-icon&gt; &lt;ng-template #imgItem&gt; &lt;img [src]=&quot;item&quot; alt=&quot;image item&quot;&gt; &lt;/ng-template&gt; &lt;/mat-grid-tile&gt; &lt;/div&gt; 第一个div是我们展示选中的，下面的是展示所有头像，使用的是material中的gridlist。 我们想要自定义表单控件，最重要的就是实现ControlValueAccessor接口，例子如下： import { Component, forwardRef } from &apos;@angular/core&apos;; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from &apos;@angular/forms&apos;; @Component({ selector: &apos;app-image-list-select&apos;, templateUrl: &apos;./image-list-select.component.html&apos;, styleUrls: [&apos;./image-list-select.component.scss&apos;], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ImageListSelectComponent), multi: true // 允许令牌多对一 } ] }) export class ImageListSelectComponent implements ControlValueAccessor { constructor() { } // 这里是做一个空函数体，真正使用的方法在 registerOnChange 中 // 由框架注册，然后我们使用它把变化发回表单 // 注意，和 EventEmitter 尽管很像，但发送回的对象不同 private propagateChange = (_: any) =&gt; {}; // 写入控件值 writeValue(obj: any): void {} // 当表单控件值改变时，函数 fn 会被调用 // 这也是我们把变化 emit 回表单的机制 registerOnChange(fn: any): void { this.propagateChange = fn; } // 这里没有使用，用于注册 touched 状态 registerOnTouched(fn: any): void {} setDisabledState?(isDisabled: boolean): void {} } 要实现ControlValueAccessor接口，我们就需要实现上面四中方法，在writeValue，我们就能获取到控件中值的值，然后我们通过private propagateChange = (_: any) =&gt; {};这个类似于EventEmitter的函数将值暴露出去。差不多就行了。 想要了解这个项目的可以去我的github上看我的项目：这是地址","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"},{"name":"Material","slug":"Material","permalink":"http://tanyibing.com/tags/Material/"}]},{"title":"angular中写自己的指令","date":"2018-09-27T15:23:39.000Z","path":"2018/09/27/angular中写自己的指令/","text":"今天我们想实现一个组件拖拽的效果，以方便以后可以通过拖拽来切换我们组件的位置。所以，我们需要设计自己的指令Directive。 在angular中有三种指令： 组件 — 拥有模板的指令 结构型指令 — 通过添加和移除 DOM 元素改变 DOM 布局的指令 属性型指令 — 改变元素、组件或其它指令的外观和行为的指令 组件是这三种指令中最常用的，而结构型的指令会改变 DOM 结构，建议是不使用，但真要使用之前得好好思考下，否则可能会带来一些不好的结果。我们今天就使用属性型的指令来实现我们想要的东西吧。 直接上代码吧： import { Directive, Input, HostListener, ElementRef, Renderer2 } from &apos;@angular/core&apos;; import { DragDropService } from &apos;../drag-drop.service&apos;; @Directive({ selector: &apos;[app-draggable]&apos; }) export class DragDirective { private _isDraggable = false; @Input() draggedClass: string; @Input(&apos;app-draggable&apos;) set isDraggable(val: boolean) { this._isDraggable = val; this.rd.setAttribute(this.el.nativeElement, &apos;draggable&apos;, `${val}`); } get isDraggable() { return this._isDraggable; } constructor( private el: ElementRef, private rd: Renderer2 ) { } @HostListener(&apos;dragstart&apos;, [&apos;$event&apos;]) onDragStart(ev: Event) { if (this.el.nativeElement === ev.target) { this.rd.addClass(this.el.nativeElement, this.draggedClass); } } @HostListener(&apos;dragend&apos;, [&apos;$event&apos;]) onDragEnd(ev: Event) { if (this.el.nativeElement === ev.target) { this.rd.removeClass(this.el.nativeElement, this.draggedClass); } } } 这是我们的 dragDective,当然代码没有写全，我们只是列一个思路，首先我们可以使用angular-cli直接生成一个指令模版： ng g d xxx //xxx代表指令的名称 生成之后直接就有了selector，里面就是我们指令的名称，然后我们通过类似于.net的语法来获取下这个指令是true还是false： @Input(&apos;app-draggable&apos;) set isDraggable(val: boolean) { this._isDraggable = val; this.rd.setAttribute(this.el.nativeElement, &apos;draggable&apos;, `${val}`); } get isDraggable() { return this._isDraggable; } 这样我们就可以在我们的组件模板中加上这个指令了： &lt;app-task-list class=&quot;list-container&quot; app-droppable [app-draggable]=&quot;true&quot;//这就是指令的位置 (dropped)=&quot;handleMove($event,list)&quot; *ngFor=&quot;let list of lists&quot; &gt; 如此一来可以说是完成了添加，但是我们的指令啥都没有做，所以也就不会有效果，我们可以发现的是，我们的指令代码中出现很多@HostListener，没错，这就是我们监听鼠标事件的方法，通过响应事件来进行一系列样式的添加： @HostListener(&apos;dragstart&apos;, [&apos;$event&apos;]) onDragStart(ev: Event) { if (this.el.nativeElement === ev.target) { this.rd.addClass(this.el.nativeElement, this.draggedClass); } } @HostListener(&apos;dragend&apos;, [&apos;$event&apos;]) onDragEnd(ev: Event) { if (this.el.nativeElement === ev.target) { this.rd.removeClass(this.el.nativeElement, this.draggedClass); } } 那这个其中的draggedClass就是我们自己定义的样式，我们的鼠标进行拖拽的时候就能显示我们的样式。 以上只是项目中的一小块代码，感兴趣的可以去我的Github上看看哦：这是地址","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"material中怎么让主题覆盖dialog这一类组件","date":"2018-09-26T14:13:15.000Z","path":"2018/09/26/material中怎么让主题覆盖dialog这一类组件/","text":"在material中很大一个特色就是我们可以根据自己的需求自定义自己想要的主题，我就大概讲讲怎么自定义吧，因为我的重点是怎么让主题覆盖一些组件。 怎么自定义主题呢？我自己写了一个theme.scss文件，代码如下： 首先导入 mat-core（） sass 混合。这包括多个组件使用的所有常见样式。这应该只在你的应用程序中包含一次。如果这个mixin包含多次，你的应用程序将最终得到这些常用样式的多个副本。将主题数据结构定义为多个调色板的组合。可以使用 mat-light-theme 方法或 mat-dark-theme 方法创建此对象。然后将方法的输出传递给 angular-material-theme 混合，它将输出主题的所有对应样式。 然后我们需要在style.scss全局样式下引入这个文件，这样就可以自由使用了。 但是我们发现，例如dialog这些组件无法渲染自定义的主题，我们该怎么解决呢？其实也很简单，我们只需要在最外层的容器上加上一句话： 这样之后就大功告成了，我们原先的是背景有黑夜主题，但是dialog没有主题，然后就成功的给dialog也加上了主题。 上面是没有主题的样子，背景是黑的，dialog是白的，不协调。接下来看看完成之后的; 但是这样做我们在项目一开始就定死了我们只能用黑夜模式，我们需要在点击一个按钮的时候切换颜色怎么办呢，好说，我们把它放到跟组件里面的一个按钮事件里不就行了，代码如下: 这下是真的彻底完成了哦！","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"},{"name":"Material","slug":"Material","permalink":"http://tanyibing.com/tags/Material/"}]},{"title":"material中怎么使用自己下载的svg图标","date":"2018-09-21T06:37:43.000Z","path":"2018/09/21/material中怎么使用自己下载的svg图标/","text":"material是谷歌开发的很好看的一个框架，我就在我最近的项目中使用了这个框架，喜欢的童鞋可以去他们的官网看看：material.io 开发过程中我发现他们的图标库咩有阿里的那么丰富，于是想用自己下载的，那我该怎么操作呢？，下面介绍一下流程。 为了方便，我没有在需要的模块中反复的添加，而是创建了一个svg.util.ts,并选择在core module中一次性加载，省掉很多事。首先我需要在svg.util.ts中引入必须的模块： 这两个模块是核心模块，一个负责注册新加入的svg图标，一个是为了防止XSS漏洞的将URL设为信任对象。 接下来就将我们的图标都注册进去： 这样子差不多快可以了，但我们还需要在core module中引入HttpClient模块（这一步必须要，否则会报错），因为需要依赖它，最后在core module的构造函数中调用就行了。 然后我们就能光明正大的使用啦： &lt;mat-icon svgIcon=&apos;注册的名称&apos;&gt;&lt;/mat-icon&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"},{"name":"Material","slug":"Material","permalink":"http://tanyibing.com/tags/Material/"}]},{"title":"尝鲜Ionic4中点击跳转新页面","date":"2018-09-20T03:15:48.000Z","path":"2018/09/20/尝鲜Ionic4中点击跳转新页面/","text":"Ionic已经出了第四版了，不过还在测试阶段，那我们先来玩玩吧。 首先我们用命令行新建一个页面news，我们发现，这一版中，新建的page被直接加入到了路由当中： 也就是说我们可以直接使用路由跳转，接下来我们在home页面中加一个按钮，并且给它个点击事件： 此时我们到home.page.ts中去定义这个goNews()方法。我们手下需要在构造函数里面注册NavController，但是我接下来发现，这个类的push方法没定义，那我们去看下源码： 果然是没有push方法了，但是有个navigateForward方法好像有那么点意思，试试吧： 果然如此，没问题，现在我们就能够跳转啦。 官网文档现在还不是写的很清楚，想要正常使用还是要查查源码。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"},{"name":"Ionic4","slug":"Ionic4","permalink":"http://tanyibing.com/tags/Ionic4/"}]},{"title":"exports和module.exports的区别","date":"2018-09-19T01:35:45.000Z","path":"2018/09/19/exports和module-exports的区别/","text":"exports和moduls.exports的区别每一个node.js执行文件，都会自动创建一个module对象，同时，module对象会创建一个叫exports的属性，初始化的值是{}： module.exports = {}; 这时我们使用exports看看： math.js exports.add=function(arg1,arg2){ return arg1+arg2; }; exports.minus=function(arg1,arg2){ return arg1-arg2; }; console.log(module); test.js var math=require(&apos;./math.js&apos;); console.log(&apos;math:&apos;+math); console.log(math.add(3,4)); console.log(math.minus(5,3)); 控制台中信息:module: { id: &apos;/home/chander-zhang/NodeJS/test/math.js&apos;, exports: { add: [Function], minus: [Function] }, parent: { ... }, filename: &apos;/home/chander-zhang/NodeJS/test/math.js&apos;, loaded: false, children: [], paths: [ &apos;/home/chander-zhang/NodeJS/test/node_modules&apos;, &apos;/home/chander-zhang/NodeJS/node_modules&apos;, &apos;/home/chander-zhang/node_modules&apos;, &apos;/home/node_modules&apos;, &apos;/node_modules&apos; ] } math: [object Object] 这时的math是个对象，当我们使用module.exports时会怎么样： math.js exports.add=function(arg1,arg2){ return arg1+arg2; }; minus=function(arg1,arg2){ return arg1-arg2; }; module.exports=minus; console.log(module); test.js var math=require(&apos;./math.js&apos;); console.log(&apos;math:&apos;+math); //console.log(math.add(3,4)); console.log(math.minus(5,3));//相当于执行了 minus(5,3) 控制台中打印出：、module: { id: &apos;/home/chander-zhang/NodeJS/test/math.js&apos;, exports: [Function], parent: { ... }, filename: &apos;/home/chander-zhang/NodeJS/test/math.js&apos;, loaded: false, children: [], paths: [ &apos;/home/chander-zhang/NodeJS/test/node_modules&apos;, &apos;/home/chander-zhang/NodeJS/node_modules&apos;, &apos;/home/chander-zhang/node_modules&apos;, &apos;/home/node_modules&apos;, &apos;/node_modules&apos; ] } math: function (arg1,arg2){ return arg1-arg2; } 如果使用math.add()或math.minus()将会出错,因为此时math是一个函数. 即便module中出现了exports.add,由于为module.exports赋了值,也不能使用math.add().因为exports是指向module.exports的引用，而require（）返回的是module.exports而不是exports，当我们自己定义module.exports时就会覆盖自动生成的moudle.exports。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://tanyibing.com/tags/Node/"}]},{"title":"javascript异步（四）","date":"2018-09-18T02:56:41.000Z","path":"2018/09/18/javascript异步（四）/","text":"JavaScript异步（四）————async &amp; await前面已经介绍了Generator，我的唯一感觉就是————学习成本真特喵的高，我们今天还要看一个异步的终极解决方案————async-await，这就是ES7自己参照Generator封装的，其实更像是Generator的语法糖。 ES7中的async-awaitGenerator和async-await对比我们先来一段Generator的异步处理代码： co(function* () { const r1 = yield readFilePromise(&apos;some1.json&apos;) console.log(r1) // 打印第 1 个文件内容 const r2 = yield readFilePromise(&apos;some2.json&apos;) console.log(r2) // 打印第 2 个文件内容 }) 接着看看使用async-await，对比一下; const readFilePromise = Q.denodeify(fs.readFile) // 定义 async 函数 const readFileAsync = async function () { const f1 = await readFilePromise(&apos;data1.json&apos;) const f2 = await readFilePromise(&apos;data2.json&apos;) console.log(&apos;data1.json&apos;, f1.toString()) console.log(&apos;data2.json&apos;, f2.toString()) return &apos;done&apos; // 先忽略，后面会讲到 } // 执行 const result = readFileAsync() 我们可以比较看出，async function代替了function* ，await代替了yield，而且使用async-await不在用co这个第三方库了，直接执行即可。 使用async-await的差异第一，await后面不能再跟thunk函数，而必须跟一个Promise对象（因此，Promise才是异步的终极解决方案和未来）。跟其他类型的数据也OK，但是会直接同步执行，而不是异步。 第二，执行const result = readFileAsync()返回的是个Promise对象，而且上面代码中的return ‘done’会直接被下面的then函数接收到 result.then(data =&gt; { console.log(data) // done }) 第三，从代码的易读性来将，async-await更加易读简介，也更加符合代码的语意。而且还不用引用第三方库，也无需学习Generator那一堆东西，使用成本非常低。 因此，如果 ES7 正式发布了之后，强烈推荐使用async-await。但是现在尚未正式发布，从稳定性考虑，还是Generator更好一些。 异步操作代码的演变历程最后再来感受下从callback到async-await的历程吧。 callback方式fs.readFile(&apos;some1.json&apos;, (err, data) =&gt; { fs.readFile(&apos;some2.json&apos;, (err, data) =&gt; { fs.readFile(&apos;some3.json&apos;, (err, data) =&gt; { fs.readFile(&apos;some4.json&apos;, (err, data) =&gt; { }) }) }) }) Promise方式readFilePromise(&apos;some1.json&apos;).then(data =&gt; { return readFilePromise(&apos;some2.json&apos;) }).then(data =&gt; { return readFilePromise(&apos;some3.json&apos;) }).then(data =&gt; { return readFilePromise(&apos;some4.json&apos;) }) Generator方式co(function* () { const r1 = yield readFilePromise(&apos;some1.json&apos;) const r2 = yield readFilePromise(&apos;some2.json&apos;) const r3 = yield readFilePromise(&apos;some3.json&apos;) const r4 = yield readFilePromise(&apos;some4.json&apos;) }) async-await方式const readFileAsync = async function () { const f1 = await readFilePromise(&apos;data1.json&apos;) const f2 = await readFilePromise(&apos;data2.json&apos;) const f3 = await readFilePromise(&apos;data3.json&apos;) const f4 = await readFilePromise(&apos;data4.json&apos;) } 到这基本就完了，如果有看到好文章以后再补充，js异步探索的任务算是结束了。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"}]},{"title":"javascript异步（三）","date":"2018-09-18T01:18:08.000Z","path":"2018/09/18/javascript异步（三）/","text":"JavaScript异步（三）————Generator上次已经介绍过一点Generator对象的知识了，这次就继续说说Generator的应用吧。 Generator的应用使用next和yield传递参数我们已经知道，yield具有返回数据的功能，如下代码。yield后面的数据被返回，存放到返回结果中的value属性中。这算是一个方向的参数传递。 function* G() { yield 100 } const g = G() console.log( g.next() ) // {value: 100, done: false} 还有另一个方向的参数传递，就是next向yield传递，如下： function* G() { const a = yield 100 console.log(&apos;a&apos;, a) // a aaa const b = yield 200 console.log(&apos;b&apos;, b) // b bbb const c = yield 300 console.log(&apos;c&apos;, c) // c ccc } const g = G() g.next() // value: 100, done: false g.next(&apos;aaa&apos;) // value: 200, done: false g.next(&apos;bbb&apos;) // value: 300, done: false g.next(&apos;ccc&apos;) // value: undefined, done: true 我们看看上面代码的执行过程： 执行第一个g.next()时，未传递任何参数，返回的{value: 100, done: false}，这个应该没有疑问 执行第二个g.next(‘aaa’)时，传递的参数是’aaa’，这个’aaa’就会被赋值到G内部的a标量中，然后执行console.log(‘a’, a)打印出来，最后返回{value: 200, done: false} 执行第三个、第四个时，道理都是完全一样的，大家自己捋一捋。 有一个要点需要注意，就g.next(‘aaa’)是将’aaa’传递给上一个已经执行完了的yield语句前面的变量，而不是即将执行的yield前面的变量。 for…of的应用for…of是Iterator对象的一个经典操作，我们使用一个斐波那契数列来看一看： function* fibonacci() { let [prev, curr] = [0, 1] for (;;) { [prev, curr] = [curr, prev + curr] // 将中间值通过 yield 返回，并且保留函数执行的状态，因此可以非常简单的实现 fibonacci yield curr } } for (let n of fibonacci()) { if (n &gt; 1000) { break } console.log(n) } 这样我们就能找到1000里面的斐波那契数列了。 yield*嵌套Generator如果我们有两个Generator，我们想在第一个中包含第二个： function* G1() { yield &apos;a&apos; yield* G2() // 使用 yield* 执行 G2() yield &apos;b&apos; } function* G2() { yield &apos;x&apos; yield &apos;y&apos; } for (let item of G1()) { console.log(item) } 之前学过的yield后面会接一个普通的 JS 对象，而yield 后面会接一个Generator，而且会把它其中的yield按照规则来一步一步执行。如果有多个Generator串联使用的话（例如Koa源码中），用yield来操作非常方便。 Generator中的this对于以下这种写法，大家可能会和构造函数创建对象的写法产生混淆，这里一定要注意 —— Generator 不是函数，更不是构造函数 function* G() {} const g = G() 而以下这种写法，更加不会成功。只有构造函数才会这么用，构造函数返回的是this，而Generator返回的是一个Iterator对象。完全是两码事，千万不要搞混了。 function* G() { this.a = 10 } const g = G() console.log(g.a) // 报错 Thunk函数为什么要说说Thunk函数呢，因为它和Generator处理异步操作还是有关系的，我们先看看。 普通异步函数fs.readFile(&apos;data1.json&apos;, &apos;utf-8&apos;, (err, data) =&gt; { // 获取文件内容 }) 这个普通的node读取文件的函数传递了三个函数，接下来我们进行一点改造。 封装成Thunk函数const thunk = function (fileName, codeType) { // 返回一个只接受 callback 参数的函数 return function (callback) { fs.readFile(fileName, codeType, callback) } } const readFileThunk = thunk(&apos;data1.json&apos;, &apos;utf-8&apos;) readFileThunk((err, data) =&gt; { // 获取文件内容 }) 从上面的Thunk函数可以看出，执行const readFileThunk = thunk(‘data1.json’, ‘utf-8’)返回的其实是一个函数，readFileThunk这个函数，只接受一个参数，而且这个参数是一个callback函数。 使用thunkify库上面的代码封装使我们自己做的，但我们不需要每遇到一个情况就自己做，我们可以直接使用第三方的thunkify就可以了。 onst thunk = thunkify(fs.readFile) const readFileThunk = thunk(&apos;data1.json&apos;, &apos;utf-8&apos;) readFileThunk((err, data) =&gt; { // 获取文件内容 }) Generator异步操作上次我们只是大概的讲了讲，接下来我们详细看看Generator是如何进行异步操作的 Generator中使用Thunk直接看代码吧 const readFileThunk = thunkify(fs.readFile) const gen = function* () { const r1 = yield readFileThunk(&apos;data1.json&apos;) console.log(r1) const r2 = yield readFileThunk(&apos;data2.json&apos;) console.log(r2) } 挨个读取两个文件的内容接着上面的代码继续写： const g = gen() // 试着打印 g.next() 这里一定要明白 value 是一个 thunk函数 ，否则下面的代码你都看不懂 // console.log( g.next() ) // g.next() 返回 {{ value: thunk函数, done: false }} // 下一行中，g.next().value 是一个 thunk 函数，它需要一个 callback 函数作为参数传递进去 g.next().value((err, data1) =&gt; { // 这里的 data1 获取的就是第一个文件的内容。下一行中，g.next(data1) 可以将数据传递给上面的 r1 变量，此前已经讲过这种参数传递的形式 // 下一行中，g.next(data1).value 又是一个 thunk 函数，它又需要一个 callback 函数作为参数传递进去 g.next(data1).value((err, data2) =&gt; { // 这里的 data2 获取的是第二个文件的内容，通过 g.next(data2) 将数据传递个上面的 r2 变量 g.next(data2) }) }) 仔细看望上面的注释，也许会有中恍然大悟的感觉，原来是这样子把异步写成同步的感觉。 自驱动流程接下来我们做一个自驱动的流程，定义好Generator的代码之后，就让他自动执行： // 自动流程管理的函数 function run(generator) { const g = generator() function next(err, data) { const result = g.next(data) // 返回 { value: thunk函数, done: ... } if (result.done) { // result.done 表示是否结束，如果结束了那就 return 作罢 return } result.value(next) // result.value 是一个 thunk 函数，需要一个 callback 函数作为参数，而 next 就是一个 callback 形式的函数 } next() // 手动执行以启动第一次 next } // 定义 Generator const readFileThunk = thunkify(fs.readFile) const gen = function* () { const r1 = yield readFileThunk(&apos;data1.json&apos;) console.log(r1.toString()) const r2 = yield readFileThunk(&apos;data2.json&apos;) console.log(r2.toString()) } // 启动执行 run(gen) 我们简单分析下： 最后一行run(gen)之后，进入run函数内部执行 先const g = generator()创建Generator实例，然后定义一个next方法，并且立即执行next() 注意这个next函数的参数是err, data两个，和我们fs.readFile用到的callback函数形式完全一样 第一次执行next时，会执行const result = g.next(data)，而g.next(data)返回的是{ value: thunk函数, done: … }，value是一个thunk函数，done表示是否结束 如果done: true，那就直接return了，否则继续进行 result.value是一个thunk函数，需要接受一个callback函数作为参数传递进去，因此正好把next给传递进去，让next一直被执行下去 co库这个流程我们也可以使用第三方的库co，用Generator的工程师肯定都要用co，两者天生一对。 // 定义 Generator const readFileThunk = thunkify(fs.readFile) const gen = function* () { const r1 = yield readFileThunk(&apos;data1.json&apos;) console.log(r1.toString()) const r2 = yield readFileThunk(&apos;data2.json&apos;) console.log(r2.toString()) } const c = co(gen) 而且const c = co(gen)返回的是一个Promise对象，可以接着这么写 c.then(data =&gt; { console.log(&apos;结束&apos;) }) Koa中使用GeneratorKoa第一版中大量使用了Generator，接下来我们去看看怎么使用的。 Koa中如何使用Generatorkoa 是一个 web 框架，处理 http 请求，但是这里我们不去管它如何处理 http 请求，而是直接关注它使用Genertor的部分————中间件。例如，我们现在要用 3 个Generator输出12345，我们如下代码这么写。 let info = &apos;&apos; function* g1() { info += &apos;1&apos; // 拼接 1 yield* g2() // 拼接 234 info += &apos;5&apos; // 拼接 5 } function* g2() { info += &apos;2&apos; // 拼接 2 yield* g3() // 拼接 3 info += &apos;4&apos; // 拼接 4 } function* g3() { info += &apos;3&apos; // 拼接 3 } var g = g1() g.next() console.log(info) // 12345 但是如果用 koa 的 中间件 的思路来做，就需要如下这么写。 app.use(function *(next){ this.body = &apos;1&apos;; yield next; this.body += &apos;5&apos;; console.log(this.body); }); app.use(function *(next){ this.body += &apos;2&apos;; yield next; this.body += &apos;4&apos;; }); app.use(function *(next){ this.body += &apos;3&apos;; }); 我们需要注意几点： app.use()中传入的每一个Generator就是一个 中间件，中间件按照传入的顺序排列，顺序不能乱 每个中间件内部，next表示下一个中间件。yield next就是先将程序暂停，先去执行下一个中间件，等next被执行完之后，再回过头来执行当前代码的下一行。因此，koa 的中间件执行顺序是一种洋葱圈模型，不过这里看不懂也没问题。 每个中间件内部，this可以共享变量。即第一个中间件改变了this的属性，在第二个中间件中可以看到效果。 Koa的这种机制如何实现的我们封住个简单的Koa： class MyKoa extends Object { constructor(props) { super(props); // 存储所有的中间件 this.middlewares = [] } // 注入中间件 use (generator) { this.middlewares.push(generator) } // 执行中间件 listen () { this._run() } _run () { const ctx = this const middlewares = ctx.middlewares co(function* () { let prev = null let i = middlewares.length //从最后一个中间件到第一个中间件的顺序开始遍历 while (i--) { // ctx 作为函数执行时的 this 才能保证多个中间件中数据的共享 //prev 将前面一个中间件传递给当前中间件，才使得中间件里面的 next 指向下一个中间件 prev = middlewares[i].call(ctx, prev); } //执行第一个中间件 yield prev; }) } } 如何使用呢： var app = new MyKoa(); app.use(function *(next){ this.body = &apos;1&apos;; yield next; this.body += &apos;5&apos;; console.log(this.body); // 12345 }); app.use(function *(next){ this.body += &apos;2&apos;; yield next; this.body += &apos;4&apos;; }); app.use(function *(next){ this.body += &apos;3&apos;; }); app.listen();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"}]},{"title":"javascript异步（二）","date":"2018-09-17T06:40:16.000Z","path":"2018/09/17/javascript异步（二）/","text":"JavaScript异步（二）————PromiseES6中的Promise写一个传统的异步操作我们先写一段异步的代码，然后用promise来封装一下： var wait = function () { var task = function () { console.log(&apos;执行完成&apos;) } setTimeout(task, 2000) } wait() 用Promise进行封装const wait = function () { // 定义一个 promise 对象 const promise = new Promise((resolve, reject) =&gt; { // 将之前的异步操作，包括到这个 new Promise 函数之内 const task = function () { console.log(&apos;执行完成&apos;) resolve() // callback 中去执行 resolve 或者 reject } setTimeout(task, 2000) }) // 返回 promise 对象 return promise } 我们首先将之前传统的异步方法用new Promise((resolve, reject) =&gt; {...})包装起来，然后return就行了。异步操作的内部，在callback中执行resolve()（表明成功了，失败的话执行reject）。 我们接下来怎么处理返回的数据呢： const w = wait() w.then(() =&gt; { console.log(&apos;ok 1&apos;) }, () =&gt; { console.log(&apos;err 1&apos;) }).then(() =&gt; { console.log(&apos;ok 2&apos;) }, () =&gt; { console.log(&apos;err 2&apos;) }) 我们调用then方法，这个方法接收两个参数，第一个在成功时（触发resolve）执行，第二个在失败时(触发reject)时执行。而且，then还可以进行链式操作。 以上就是ES6中Promise的基本使用方法，接下来看一些Promise的常见用法吧。 Promise在ES6中的常见用法为了方便使用，我们首先封装个Promise，为后面使用： const fs = require(&apos;fs&apos;) const path = require(&apos;path&apos;) // 后面获取文件路径时候会用到 const readFilePromise = function (fileName) { return new Promise((resolve, reject) =&gt; { fs.readFile(fileName, (err, data) =&gt; { if (err) { reject(err) // 注意，这里执行 reject 是传递了参数，后面会有地方接收到这个参数 } else { resolve(data.toString()) // 注意，这里执行 resolve 时传递了参数，后面会有地方接收到这个参数 } }) }) } 参数传递我们要使用上面封装的readFilePromise读取一个 json 文件../data/data2.json，这个文件内容非常简单：{“a”:100, “b”:200} 先将文件内容打印出来，代码如下。大家需要注意，readFilePromise函数中，执行resolve(data.toString())传递的参数内容，会被下面代码中的data参数所接收到。 const fullFileName = path.resolve(__dirname, &apos;../data/data2.json&apos;) const result = readFilePromise(fullFileName) result.then(data =&gt; { console.log(data) }) 参数传递就是在异步里面通过resolve来传递至，然后就会被第一个then处理时接收到，而且通过then的链式操作可以继续将处理后的值传递下去。 异常捕获我们知道then会接收两个参数（函数），第一个参数会在执行resolve之后触发（还能传递参数），第二个参数会在执行reject之后触发（其实也可以传递参数，和resolve传递参数一样），但是上面的例子中，我们没有用到then的第二个参数。这是为何呢 ———— 因为不建议这么用。 对于Promise中的异常处理，我们建议用catch方法，而不是then的第二个参数。请看下面的代码，以及注释。 const fullFileName = path.resolve(__dirname, &apos;../data/data2.json&apos;) const result = readFilePromise(fullFileName) result.then(data =&gt; { console.log(data) return JSON.parse(data).a }).then(a =&gt; { console.log(a) ).catch(err =&gt; { console.log(err.stack) // 这里的 catch 就能捕获 readFilePromise 中触发的 reject ，而且能接收 reject 传递的参数 }) 在若干个then串联之后，我们一般会在最后跟一个.catch来捕获异常，而且执行reject时传递的参数也会在catch中获取到。这样做的好处是： 让程序看起来更加简洁，是一个串联的关系，没有分支（如果用then的两个参数，就会出现分支，影响阅读） 更像是try - catch的样子，更易理解 串联多个异步操作如果现在有一个需求：先读取data2.json的内容，当成功之后，再去读取data1.json。这样的需求，如果用传统的callback去实现，会变得很麻烦。而且，现在只是两个文件，如果是十几个文件这样做，写出来的代码就没法看了（臭名昭著的callback-hell）。但是用刚刚学到的Promise就可以轻松胜任这项工作： const fullFileName2 = path.resolve(__dirname, &apos;../data/data2.json&apos;) const result2 = readFilePromise(fullFileName2) const fullFileName1 = path.resolve(__dirname, &apos;../data/data1.json&apos;) const result1 = readFilePromise(fullFileName1) result2.then(data =&gt; { console.log(&apos;data2.json&apos;, data) return result1 // 此处只需返回读取 data1.json 的 Promise 即可 }).then(data =&gt; { console.log(&apos;data1.json&apos;, data) // data 即可接收到 data1.json 的内容 }) 上文“参数传递”提到过，如果then有链式操作，前面步骤返回的值，会被后面的步骤获取到。但是，如果前面步骤返回值是一个Promise的话，情况就不一样了。如果前面返回的是Promise对象，后面的then将会被当做这个返回的Promise的第一个then来对待。 Promise.all &amp; Promise.race现在我需要一起读取data1.json和data2.json这两个文件，等待它们全部都被读取完，再做下一步的操作。此时需要用到Promise.all： // Promise.all 接收一个包含多个 promise 对象的数组 Promise.all([result1, result2]).then(datas =&gt; { // 接收到的 datas 是一个数组，依次包含了多个 promise 返回的内容 console.log(datas[0]) console.log(datas[1]) }) 读取两个文件data1.json和data2.json，现在我需要一起读取这两个文件，但是只要有一个已经读取了，就可以进行下一步的操作。此时需要用到Promise.race： // Promise.race 接收一个包含多个 promise 对象的数组 Promise.race([result1, result2]).then(data =&gt; { // data 即最先执行完成的 promise 的返回值 console.log(data) })","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"}]},{"title":"node中踩的坑（不定时更新）","date":"2018-09-14T09:02:35.000Z","path":"2018/09/14/node中踩的坑（不定时更新）/","text":"2018-9-14问题在Koa中想要使用art-template这个模板引擎，但是使用之后在渲染模板的时候一直报下面的错： 分析报的错说我的路径必须为一个字符串，我重新检查后，发现并不存在语法错误呀，果断去度娘看看，试了几个方法解决不了我的问题，但是反馈最多的一个方法就是node版本和其他的不兼容。我靠！这要重搞工作量有点大，果断换个模板引擎吧。 解决方法最后回去官网看一看，发现有art-template和koa-art-template之分，但是配置好像没啥区别啊。把引入的模块改成koa-art-template，再试试，成了！什么鬼！不管了，问题暂时是解决了。 另外附上项目的地址：https://github.com/TanYiBing/cms_demo","tags":[{"name":"Node","slug":"Node","permalink":"http://tanyibing.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://tanyibing.com/tags/Koa/"}]},{"title":"javascript异步（一）","date":"2018-09-14T08:06:01.000Z","path":"2018/09/14/javascript异步（一）/","text":"JavaScript异步（一）前言昨天刚立了个flag，而我这个人向来都是说话不算话的（手动滑稽），为了防止自己半途而废，所以今天先来开个头，开了头就不好回头了。 异步和单线程有什么关系？1.为啥是单线程JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 2.啥是异步我们先看一段代码： var i, t = Date.now(); for (i = 0; i &lt; 100000000; i++) {} console.log(Date.now() - t) // 250 上面的程序花费 250ms 的时间执行完成，执行过程中就会有卡顿，其他的事儿就先撂一边不管了。 执行程序这样没有问题，但是对于 JS 最初使用的环境 ———— 浏览器客户端 ———— 就不一样了。因此在浏览器端运行的js，可能会有大量的网络请求，而一个网络资源啥时候返回，这个时间是不可预估的。这种情况也要傻傻的等着、卡顿着、啥都不做吗？———— 那肯定不行。 因此，JS 对于这种场景就设计了异步 ———— 即，发起一个网络请求，就先不管这边了，先干其他事儿，网络请求啥时候返回结果，到时候再说。这样就能保证一个网页的流程运行。 3.事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 4.使用回调函数来进行异步操作举个栗子： var ajax = $.ajax({ url: &apos;/data/data1.json&apos;, success: function () { console.log(&apos;success&apos;) } }) 上面这个ajax操作就是一个异步操作，第二个参数就是一个callback，我们先发个消息出去取一些数据，当然不会立即就能取到，那我们也不闲着，先去干别的，等拿到了通知我们，我们再执行callback进行数据操作。实现异步的最核心原理，就是将callback作为参数传递给异步执行函数，当有结果返回之后再触发 callback执行，就是如此简单！ 5.常用的异步操作开发中我们比较常用的异步操作有; 网络请求，如 ajax、http IO操作，如 readFile、readDir 定时函数：如 setTimeout、setInterval Event Loop这一部分让我写肯定显得业余，还是去看看阮一峰老师怎么说吧：JavaScript 运行机制详解：再谈Event Loop 事件绑定算不算异步呢？我们看一个事件绑定的操作： $btn.on(&apos;click&apos;, function (e) { console.log(&apos;你点击了按钮&apos;) }) 这个写法和我们上面的异步操作是不是一样，都定义了callback，那事件绑定算不算异步操作呢？如果你认真看了阮一峰老师的那篇文章，你就会发现，其实这也是异步操作。为什么我会这么问呢？ 因为它们之间还有有些不同之处的： event-loop 执行时，调用的源不一样。异步操作是系统自动调用，无论是setTimeout时间到了还是$.ajax请求返回了，系统会自动调用。而事件绑定就需要用户手动触发。 从设计上来将，事件绑定有着明显的“订阅-发布”的设计模式，而异步操作却没有。 但是我们从这张图上又可以发现,我们的事件包括了Network和我们的一些鼠标操作，这些都被认为是异步的。其实仔细想想也对，网络请求其实也相当于订阅和发布啊！ 今天的就到这吧！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"}]},{"title":"封装个Koa","date":"2018-09-13T08:39:37.000Z","path":"2018/09/13/封装个Koa/","text":"想了解下Koa是怎么个骚操作，之前使用的是Koa2，里面是async和await，用起来爽歪歪。不过，async和await是ES7里面的东东，还是有必要看一下koa的第一代的，发现里面的中间件是Generator，其实我对这个也不是很理解，ES6里面新增加的，一下子有点难接受，今天就提上日程，看一看怎么搞，自己封装个Koa试试！ 想要真正搞懂这个Generator还是比较烦，我自己感觉整个ES6的主要部分应该就是这个Generator了，相知带它怎么回事先要知道Iterator、然后再看Generator，但是想和异步扯上关系你还要看Chunk函数，还要看看co库，当然啦，Promise肯定要知道，所以感觉这也不是个简单的东西，门道多着呢。 不说废话了，上代码吧，封装个MyKoa： class MyKoa extends Object { constructor(props) { super(props); // 存储所有的中间件 this.middlewares = [] } // 注入中间件 use (generator) { this.middlewares.push(generator) } // 执行中间件 listen () { this._run() } _run () { const ctx = this; const middlewares = ctx.middlewares; co(function* () { let prev = null let i = middlewares.length //从最后一个中间件到第一个中间件的顺序开始遍历 while (i--) { // ctx 作为函数执行时的 this 才能保证多个中间件中数据的共享 //prev 将前面一个中间件传递给当前中间件，才使得中间件里面的 next 指向下一个中间件 prev = middlewares[i].call(ctx, prev); } //执行第一个中间件 yield prev; }) } } 然后可以试验下效果： var app = new MyKoa(); app.use(function *(next){ this.body = &apos;1&apos;; yield next; this.body += &apos;5&apos;; console.log(this.body); // 12345 }); app.use(function *(next){ this.body += &apos;2&apos;; yield next; this.body += &apos;4&apos;; }); app.use(function *(next){ this.body += &apos;3&apos;; }); app.listen(); 其实Generator和我们的回调处理异步的callback根本没有一点关系，它的本质是‘暂停’，并将执行权转移，我们只是给它穿上了一层又一层的外套，强行让它和异步‘发生关系’。 PS：立个flag，2018年过年之前找个机会，我一定彻彻底底研究次js中的异步！！！","tags":[{"name":"Node","slug":"Node","permalink":"http://tanyibing.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://tanyibing.com/tags/Koa/"}]},{"title":"Jade怎么玩","date":"2018-09-13T02:24:18.000Z","path":"2018/09/13/Jade怎么玩/","text":"前端想要用模板，那就看看Jade吧，打开我们的Jade官网，上去看看呢，结果发现官网真的很水，水在哪呢？特喵的，给的代码没有一个注意缩进的，这也就导致后面很多模板使用jade命令时报错，有失水准啊！ 好在咋们国人搞的还是比较靠谱：点这可以学习Jade 你不会真以为我要写个技术博客吧，我只是来吐槽下，Jade很简单，自己去学吧，几分钟就会了。","tags":[{"name":"Jade","slug":"Jade","permalink":"http://tanyibing.com/tags/Jade/"}]},{"title":"Generator函数","date":"2018-09-12T08:09:54.000Z","path":"2018/09/12/Generator函数/","text":"Generator函数昨天的Promise对象就是一种异步编程解决方案，今天再看一种方案，这就是Generator函数。网上有很多关于Generator的介绍，例如： Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator的创建接下来我们看一下怎么定义一个Generator函数： function* helloWorldGenerator() { yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;; } var hw = helloWorldGenerator(); 我们发现在function关键字和函数名称之间有个星号，这表示这是一个Generator函数。但这样还不行，进入函数我们发现使用了yield表达式，定义了不同的内部状态(yield在英语中就是“产生”的意思)。这样我们一共定义了三个状态：hello、word和一个return语句。 Generator的调用Generator函数返回的是一个遍历器对象，也就是说我们需要调用next方法来遍历函数中的状态： hw.next() // { value: &apos;hello&apos;, done: false } hw.next() / { value: &apos;world&apos;, done: false } hw.next() // { value: &apos;ending&apos;, done: true } hw.next() / { value: undefined, done: true } 上面一共运行了四次next方法。 第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 Generator函数的作用这个东西看上去好像没啥用，那么它到底能干点啥呢？ 把异步回调变成‘同步’代码例如我们写个ajax代码： ajax(&apos;http://url-1&apos;, data1, function (err, result) { if (err) { return handle(err); } ajax(&apos;http://url-2&apos;, data2, function (err, result) { if (err) { return handle(err); } ajax(&apos;http://url-3&apos;, data3, function (err, result) { if (err) { return handle(err); } return success(result); }); }); }); 这个代码简直不想看，那么我们可以用Generator来改造下： try { r1 = yield ajax(&apos;http://url-1&apos;, data1); r2 = yield ajax(&apos;http://url-2&apos;, data2); r3 = yield ajax(&apos;http://url-3&apos;, data3); success(r3); } catch (err) { handle(err); } 这样看上去好多了，但不是真正的同步代码，至少看上去很像。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://tanyibing.com/tags/ECMAScript6/"}]},{"title":"Promise对象","date":"2018-09-11T08:07:08.000Z","path":"2018/09/11/Promise对象/","text":"Promise对象Promise的介绍Promise在ECMAScript6中被正式写进了语言标准，这是异步编程的一种解决方案，较之传统的函数回调和事件，Promise来得更加强大。Promise被理解成一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise有三个状态，分别是： pending：进行中 fulfilled：已成功 rejected：已失败 这三个状态是根据异步操作的结果来决定的，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。这三个状态一旦确定就不会在改变了。 Promise的使用创建怎么创建一个Promise实例呢： const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); 其中两个方法，resolve用来处理异步操作成功的结果，将其结果传递出去，在后面的then方法中去接受，reject用来处理操作失败的结果并传递出去，也可用then方法接收。 then方法的使用Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数： promise.then(function(value) { // success }, function(error) { // failure }); 其中第二个函数是可选的。这两个函数就是用来接收上面传出来的结果的。而且需要注意的是then方法返回是一个新的Promise，也就是说我们可以进行链式编程。 Promise执行顺序Promise在新建之后就会立即执行，举个例子： let promise = new Promise(function(resolve, reject) { console.log(&apos;a&apos;); resolve(); }); promise.then(function() { console.log(&apos;b&apos;); }); console.log(&apos;c&apos;); // a // c // b 上面的代码先输出a，因为Promise新建之后就立即执行，then方法在当前脚本所有同步任务执行完才执行，最后才会输出b。 Promise和其他技术昨天我看了RxJS，发现这两货好像有点像，一个是把所有数据都变成流进行操作。一个是一直返回Promise，通过then方法一直链式操作，那就比较一下吧。 操作 可观察对象 承诺 创建 new Observable((observer) =&gt; {observer.next(123);}); new Promise((resolve, reject) =&gt; {resolve(123);}); 转换 obs.map((value) =&gt; value * 2 ); promise.then((value) =&gt; value * 2); 订阅 sub = obs.subscribe((value) =&gt; {console.log(value)}); promise.then((value) =&gt; {console.log(value);}); 取消订阅 sub.unsubscribe(); 承诺被解析时隐式完成。 Promise的应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 const preloadImage = function (path) { return new Promise(function (resolve, reject) { const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); };","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://tanyibing.com/tags/ECMAScript6/"}]},{"title":"初入RxJS","date":"2018-09-10T03:21:19.000Z","path":"2018/09/10/初入RxJS/","text":"RxJS简介刚开始接触angular的时候就发现，RxJS在angular中是使用的最多的框架。它的全称是：Reactive Extension。这套框架其实是源自于微软，微软在2011年就已经开发出这套框架了，但真正火起来是在NetFlix，支持很多语言的一套响应式编程的框架，感兴趣可以去它的官网看看：reactivex.io，支持了这么多语言！！！ 它的优势在于：在思考的维度上加上时间考量。，这也是一个问题，导致更难理解！ ObservableObservable的性质Observable有三种状态，分别是： next：必要。用来处理每个送达值。在开始执行后可能执行零次或多次。 error：可选。用来处理错误通知。错误会中断这个可观察对象实例的执行过程。 complete：可选。用来处理执行完毕（complete）通知。当执行完毕后，这些值就会继续传给下一个处理器。 还有特殊的Observable：永不结束的、Never、Empty（结束但不发射）、Throw 本来是想写介绍点操作符的，但是我发现没啥意思，反正文档都能查到，那就记录点自己对Observable的理解吧，具体操作符到时候查api。其实Observable就是将数据以流的形式来进行处理，可以理解成node中的流，我们可以对流进行一系列的操作，最后我们再订阅这个流，对流里面的数据进行使用。 举个例子吧: const a: Array&lt;number&gt; = [1, 2, 3, 4]; const a$ = Rx.Observable.from(a).pipe(map( val =&gt; val * val)); const observer = { next: (val) =&gt; console.log(val); error： (err) =&gt; console.log(err); complete: () =&gt; console.log(`everything is completed`); } a$.subscribe(observer); 上面的例子会打印出： 1 4 9 16 因为我们对流中的数据进行了map操作，使它们自己乘以自己。这就是对流的一个简单处理，连pipe方法都和node中的流一样。 Observable的冷和热Observable有两种，一种是冷的，一种是热的。怎么去理解呢？下面的内容在angular的官网上并没有说明 冷的就是表示，每次你订阅之后我们都会从头执行一遍，就像看重播一样，点击之后都是重头开始播放； 热代表每次订阅之后大家之间的进度是一样的，就像看直播一样，打开之后都是最新时刻的通知。 未完待续。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular动画","date":"2018-09-07T06:48:12.000Z","path":"2018/09/07/angular动画/","text":"Angular动画在angular2的时候，angular动画还是个核心的组件库，但是到了angular4的时候，为了减小核心库的体积，所以移除出核心组件。但并不是不重要，它依然是angular中很重要的组成部分，而且也是官方提供的支持。 angular动画架构其实很简单，就是在组件里面定义数个触发器，每个触发器会有一系列的状态和过渡效果，其实这就是动画。 State &amp; Transiton（这两个是核心） 动画其实就是从一个状态过渡到另一个状态 状态本身包含形状、颜色、大小等等 State就是定义状态而Transition是定义如何过渡 Animate函数其实在Transition函数中，还会调用另一个函数，那就是Animate Animate规定了具体怎么样过渡，比如时间、过渡的速度等 Animate有多个重载形式 使用流程引入关键模块并声明import { BrowserModule } from &apos;@angular/platform-browser&apos;; import { BrowserAnimationsModule } from &apos;@angular/platform-browser/animations&apos;; @NgModule({ imports: [ BrowserModule, BrowserAnimationsModule ], }) export class AppModule { } 建议在imports中最后引入BrowserAnimationsModule模块，放在前面可能会踩坑。 定义各种状态拿个官网的例子来看看： @Component({ ... //这里是一些正常的定义 animations: [ trigger(&apos;heroState&apos;, [ state(&apos;inactive&apos;, style({ backgroundColor: &apos;#eee&apos;, transform: &apos;scale(1)&apos; })), state(&apos;active&apos;, style({ backgroundColor: &apos;#cfd8dc&apos;, transform: &apos;scale(1.1)&apos; })), transition(&apos;inactive =&gt; active&apos;, animate(&apos;100ms ease-in&apos;)), transition(&apos;active =&gt; inactive&apos;, animate(&apos;100ms ease-out&apos;)) ]) ] }) 这里定义了两个状态，一个是active还有个是incative，这两个状态分别有不同的style样式，transition定义了从不同状态过渡到另一个状态的过程。 附加到模板上template: ` &lt;ul&gt; &lt;li *ngFor=&quot;let hero of heroes&quot; [@heroState]=&quot;hero.state&quot; (click)=&quot;hero.toggleState()&quot;&gt; {{hero.name}} &lt;/li&gt; &lt;/ul&gt; ` 只要使用[@triggerName]语法加到模板上就行了。这就是一个简单的动画效果。 更多的深入知识，例如缓动函数、关键帧需要的话可以去官网看看，在这贴两个好玩的网址出来： https://easings.net/zh-cnhttp://cubic-bezier.com/#.17,.67,.83,-0.63","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular实战中踩过的坑（不定时更新）","date":"2018-09-07T04:08:48.000Z","path":"2018/09/07/angular实战中踩过的坑（不定时更新）/","text":"动态表单中踩过的坑2018-9-7问题：今天在写动态表单时遇到个问题，我在控制器中生成的formControl死活就是拿不到我输入的值。 分析：生成formControl的代码肯定没有问题： let fb = new FormBuilder(); this.formModel = fb.group({ title: [&apos;&apos;, Validators.minLength(3)], price: [null, this.positiveNumberValidator], category: [&apos;-1&apos;] }); 对吧，是没有问题，那肯定就是出在绑定模板的时候，于是我们认真看看吧。 问题根源： 发现了吧，这个Name由于打快了，打成了小写！低级错误！以后拼写细心点！ 版本更新问题问题：我想要做个商品筛选的功能，其中我需要使用debounceTime方法来对我的输入行为产生一个延时的处理，我的调用方法如下： 引入的是： import ‘rxjs/RW’; 结果引入报错。 分析：既然引入报错肯定是更新过了，目录结构发生变化了，甚至连方法的使用也有可能改变了，还是去官方找找吧。 问题根源：一查果然是更新的问题，而且不出意料，方法也需要修改下，经过修改后引入的方式如下： import { debounceTime } from ‘rxjs/operators’; 方法也需要改进成下面这种:","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"Koa中使用Cookie & Session","date":"2018-09-06T02:43:21.000Z","path":"2018/09/06/Koa中使用Cookie-Session/","text":"koa中cookie和session使用 cookie介绍cookie 是存储于访问者的计算机中的变量（客户端）。可以让我们用同一个浏览器访问同一个域名的时候共享数据。那为什么不使用http呢？很简单，因为HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。 cookie用处随便举几个例子： 存储用户信息，例如登陆信息。 浏览历史记录。 猜你喜欢的功能。 10天免登陆。 多个页面之间的数据传递。 实现购物车功能。 Koa Cookie的使用Koa中设置Cookie的值ctx.cookies.set(name, value, [options]) 通过options设置cookie name的value: options名称 options值 maxAge 一个数字表示从 Date.now() 得到的毫秒数。 expires cookie 过期的 Date path cookie 路径, 默认是’/‘。 secure 安全 cookie 默认 false，设置成 true 表示只有 https 可以访问。 httpOnly 是否只是服务器可访问 cookie, 默认是 true overwrite 一个布尔值，表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（不管路径或域）是否在设置此 Cookie 时从Set-Cookie 标头中过滤掉。 Koa中设置中文Cookieconsole.log(new Buffer(&apos;hello, world!&apos;).toString(&apos;base64&apos;));// 转换成 base64 字符串：aGVsbG8sIHdvcmxkIQ== console.log(new Buffer(&apos;aGVsbG8sIHdvcmxkIQ==&apos;, &apos;base64&apos;).toString());// 还原 base64 字符串：hello, world! Session介绍session 是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 Session 的工作流程当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session 对象，生成一个类似于 key,value的键值对，然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的Session(value)。 客户的信息都保存在Session中。 koa-session 的使用npm install koa-session --save 引入 express-sessionconst session = require(&apos;koa-session&apos;); 设置官方文档提供的中间件app.keys = [&apos;some secret hurr&apos;]; const CONFIG = { key: &apos;koa:sess&apos;, //cookie key (default is koa:sess) maxAge: 86400000, // cookie 的过期时间 maxAge in ms (default is 1 days) overwrite: true, //是否可以 overwrite (默认 default true) httpOnly: true, //cookie 是否只有服务器端可以访问 httpOnly or not (default true) signed: true, //签名默认 true rolling: false, //在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） renew: false, //(boolean) renew session when session is nearly expired, }; app.use(session(CONFIG, app)); Cookie 和 Session 区别 cookie 数据存放在客户的浏览器上，session 数据放在服务器上。 cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗考虑到安全应当使用 session。 session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE。 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。","tags":[{"name":"Node","slug":"Node","permalink":"http://tanyibing.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://tanyibing.com/tags/Koa/"}]},{"title":"分享按钮功能的实现","date":"2018-09-05T09:07:22.000Z","path":"2018/09/05/分享按钮功能的实现/","text":"Facebook分享功能事项今天需要实现一个点击按钮进行分享的功能，而且需要是多平台，之前了解过应该是通过调用各个平台的api进行实现的，没办法，去网上找找方法吧。 首先找个Facebook的实现看看效果，当你只是想分享一个链接到facebook中的时候，我们只需要将分享的url作为参数的形式传递到facebook网站即可，如下： “http://www.facebook.com/sharer/sharer.php?u=&quot; + url; 当然也可以当成参数的形式传递： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;share_button&quot; type=&quot;button&quot; value=&quot;share to facebook&quot; /&gt; &lt;script type=&quot;text/JavaScript&quot;&gt; function popupwindow(url, title, w, h) { wLeft = window.screenLeft ? window.screenLeft : window.screenX; wTop = window.screenTop ? window.screenTop : window.screenY; var left = wLeft + (window.innerWidth / 2) - (w / 2); var top = wTop + (window.innerHeight / 2) - (h / 2); return window.open(url, title, &apos;toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=&apos; + w + &apos;, height=&apos; + h + &apos;, top=&apos; + top + &apos;, left=&apos; + left); } window.onload = function () { document.getElementById(&apos;share_button&apos;).onclick = function(){ var shareUrl = &quot;http://www.facebook.com/sharer/sharer.php?u=https://www.google.com&quot;; popupwindow(shareUrl, &apos;Facebook&apos;, 600, 400); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 上面虽然分享成功了，但是分享的内容显得很死板，只有一些文字，如何自定义我们的内容呢？我们需要在被分享的网站的页面上添加一些meta标签，facebook会自己从所分享的页面上去抓取这些标签里的内容，你可以自定义图片、描述等等。 在定义了这些之后就更加生动了： &lt;meta property=&quot;og:title&quot; content=&quot;百度&quot;&gt; &lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt; &lt;meta property=&quot;og:image&quot; content=&quot;www.baidu.com/img/bd_logo1.png&quot;&gt; &lt;meta property=&quot;og:description&quot; content=&quot;百度一下，你就知道&quot;&gt; 当然，你可能想动态的去生成这些东西，这就复杂一些，需要用到facebook中的Javascript SDK: &lt;script&gt; window.fbAsyncInit = function() { FB.init({ appId : &apos;your-app-id&apos;, autoLogAppEvents : true, xfbml : true, version : &apos;v2.10&apos; }); FB.AppEvents.logPageView(); }; (function(d, s, id){ var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) {return;} js = d.createElement(s); js.id = id; js.src = &quot;//connect.facebook.net/en_US/sdk.js&quot;; fjs.parentNode.insertBefore(js, fjs); }(document, &apos;script&apos;, &apos;facebook-jssdk&apos;)); &lt;/script&gt; 在他们的官网可以看更多。 我们还可以通过facebook develop来检测你要分享的网站的效果，并且在这里可以生成使用sdk所需要的appid，而且可以在这里看到网址的被转发数，点击数之类的。 这样就完成facebook的分享功能了，但他喵的是不是也太麻烦了，果断找找有没有别的方法，难道你还真以为我会一个个写下去！！！？？？结果还真找到了一个方法，那就是Mob上面的ShareSDK啦。 怎么实现？首先在里面找到你需要的简单的，首先在下图中找到你要的，然后傻瓜式写代码就行了 &lt;!--MOB SHARE BEGIN--&gt; &lt;div class=&quot;-mob-share-ui-button -mob-share-open&quot;&gt;分享&lt;/div&gt; &lt;div class=&quot;-mob-share-ui&quot; style=&quot;display: none&quot;&gt; &lt;ul class=&quot;-mob-share-list&quot;&gt; &lt;li class=&quot;-mob-share-weibo&quot;&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qzone&quot;&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qq&quot;&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-douban&quot;&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-facebook&quot;&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-twitter&quot;&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;-mob-share-close&quot;&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;-mob-share-ui-bg&quot;&gt;&lt;/div&gt; &lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey=你的appkey&quot;&gt;&lt;/script&gt; &lt;!--MOB SHARE END--&gt; 这是最简单的一种，至于怎么扩展，文档写的很清楚，也很傻瓜式，我就不再傻瓜式的写出来了，影响我的形象。啦啦啦啦！！！","tags":[{"name":"Web SDK","slug":"Web-SDK","permalink":"http://tanyibing.com/tags/Web-SDK/"}]},{"title":"angular应用的构建和部署","date":"2018-09-04T02:11:32.000Z","path":"2018/09/04/angular应用的构建和部署/","text":"第一步 构建我们知道我们的angular应用是使用Typescript进行编写的，而浏览器不能直接运行Typescript，而且我们的样式可能是使用scss编写的，我们需要将这所有的一切进行整合，构建成浏览器能看得懂的文件。索性的是angular cli工具已经帮我们准备好了一切，我们只要执行一条命令就行了： ng build 然后我们就得到了这样一个dist文件夹，这样我们就已经构建好了。 第二步 部署部署简单啊，例如node的服务器，直接新建一个目录，然后把dist里面的文件都复制进去就行了，这样就算是部署完成了。 多环境配置为了让我们的项目能在多种环境下都能运行，我们需要做多环境配置，具体配置方法还在研究中！","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular中的两种表单","date":"2018-09-03T06:44:55.000Z","path":"2018/09/03/angular中的两种表单/","text":"表单forms是前端中很重要的一块内容，Angular中同样如此。在Angular中，有两种表单的形式，一种是模板驱动表单，还有一种是响应式表单。接下来就简单的介绍一下： 模版驱动表单区别：只能在模板中操作，不能在代码中操作。不说了，直接上个表单： &lt;form #myForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(myForm.value)&quot;&gt; &lt;div&gt;用户名：&lt;input ngModel name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;div&gt;手机号：&lt;input ngModel name=&quot;mobile&quot; type=&quot;number&quot;&gt;&lt;/div&gt; &lt;div ngModelGroup=&quot;passwordsGroup&quot;&gt; &lt;div&gt;密码：&lt;input ngModel name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/div&gt; &lt;div&gt;确认密码：&lt;input ngModel name=&quot;pconfirm&quot; type=&quot;password&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt; &lt;/form&gt; 响应式表单区别：只能在代码中操作，不能在模板中操作。响应式表单一共分为两步： 创建数据模型由三个类组成：FormControl、FormGroup、FormArray，怎么创建呢？直接贴出代码： export class ReactiveFormComponent implements OnInit { username: FormControl = new FormControl(&apos;username&apos;); formModel: FormGroup = new FormGroup({ dateRange: new FormGroup({ from: new FormControl(), to: new FormControl() }), emails: FormArray = new FormArray([ new FormControl(&quot;a@a.com&quot;), new FormControl(&quot;b@b.com&quot;) ]); }); } 使用响应式表单指令绑定表单模版 html &lt;form [formGroup]=&quot;formModel&quot; (submit)=&quot;onSubmit()&quot;&gt; &lt;div formGroupName=&quot;dateRange&quot;&gt; 起始日期：&lt;input type=&quot;date&quot; formControlName=&quot;from&quot;&gt; 截止日期：&lt;input type=&quot;date&quot; formControlName=&quot;to&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;ul formArryName=&quot;emails&quot;&gt; &lt;li *ngFor=&quot;let e of this.formModel.get(&apos;emails&apos;).controls; let i = index;&quot;&gt; &lt;input type=&quot;text&quot; [formControlName]=&quot;i&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button type=&quot;button&quot; (click)=&quot;addEmail()&quot;&gt;增加email&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; js addEmail(){ let emails = this.formModel.get(&quot;emails&quot;) as FormArray; emails.push(new FormControl()); } 这样看上去是不是代码很多，有个简化的方法就是使用FormBuilder，使用首先要引入，然后再constructor中注册，然后给个对比吧： profileForm = new FormGroup({ firstName: new FormControl(&apos;&apos;), lastName: new FormControl(&apos;&apos;), address: new FormGroup({ street: new FormControl(&apos;&apos;), city: new FormControl(&apos;&apos;), state: new FormControl(&apos;&apos;), zip: new FormControl(&apos;&apos;) }) }); 上面的等同于： profileForm = this.fb.group({ firstName: [&apos;&apos;], lastName: [&apos;&apos;], address: this.fb.group({ street: [&apos;&apos;], city: [&apos;&apos;], state: [&apos;&apos;], zip: [&apos;&apos;] }), }); FormGroup用this.fb.group替代，FormContrl用[&#39;&#39;]替代,怎么进行校验，我的天，又是好多字，今天就先这样吧！！！反正是我自己看的，我记得就行了！！！哈哈哈！！！","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular生命周期钩子","date":"2018-09-02T14:40:24.000Z","path":"2018/09/02/angular生命周期钩子/","text":"Angular中每个组件都有它的生命周期，从创建、渲染，到变更检测，再到最后的销毁过程过程，Angular一共提供了八个生命周期钩子，他们按照顺序分别是：constructor、ngOnChanges、ngOnInit、ngDoCheck、ngAfterContentInit、ngAfterContentChecked、ngAfterViewInit、ngAfterViewChecked、ngOnDestroy，其中有的钩子在生命周期内只调用一次，有的则可以反复调用（变更检测机制中需要调用方法）。如下图： 其中红色的表示只调一次，绿色的则可以被多次调用。我们将介绍其中重要的几个方法。 ngOnChanges:这个钩子在父组件初始化或修改子组件的输入属性时会被调用。想要理解这个方法为什么会被调用或不被调用，我们需要了解可变对象和不可变对象，在js中，字符串是不可变对象，但一个对象是一个可变对象，至于为什么，请自行百度。最后的结论是：当输入属性是变对象例如对象时，对象的属性发生变化并不会触发ngOnChanges方法；当输入属性是不可变对象例如字符串时，字符串改变会触发ngOnChanges方法。还需要注意一点就是：ngOnChanges方法首次调用一定是发生在ngOninit方法之前的。 ngDoCheck:变更检测可以说是Angular中最复杂的模块： angular有两种变更检测机制，一种是Default策略，一种是OnPush策略。Default策略会在组件发生变化时去检查组件树中所有组件，而使用OnPush的组件只会在其输入属性发生变化时去检查它。当我们对性能要求比较高的时候，例如有大量的表格数据在时时发生变化时，这两种策略的正确选择就显得尤为重要。在ngOnChanges中我们知道 当输入属性是可变对象例如对象时，对象的属性发生变化并不会触发ngOnChanges方法。 那么怎么检测对象的属性呢，这时就需要用到ngDoCheck方法了。check的调用十分频繁，发生一点点动静都会调用check方法，就比如我们的鼠标光标切换input但是没有改变值框这类的动作，组件树上所有的有check关键字钩子都会调用，所以，我们的所有check方法一定要小心，一定要高效，一定要轻量级。 ngAfterViewInit &amp; ngAfterViewChecked:顾名思义，这两个方法都是跟组件的视图密切相关的，前者是在视图都组建完毕之后才调用，后者是在视图发生变化时调用，值得注意的是： 这两个方法都是在视图组建完毕之后被调用的； 如果父组件存在子组件，那么父组件的这两个方法会在所有子组件的视图都组建完毕后调用； 不要早在这两个方法里面去改变视图中绑定的东西，这样做会报错。如果真的需要修改，需要写在一个timeout方法里面。 ngAfterContentInit &amp; ngAfterContentChecked:要使用这两个方法，就得再说到一个ng-content投影，什么是内容投影呢？就是从组件外部导入HTML内容，并把它插在组件中指定位置上的一种途径，举个例子，我们在子组件模板中这样定义一个投影点： &lt;ng-content&gt;&lt;/ng-content&gt; 这样我们在父组件中可以定义： &lt;app-child&gt; //这里面可以写想投影到子组件的内容 &lt;/app-child&gt; 这样我们就将父组件中的内容投影到了子组件中。不仅如此，我们还能同时投影多个内容，在父组件中这样定义： &lt;app-child&gt; //这里面可以写想投影到子组件的内容 &lt;div class=&apos;header&apos;&gt;{{title}}&lt;/div&gt; &lt;div class=&apos;footer&apos;&gt;{{content}}&lt;/div&gt; &lt;/app-child&gt; 然后再子组件中可以这样接收： &lt;ng-content select=&apos;.header&apos;&gt;&lt;/ng-content&gt; &lt;ng-content select=&apos;.footer&apos;&gt;&lt;/ng-content&gt; 这样我们不仅将两个HTML片段投影到子组件中，还将父组件控制器中的title、content通过插值表达式投影到了子组件中。ngAfterContentInit和ngAfterViewInit不同的是：ngAfterViewInit不能够改变视图中绑定的值，而在ngAfterContentInit中是可以的，不会报错。因为在ngAfterContentInit的时候，视图还没有组装完毕，只是投影进来的内容被组装完毕了。 ngOnDestroy组件什么时候被销毁呢，就是路由到别处的时候，当前组件会被销毁，创建新的路由的组件。在这一般是用来释放那些不会被垃圾收集器自动回收的各类资源的地方。取消那些对可观察对象和 DOM 事件的订阅。停止定时器。注销该指令曾注册到全局服务或应用级服务中的各种回调函数。如果不这么做，就会有导致内存泄露的风险。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular中组件之间如何通信(二)","date":"2018-09-01T11:19:43.000Z","path":"2018/09/01/angular中组件之间如何通信（二）/","text":"接着上一篇的内容，上一篇最后说到有公共父组件的组件之间是如何通信的，最后还有一个问题没有解决。但是在这之前我需要补充一下，父组件和子组件之间的通信还有一种方式，那就是通过本地变量或者使用@ViewChiad来进行传递，举个例子： export class childComponent { private sayHello() { console.log(&apos;Hello&apos;); } } 我在子组件中定义这样一个方法，我怎么在父组件中调用呢，一个是通过本地变量的方法： &lt;app-child #child1&gt;&lt;/app-child&gt; &lt;button (click)=&quot;child1.syaHello()&quot;&gt;sayHello&lt;/button&gt; 我在父组件的模板中使用子组件并加上#child1这个属性，然后就可以在父组件的模版中直接调用子组件的方法了。但是我们发现父组件的控制器并不能调用到这个方法，于是，我们就可以使用@ViewChiad： export class ParentComponent { @ViewChild(&apos;child1&apos;) private child: ChildComponent;//声明一个子组件 sayBay() { this.child.sayHello(); } } 这样我们就实现了在父组件的控制器中调用子组件的方法。 接下来我们就讨论一下最后一个问题：当组件之间没有公共的父组件时，它们应该如何通信呢？答案就是使用服务进行通信。。。loading","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular中组件之间如何通信","date":"2018-08-31T07:27:24.000Z","path":"2018/08/31/angular中组件之间如何通信/","text":"在angular中，我们会设计很多的component组件，也就生成了组件树，组件之间有可能是父子组件，或者兄弟组件，或者彼此都没有关系。那么这么多组件之间该如何通讯呢？下面我们就简答的了解了解。 父子组件之间的通讯父子之间的通讯比较简单，我们需要用到@Input输入属性和@Output输出属性。当我们需要从父组件向子组件传递信息时，我们首先需要为子组件定义一个属性： export class childComponent { @Input() hero: Hero; } 被@Input修饰的属性就即将接受从父组件传过来的信息。具体怎么传值呢？我们在父组件中通过子组件的属性进行传值： &lt;app-child [hero]=&quot;控制器中的属性值&quot;&gt;&lt;/app-child&gt; 我们在父组件的模板中调用子组件时，只要在子组件中对hero属性进行绑定就行了。是不是很简单？而从子组件向父组件传值也很简单，其实就是一个反向的过程，我们需要借助EventEmitter的订阅和广播的功能就可以了，首先我们在子组件中定义要传输出去的属性值： export class childComponent { @Output() voted = new EventEmitter&lt;boolean&gt;(); didVote = false; vote(agreed: boolean) { this.voted.emit(agreed); this.didVote = true; } } 我们将要输出的是通过EventEmitter进行实例化，然后在需要的时候触发.emit(agreed)事件就能将数据传出去。那接下来我们需要在父组件中进行接收： &lt;app-child (voted)=&quot;onVoted($event)&quot;&gt;&lt;/app-child&gt; 我们在父组件模板中的子组件上加上一个事件绑定，并且在父组件中定义onVoted()方法： export class ParentComponent { agreed = 0; disagreed = 0; onVoted(event: boolean) {//event就是传递过来的数据 agreed ? this.agreed++ : this.disagreed++; } 在父组件的方法中的参数就是我们从子组件中拿到的数据。这样就成功的传递出了信息。但是需要注意的是：默认情况下父组件模板中捕获事件的名字和子组件中输出属性的名字是一样的，都是voted！！！但是我们也可以通过输出属性来重命名： @Output(&apos;XXX&apos;)//这样就可以改掉输出属性的名字，同样的捕获事件的名字也要同步改过来。 中间人模式父子组件之间传递数据容易实现，但是当我们的组件不是父子关系的时候我们应该怎么传递数据？这就要用到我们的中间人模式了。 中间人模式最简单的一种关系就是两个组件有共同的父组件，也就是两个组件是兄弟关系。但是这个比喻不贴切，他们只是拥有共同的父组件，其实他们两之间谁都不认识谁。那么他们之间怎么通信呢？就把父组件当成中间人就行了： export class childOneComponent { @Output() voted = new EventEmitter&lt;boolean&gt;(); didVote = false; vote(agreed: boolean) { this.voted.emit(agreed); this.didVote = true; } } 首先还是一个组件中输出一个属性，并在适当的时触发广播的行为，将我们的数据发送出去。接着需要在父组件中监听voted这个事件： &lt;app-child-one (voted)=&quot;veteHandler($event)&quot;&gt;&lt;/app-child-one&gt; 我们的另一个子组件需要有个输入属性： export class childTwoComponent { @Input() voteCount; } 既然是我们的中间人，它就应该先接收它收到的数据，然后将数据再传给需要的人。这就很简单啦： export class ParentComponent { voteCount; veteHandler(event: boolean) {//event就是传递过来的数据 this.voteCount = event; } 我想你已经猜到下一步应该怎么办了，我们将父组件接受的数据传给另一个子组件就行了，怎么传？通过属性绑定来传递啊： &lt;app-child-one (voted)=&quot;veteHandler($event)&quot;&gt;&lt;/app-child-one&gt; &lt;app-child-two [voteCount]=&quot;voteCount&quot;&gt;&lt;/app-child-two&gt; 这样我这个中间人的职责就完成啦，成功将一个组件传递给另一个组件。而且他们两互相之间根本不知情。 那么没有共同的父组件的组件之间难道就不能通讯了吗？答案肯定是不是的，我将在下一篇博客中回答！","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular数据绑定","date":"2018-08-30T14:56:05.000Z","path":"2018/08/30/angular数据绑定/","text":"Angular数据绑定是Angular中最常见的，绑定的方式有单向数据绑定和双向数据绑定。单向的数据绑定通常有以下几种方式： 1.使用插值表达式将一个表达式的值显示在模板上： &lt;h1&gt;{{titke}}&lt;/h1&gt; 2.使用方括号将HTML标签的一个属性绑定到一个表达式上： &lt;img [src] = &quot;imgUrl&quot;&gt; 其实我们的属性绑定和我们的插值表达式是一样的，我们举个例子; &lt;img [src] = &quot;imgUrl&quot;&gt; &lt;img src = {{imgUrl}}&gt; 这两种写法其实都一样，插值的表达式都会被Angular转化成属性绑定。在这还有一个需要理解的东西就是HTML属性和DOM属性的区别，举个例子： &lt;input value=&quot;hello&quot; (click)=&quot;doOnInput($event)&quot;&gt; 我们的控制器定义一下我们的输入事件： doOnInput(event: any) { console.log(event.target.value);//打印DOM属性的值 console.log(event.target.getAttribute(&apos;value&apos;);//打印HTML属性的值 } 我们可以发现DOM属性的值是随着你改变输入的值而一直在改变的，而HTML属性的值一直是hello，因为HTML是初始化DOM属性的值的，不能改变，而DOM属性的值可以改变。 HTML属性和DOM属性的关系如下： 少量HTML属性和DOM属性之间有1:1的映射，比如id。 有些HTML属性没有对应的DOM属性，如colspan。 有些DOM属性没有对应的HTML属性，如textContent。 就算名字相同，HTML属性和DOM属性也不是一样东西。 HTML属性的值指定了初始值；DOM属性的值表示当前值.DOM属性的值可以改变；HTML属性的值不能改变。 模板绑定是通过DOM属性和事件来工作的，而不是HTML属性。 以上是DOM属性的绑定，下面介绍下HTML属性的绑定简单的举个例子： &lt;td [attr.colspan]={{1+1}}&gt; 因为colspan是个DOM属性没有的HTML属性，所以我们在前面加上attr这个前缀来表示它是HTML属性。 更多的我们可以通过[ngClass]或者[class.classname]、[class]这种来控制部分或者全部的类名，以此来达到控制样式的效果。ngclass的表达式需要接收一个对象，对象中通过{cssClassName: Boolen}这种键值对来表示该类是否要加上，true表示加上，false代表移除，这就是CSS类绑定。 类似的，我们还可以通过css样式绑定，不过不再是class开头了，而是style开头，举个栗子： &lt;div [style.color]=&quot; isDev? &apos;red&apos;: &apos;blue&apos;&quot;&gt; 其中的isDev就是控制器来控制的。和上面css类绑定一样，这只是单一样式的绑定，所以我们还有个[ngStyle]来批量控制，它也是接受一个对象，但和css类不同的是，这个对象里面定义的是样式的键值对，例如{color: red,background: black} 3.上面这两个绑定方式都是控制器向模板传输数据，下面这种是模板向控制器传输数据，也就是事件绑定： &lt;button (click)=&quot;onClickEvent($event)&quot;&gt;点击执行&lt;/button&gt; //小括号表示这是一个事件绑定 //小括号中的是事件的名称 //等号后面双引号中的是事件发生时执行的表达式 //如果处理事件的方法需要了解事件的属性，我们就可以给方法加上$event参数 我们的事件绑定中也可以不是一个方法调用，而是一个属性赋值： &lt;button (click)=&quot;saved = true&quot;&gt; 这样我们就能够直接给控制器中的saved属性赋值为true。 接下来我们看一下最重要的双向数据绑定 盒子里面装香蕉 这句话是官网文档上面说的，就是指[(ngModel)]是方括号包着小括号，其实从上面就能看出，控制器传值给模板是方括号，模板传值给控制器是小括号，两个融合到一起就是双向数据绑定了，举个栗子： &lt;input [value]=&quot;currentHero.name&quot; (input)=&quot;currentHero.name=$event.target.value&quot; &gt; 下面这个而其实就是一个双向数据绑定，但是显得太过笨重，于是有了下面这种写法： &lt;input [(ngModel)]=&quot;currentHero.name&quot;&gt; 这样就能够同步输入和显示了，最常用的地方就是我们的表单元素了。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"angular中如何引入第三方库","date":"2018-08-29T15:06:42.000Z","path":"2018/08/29/angular中如何引入第三方库/","text":"当我们想要在angular项目中引入第三方的库的时候我们应该怎么操作？就拿jquery来说吧： 第一步我们需要在项目目录下安装自己所需要的包： npm install --save jquery --save和--save-dev的区别就不多描述了，安装完成之后我们就可以在项目下的node_modules下面看到它了。 第二步我们需要把我们下载好的包加入到angular的配置文件中，在6.x之前，这个配置文件的名称是.angular-cli.json，但是在6.x之后就不是这个名字了，而是换成了angular.json，打开这个文件我们就能看到一系列的配置信息。我们需要将自己下载的包的路径引用到styles和scripts数组下面： 在这里填入正确的路径就可以了。这样jquery或者你需要的第三方包就被加入到angular项目中了。 但是我们现在还是不能直接使用jquery，因为angular是使用typescript开发的，而jquery的本质是javascript，Typescript是不能直接使用的。我们还需要安装类型描述文件让Typescript认识jquery。 第三步我们通过命令来安装jquery的类型描述文件： npm install @types/jquery(这个名字是你需要安装的包的名字) --save-dev 这样我们就能够使用jquery的命令了。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"rem的正确使用姿势","date":"2018-08-27T14:14:03.000Z","path":"2018/08/27/rem的正确使用姿势/","text":"最近用的比较多的就是rem了，所以写一篇rem的文章来记录下使用rem来制作移动端的页面的关键之处。 首先简单的阐述下px、em、rem三者之间的关系： px：像素是相对于显示器屏幕分辨率而言的相对长度单位。pc端使用px倒也无所谓，可是在移动端，因为手机分辨率种类颇多，不可能一个个去适配，这时px就显得非常无力，所以就要考虑em和rem。 em：继承父级的，假设html的font-size默认为16px，body字体大小定义为50%，那么在body里字体大小就是1em=8px了。可当你又定义了一个div，然后把字体设置成了50%，请问，现在div下的1em等于多少？因为继承了父级的值，现在这个div里的1em=4px，这么嵌套下去的话，抱歉，我数学不好！所以rem就出现了。 rem：是em的升级版，rem只会相对html的值，不会受到父级的影响，这样的好处在于：从em里的例子来讲，1rem始终会等于8px。使用的时候不需要重新计算rem此时的大小。rem因为是css3增加的，所以ie8或以下请无视（始终想不明白，为什么国人至今对微软都放弃的ie这么恋恋不舍）。 使用方法：首先在css中先全局声明font-size=625%,这里为什么用625%呢？因为100%=16px,1px=6.25%,所以100px=625%，1rem=100px。这样在后面使用的时候就方便很多。需要注意的是，rem是相对于根元素html的font-size，也就是说只需要设置根元素html的百分比就行了： html{font-size: 625%;} 还可以动态的来设置rem，例如使用媒体查询： @media screen and (min-width: 320px) { html {font-size: 14px;} } @media screen and (min-width: 360px) { html {font-size: 16px;} } @media screen and (min-width: 400px) { html {font-size: 18px;} } @media screen and (min-width: 440px) { html {font-size: 20px;} } @media screen and (min-width: 480px) { html {font-size: 22px;} } @media screen and (min-width: 640px) { html {font-size: 28px;} } 或者利用js计算当前设备来设置： (function (doc, win) { var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function () { var clientWidth = docEl.clientWidth; if (!clientWidth) return; if(clientWidth&gt;=640){ docEl.style.fontSize = &apos;100px&apos;; }else{ //这里的640是根据设计图实际大小来的 docEl.style.fontSize = 100 * (clientWidth / 640) + &apos;px&apos;; } }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false); })(document, window); 后来看到一个关于手淘的文章，有了下面这种最佳的方法，通过js计算当前设备的DPR，动态设置在html标签上，并动态的设置html的font-size，利用css选择器根据DPR来设置不同DPR下的字体的大小： function(win, lib) { var timer, doc = win.document, docElem = doc.documentElement, vpMeta = doc.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;), flexMeta = doc.querySelector(&apos;meta[name=&quot;flexible&quot;]&apos;), dpr = 0, scale = 0, flexible = lib.flexible || (lib.flexible = {}); // 设置了 viewport meta if (vpMeta) { console.warn(&quot;将根据已有的meta标签来设置缩放比例&quot;); var initial = vpMeta.getAttribute(&quot;content&quot;).match(/initial\\-scale=([\\d\\.]+)/); if (initial) { scale = parseFloat(initial[1]); // 已设置的 initialScale dpr = parseInt(1 / scale); // 设备像素比 devicePixelRatio } // 设置了 flexible Meta }else if (flexMeta) { var flexMetaContent = flexMeta.getAttribute(&quot;content&quot;); if (flexMetaContent) { var initial = flexMetaContent.match(/initial\\-dpr=([\\d\\.]+)/), maximum = flexMetaContent.match(/maximum\\-dpr=([\\d\\.]+)/); if (initial) { dpr = parseFloat(initial[1]); scale = parseFloat((1 / dpr).toFixed(2)); } if (maximum) { dpr = parseFloat(maximum[1]); scale = parseFloat((1 / dpr).toFixed(2)); } } } // viewport 或 flexible // meta 均未设置 if (!dpr &amp;&amp; !scale) { // QST // 这里的 第一句有什么用 ? // 和 Android 有毛关系 ? var u = (win.navigator.appVersion.match(/android/gi), win.navigator.appVersion.match(/iphone/gi)), _dpr = win.devicePixelRatio; // 所以这里似乎是将所有 Android 设备都设置为 1 了 dpr = u ? ( (_dpr &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) ? 3 : (_dpr &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) ? 2 : 1 ) : 1; scale = 1 / dpr; } docElem.setAttribute(&quot;data-dpr&quot;, dpr); // 插入 viewport meta if (!vpMeta) { vpMeta = doc.createElement(&quot;meta&quot;); vpMeta.setAttribute(&quot;name&quot;, &quot;viewport&quot;); vpMeta.setAttribute(&quot;content&quot;, &quot;initial-scale=&quot; + scale + &quot;, maximum-scale=&quot; + scale + &quot;, minimum-scale=&quot; + scale + &quot;, user-scalable=no&quot;); if (docElem.firstElementChild) { docElem.firstElementChild.appendChild(vpMeta) } else { var div = doc.createElement(&quot;div&quot;); div.appendChild(vpMeta); doc.write(div.innerHTML); } } function setFontSize() { var winWidth = docElem.getBoundingClientRect().width; if (winWidth / dpr &gt; 540) { (winWidth = 540 * dpr); } // 根节点 fontSize 根据宽度决定 var baseSize = winWidth / 10; docElem.style.fontSize = baseSize + &quot;px&quot;; flexible.rem = win.rem = baseSize; } // 调整窗口时重置 win.addEventListener(&quot;resize&quot;, function() { clearTimeout(timer); timer = setTimeout(setFontSize, 300); }, false); // 这一段是我自己加的 // orientationchange 时也需要重算下吧 win.addEventListener(&quot;orientationchange&quot;, function() { clearTimeout(timer); timer = setTimeout(setFontSize, 300); }, false); // pageshow // keyword: 倒退 缓存相关 win.addEventListener(&quot;pageshow&quot;, function(e) { if (e.persisted) { clearTimeout(timer); timer = setTimeout(setFontSize, 300); } }, false); // 设置基准字体 if (&quot;complete&quot; === doc.readyState) { doc.body.style.fontSize = 12 * dpr + &quot;px&quot;; } else { doc.addEventListener(&quot;DOMContentLoaded&quot;, function() { doc.body.style.fontSize = 12 * dpr + &quot;px&quot;; }, false); } setFontSize(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = setFontSize; flexible.rem2px = function(d) { var c = parseFloat(d) * this.rem; if (&quot;string&quot; == typeof d &amp;&amp; d.match(/rem$/)) { c += &quot;px&quot;; } return c; }; flexible.px2rem = function(d) { var c = parseFloat(d) / this.rem; if (&quot;string&quot; == typeof d &amp;&amp; d.match(/px$/)) { c += &quot;rem&quot;; } return c; } }(window, window.lib || (window.lib = {}));","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://tanyibing.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://tanyibing.com/tags/CSS/"}]},{"title":"全屏遮罩播放视频","date":"2018-08-23T08:48:28.000Z","path":"2018/08/23/全屏遮罩播放视频/","text":"接着上一篇的内容，现在我播放视频不希望跳转到一个新的视频播放页面这么麻烦了，我想要通过点击直接在本页面进行播放。最后决定的是在全屏加上一个遮罩，视频控制住在屏幕的正中央进行播放。直接上我的代码吧： &lt;div class=&quot;box-mask&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;input class=&quot;btnCancel&quot; type=&quot;button&quot; value=&quot;关闭&quot;&gt; &lt;script src=&apos;//player.polyv.net/script/polyvplayer.min.js&apos;&gt;&lt;/script&gt; &lt;div id=&apos;&apos; class=&quot;demo&quot;&gt;&lt;/div&gt; &lt;script&gt; let videoDiv = $(&apos;.box div&apos;); $(&quot;.btnDel&quot;).click(function() { let vid = $(this).attr(&apos;id&apos;); console.log(vid); let plv = &apos;plv_&apos; + vid; let plvObj = &apos;#&apos; + plv; $(videoDiv).attr(&apos;id&apos;, plv); let plvConfig = { &apos;width&apos;:&apos;100%&apos;, &apos;height&apos;:&apos;100%&apos;, &apos;vid&apos; : vid } let player = polyvObject(plvObj).videoPlayer(plvConfig); }); &lt;/script&gt; &lt;/div&gt; 这是我的遮罩和视频播放模块的DOM结构，其中.btnDel就是我们点击进入遮罩的入口。紧接着我放出我的css样式： .box-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; opacity: 0.7; filter: alpha(opacity=50); z-index: 99; display: none; } .box { position: absolute; width: 1000px; height: 620px; line-height:620px; text-align: center; z-index: 101; display: none; } .demo{ width:100%; height:100%; margin:0 auto; } .btnCancel { float: right; width: 50px; height: 30px; } 紧接着我要实现通过点击来实现遮罩的开启和关闭，并且要考虑下鼠标滚轮的滚动和浏览器窗口的大小改变这些情况： $(document).ready(function() { var isOpen = 0; //全局变量，判断是否已经打开弹出框 $(&quot;.btnDel&quot;).click(function() { //$(&quot;.box-mask&quot;).css({&quot;display&quot;:&quot;block&quot;}); $(&quot;.box-mask&quot;).fadeIn(500); center($(&quot;.box&quot;)); //载入弹出窗口上的按钮事件 checkEvent($(this).parent(), $(&quot;.btnSure&quot;), $(&quot;.btnCancel&quot;)); }); function center(obj) { //obj这个参数是弹出框的整个对象 var screenWidth = $(window).width(), screenHeigth = $(window).height(); //获取屏幕宽高 var scollTop = $(document).scrollTop(); //当前窗口距离页面顶部的距离 var objLeft = (screenWidth - obj.width()) / 2; ///弹出框距离左侧距离 var objTop = (screenHeigth - obj.height()) / 2 + scollTop; ///弹出框距离顶部的距离 obj.css({ left:objLeft + &quot;px&quot;, top:objTop + &quot;px&quot; }); obj.fadeIn(500); //弹出框淡入 isOpen = 1; //弹出框打开后这个变量置1 说明弹出框是打开装填 //当窗口大小发生改变时 $(window).resize(function() { //只有isOpen状态下才执行 if (isOpen == 1) { //重新获取数据 screenWidth = $(window).width(); screenHeigth = $(window).height(); var scollTop = $(document).scrollTop(); objLeft = (screenWidth - obj.width()) / 2; var objTop = (screenHeigth - obj.height()) / 2 + scollTop; obj.css({ left:objLeft + &quot;px&quot;, top:objTop + &quot;px&quot; }); obj.fadeIn(500); } }); //当滚动条发生改变的时候 $(window).scroll(function() { if (isOpen == 1) { //重新获取数据 screenWidth = $(window).width(); screenHeigth = $(window).height(); var scollTop = $(document).scrollTop(); objLeft = (screenWidth - obj.width()) / 2; var objTop = (screenHeigth - obj.height()) / 2 + scollTop; obj.css({ left:objLeft + &quot;px&quot;, top:objTop + &quot;px&quot; }); obj.fadeIn(500); } }); } //导入两个按钮事件 obj整个页面的内容对象，obj1为确认按钮，obj2为取消按钮 function checkEvent(obj, obj1, obj2) { //确认后删除页面所有东西 obj1.click(function() { //移除所有父标签内容 obj.remove(); //调用closed关闭弹出框 closed($(&quot;.box-mask&quot;), $(&quot;.box&quot;)); }); //取消按钮事件 obj2.click(function() { //调用closed关闭弹出框 closed($(&quot;.box-mask&quot;), $(&quot;.box&quot;)); }); } //关闭弹出窗口事件 function closed(obj1, obj2) { obj1.fadeOut(500); obj2.fadeOut(500); isOpen = 0; } }); 至于视频内容的切换，和上一篇差不多，也可以去我的github上看实例https://github.com/TanYiBing/zenith.","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://tanyibing.com/tags/CSS/"},{"name":"HTTP","slug":"HTTP","permalink":"http://tanyibing.com/tags/HTTP/"}]},{"title":"静态页面之间传值","date":"2018-08-22T14:40:46.000Z","path":"2018/08/22/静态页面之间传值/","text":"今天在工作中需要实现视频的播放功能，我需要从视频的聚合页通过点击来跳转到视频播放页面来进行播放。因为视频是托管在POLYV平台上的，视频以.swf的格式保存的话就不能直接使用video标签，而是需要使用特定的方法来实现视频的播放功能，我最后选择的是视频平台上的多终端样式，具体代码如下： &lt;script src=&apos;//player.polyv.netscriptpolyvplayer.min.js&apos;&gt;&lt;/script&gt; &lt;div id=&apos;plv_228d7015db12fcd9a62b5abc1f76540f_2&apos;&gt;&lt;/div&gt; &lt;script&gt; var player = polyvObject(&apos;#plv_228d7015db12fcd9a62b5abc1f76540f_2&apos;).videoPlayer({ &apos;width&apos;:&apos;600&apos;, &apos;height&apos;:&apos;338&apos;, &apos;vid&apos; : &apos;228d7015db12fcd9a62b5abc1f76540f_2&apos; }); &lt;/script&gt; 我的视频聚合页中的一个例子是: &lt;a href=&quot;&quot; class=&quot;vedioCard&quot;&gt; &lt;img src=&quot;xxx.jpg&quot; class=&quot;ved&quot;&gt; &lt;div class=&quot;deti&quot;&gt;江苏的启东&lt;/div&gt; &lt;/a&gt; 紧接着我在a标签里面加上传递参数的url： &lt;a href=&quot;./video.html?vid=228d7015db9fd7dbd831b586d395e7fb_2&quot; class=&quot;vedioCard&quot;&gt; &lt;img src=&quot;xxx.jpg&quot; class=&quot;ved&quot;&gt; &lt;div class=&quot;deti&quot;&gt;江苏的启东&lt;/div&gt; &lt;/a&gt; vid就是我在播放页面想要获取的参数，因为视频的播放需要这个参数。接下来我需要在播放页面使用$.query.get（param）方法来获取我想要的东西，这看上去就是和jquery有关，没错！这是jquery的一个插件，插件的代码我也拿过来使用： new function(settings) { var $separator = settings.separator || &apos;&amp;&apos;; var $spaces = settings.spaces === false ? false : true; var $suffix = settings.suffix === false ? &apos;&apos; : &apos;[]&apos;; var $prefix = settings.prefix === false ? false : true; var $hash = $prefix ? settings.hash === true ? &quot;#&quot; : &quot;?&quot; : &quot;&quot;; var $numbers = settings.numbers === false ? false : true; jQuery.query = new function() { var is = function(o, t) { return o != undefined &amp;&amp; o !== null &amp;&amp; (!!t ? o.constructor == t : true); }; var parse = function(path) { var m, rx = /\\[([^[]*)\\]/g, match = /^([^[]+)(\\[.*\\])?$/.exec(path), base = match[1], tokens = []; while (m = rx.exec(match[2])) tokens.push(m[1]); return [base, tokens]; }; var set = function(target, tokens, value) { var o, token = tokens.shift(); if (typeof target != &apos;object&apos;) target = null; if (token === &quot;&quot;) { if (!target) target = []; if (is(target, Array)) { target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value)); } else if (is(target, Object)) { var i = 0; while (target[i++] != null); target[--i] = tokens.length == 0 ? value : set(target[i], tokens.slice(0), value); } else { target = []; target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value)); } } else if (token &amp;&amp; token.match(/^\\s*[0-9]+\\s*$/)) { var index = parseInt(token, 10); if (!target) target = []; target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value); } else if (token) { var index = token.replace(/^\\s*|\\s*$/g, &quot;&quot;); if (!target) target = {}; if (is(target, Array)) { var temp = {}; for (var i = 0; i &lt; target.length; ++i) { temp[i] = target[i]; } target = temp; } target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value); } else { return value; } return target; }; var queryObject = function(a) { var self = this; self.keys = {}; if (a.queryObject) { jQuery.each(a.get(), function(key, val) { self.SET(key, val); }); } else { jQuery.each(arguments, function() { var q = &quot;&quot; + this; q = q.replace(/^[?#]/,&apos;&apos;); q = q.replace(/[;&amp;]$/,&apos;&apos;); if ($spaces) q = q.replace(/[+]/g,&apos; &apos;); jQuery.each(q.split(/[&amp;;]/), function(){ var key = decodeURIComponent(this.split(&apos;=&apos;)[0] || &quot;&quot;); var val = decodeURIComponent(this.split(&apos;=&apos;)[1] || &quot;&quot;); if (!key) return; if ($numbers) { if (/^[+-]?[0-9]+\\.[0-9]*$/.test(val)) val = parseFloat(val); else if (/^[+-]?[0-9]+$/.test(val)) val = parseInt(val, 10); } val = (!val &amp;&amp; val !== 0) ? true : val; if (val !== false &amp;&amp; val !== true &amp;&amp; typeof val != &apos;number&apos;) val = val; self.SET(key, val); }); }); } return self; }; queryObject.prototype = { queryObject: true, has: function(key, type) { var value = this.get(key); return is(value, type); }, GET: function(key) { if (!is(key)) return this.keys; var parsed = parse(key), base = parsed[0], tokens = parsed[1]; var target = this.keys[base]; while (target != null &amp;&amp; tokens.length != 0) { target = target[tokens.shift()]; } return typeof target == &apos;number&apos; ? target : target || &quot;&quot;; }, get: function(key) { var target = this.GET(key); if (is(target, Object)) return jQuery.extend(true, {}, target); else if (is(target, Array)) return target.slice(0); return target; }, SET: function(key, val) { var value = !is(val) ? null : val; var parsed = parse(key), base = parsed[0], tokens = parsed[1]; var target = this.keys[base]; this.keys[base] = set(target, tokens.slice(0), value); return this; }, set: function(key, val) { return this.copy().SET(key, val); }, REMOVE: function(key) { return this.SET(key, null).COMPACT(); }, remove: function(key) { return this.copy().REMOVE(key); }, EMPTY: function() { var self = this; jQuery.each(self.keys, function(key, value) { delete self.keys[key]; }); return self; }, load: function(url) { var hash = url.replace(/^.*?[#](.+?)(?:\\?.+)?$/, &quot;$1&quot;); var search = url.replace(/^.*?[?](.+?)(?:#.+)?$/, &quot;$1&quot;); return new queryObject(url.length == search.length ? &apos;&apos; : search, url.length == hash.length ? &apos;&apos; : hash); }, empty: function() { return this.copy().EMPTY(); }, copy: function() { return new queryObject(this); }, COMPACT: function() { function build(orig) { var obj = typeof orig == &quot;object&quot; ? is(orig, Array) ? [] : {} : orig; if (typeof orig == &apos;object&apos;) { function add(o, key, value) { if (is(o, Array)) o.push(value); else o[key] = value; } jQuery.each(orig, function(key, value) { if (!is(value)) return true; add(obj, key, build(value)); }); } return obj; } this.keys = build(this.keys); return this; }, compact: function() { return this.copy().COMPACT(); }, toString: function() { var i = 0, queryString = [], chunks = [], self = this; var encode = function(str) { str = str + &quot;&quot;; if ($spaces) str = str.replace(/ /g, &quot;+&quot;); return encodeURIComponent(str); }; var addFields = function(arr, key, value) { if (!is(value) || value === false) return; var o = [encode(key)]; if (value !== true) { o.push(&quot;=&quot;); o.push(encode(value)); } arr.push(o.join(&quot;&quot;)); }; var build = function(obj, base) { var newKey = function(key) { return !base || base == &quot;&quot; ? [key].join(&quot;&quot;) : [base, &quot;[&quot;, key, &quot;]&quot;].join(&quot;&quot;); }; jQuery.each(obj, function(key, value) { if (typeof value == &apos;object&apos;) build(value, newKey(key)); else addFields(chunks, newKey(key), value); }); }; build(this.keys); if (chunks.length &gt; 0) queryString.push($hash); queryString.push(chunks.join($separator)); return queryString.join(&quot;&quot;); } }; return new queryObject(location.search, location.hash); }; }(jQuery.query || {}); 在有了这个插件之后我们就可以很轻松地拿到url中的参数了： let vid = $.query.get(&apos;vid&apos;); 拿到参数之后只要像对待普通DOM元素一样对上面视频播放的那个div进行属性的修改，就可以播放不同的视频了。","tags":[{"name":"URL","slug":"URL","permalink":"http://tanyibing.com/tags/URL/"},{"name":"HTTP","slug":"HTTP","permalink":"http://tanyibing.com/tags/HTTP/"}]},{"title":"angular6在使用antd的layout之后没有css样式","date":"2018-08-21T17:37:10.000Z","path":"2018/08/22/angular6在使用antd的layout之后没有css样式/","text":"今天我在使用Angular6安装完antd之后，使用了layout模块，打开之后发现没有样式，最后解决方案如下： 首先我们看看antd的官网： https://ng.ant.design/docs/getting-started/zh 当我们开始使用之前，我们需要引入css全局样式，但是引入的位置不正确就会导致我们的模块没有样式。 解决方案是在全局样式文件style.css的开头引入antd的css @importnode_modules/ng-zorro-antd/src/ng-zorro-antd.min.css 如下图：","tags":[{"name":"Angular","slug":"Angular","permalink":"http://tanyibing.com/tags/Angular/"},{"name":"Typescript","slug":"Typescript","permalink":"http://tanyibing.com/tags/Typescript/"}]},{"title":"JS原型理解","date":"2018-08-08T15:40:45.000Z","path":"2018/08/08/JS原型、原型链/","text":"JS原型和原型链js原型js原型和原型链一直是js中一个难点，也是面试时大概率的问题，看了网上很多的说法，好像都不是那么通俗易懂。我就用简单的方式来介绍介绍，本人是前端菜鸟，说错了欢迎大家提出来。 我理解中的原型是为了继承而产生的，为了防止污染全局变量，我们可以给Person的原型加上一个sayHello方法，这也是最简单的例子（自行脑补代码），这样我们就可以在Person的实例中共享sayHello这个方法。图中的每条线其实都可以用一个属性代替，我画出来你们就一目了然了。 我们可以看到，Person构造函数可以通过prototype属性访问它自己的原型对象的，而实例化出来的对象可以通过_proto_属性访问Peroson构造函数的原型对象._proto_属性其实是非标准的属性，也就是说这是浏览器为了方便才产生的属性，为了什么方便？当然是为了调试的方便啦，所以我们还是尽量不要在代码中使用_proto_，而在调试的时候使用。 js原型链上面给的是一个简单的原型模型，我们知道，原型对象还有一个属性constructor，这个属性就是指向该对象的构造函数的。下面我们需要了解几个概念，以便我们清楚的知道原型链是什么：1.每个构造函数都有原型对象2.每个对象都会有构造函数3.每个构造函数的原型都是一个对象4.那么这个原型对象也会有构造函数5.那么这个原型对象的构造函数也会有原型对象这样就形成一个链式结构，也就是我们说的原型链 从图中我们就可以清楚的看到一个原型链结构，我们的原型其实也是个对象，对象也是由对象构造函数生成的，其实也就是之前的原型三角结构的延伸，可以看到，所有的对象的原型最顶层就是null。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tanyibing.com/tags/JavaScript/"}]},{"title":"SEO自学笔记（五）","date":"2018-08-02T14:03:55.000Z","path":"2018/08/02/SEO自学笔记（五）/","text":"SEO自学笔记（五）今天主要的工作是优化公司官网的关键词，去外网发外链，虽然心中质疑如今外链对优化还有没有作用，但还是做了，也积累了一些国外的外链资源，有需要的小伙伴也可以私聊我，我的企鹅是820567197.言归正传，SEO抽空看了一些，只有一张笔记，发出来：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"SEO自学笔记（四）","date":"2018-08-01T13:53:59.000Z","path":"2018/08/01/SEO自学笔记（四）/","text":"SEO自学笔记（四）以下是今天的自学笔记：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"SEO自学笔记（三）","date":"2018-07-31T13:58:21.000Z","path":"2018/07/31/SEO自学笔记（三）/","text":"SEO自学笔记（三）自从github被微软收购之后，我用hexo来写博客就不是那么顺利了，就跟被墙一样，网站打开慢就不说了，昨晚一直hexo d命令报错，害得我把博客迁移了一遍，最后不知道怎么鬼使神差的上传好了。今天上传的时候又遇到了问题，搭了梯子才解决。在这吐槽一下，看到很多人已经把自己的项目都迁走了，感觉github的未来不是那么美好了。 言归正传，再上传一下我今天额外的SEO笔记：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"SEO自学笔记（二）","date":"2018-07-31T13:40:04.000Z","path":"2018/07/31/SEO自学笔记（二）/","text":"SEO自学笔记（二）紧接着第一天的内容，今天的学习笔记如下：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"SEO自学笔记（一）","date":"2018-07-30T14:28:13.000Z","path":"2018/07/30/SEO自学笔记（一）/","text":"SEO自学笔记（一）最近在工作中要求学习一些SEO的技术来给主站进行一定的优化，所以自学了SEO的一些知识，我通过xmind思维导图做了一些笔记，下面就贴出我学习的过程：","tags":[{"name":"SEO","slug":"SEO","permalink":"http://tanyibing.com/tags/SEO/"}]},{"title":"PHP中Session的清除和销毁","date":"2018-03-26T09:48:30.000Z","path":"2018/03/26/PHP中Session的清除和销毁-1/","text":"PHP中session清除和销毁今天在工作中使用session进行用户的登录验证操作，最后要进行用户注销的操作，也就是session的删除，所以查阅文档发现删除会话主要有删除单个会话、删除所有会话和结束当前会话的三种方式，以下就是三种清除session的具体方法： 1.删除单个会话删除单个会话其实就是删单个会话的变量，和数组的操作一样，直接注销$_SESSION数组的某个元素即可。例如：$_SESSION[“session_name”]变量，可以使用unset()函数，代码如下所示：unset($_SESSION[&quot;session_name&quot;]);注意：在使用unset()时，要注意$SESSION数组中的元素一定不可以可略，即不可以一次注销整个数组，这样会禁止整个会话的功能，一旦使用会将全局变量$_SESSION全局变量销毁，而且没有办法将其恢复，用户也不可能再注册$_SESSION变量，在php文档中也可以发现警告 Caution请不要使用unset($、_SESSION)来释放整个$_SESSION， 因为它将会禁用通过全局$_SESSION去注册会话变量 2.删除所有会话如果想吧某个用户在session中注册的所有变量都删除，也就是一次删除所有的会话变量，可以通过将一个空数组赋值给$_SESSION来实现，其代码显示如下：$_SESSION = array();也可以使用session_unset 来释放所有的会话变量,使用方法如下：void session_unset ( void )该函数没有返回值。 3.删除当前会话如果整个会话已经结束，首先应该注销所有会话变量，然后使用 session_destroy()函数清除结束当前的会话，并清空会话中的所有资源，彻底销毁 Session，其代码如下显示：session_destroy()；相对于 session_start() 函数 （创建 Session 文件），session_destroy()函数用来关闭 Session 的运作 （删除 Session 文件），如果成功则返回 TURE，销毁 Session 资料失败则返回 FALSE。但该函数并不会释放和当前 Session 相关的变量，也不会删除保存在客户端 Cookie 中的 Session ID 。下面是我在代码中实际使用的方法： if(isset($_SESSION['username'])){ $_SESSION = array(); if(isset($_COOKIE[session_name()])){ setcookie(session_name(),'',time()-3600); } session_destroy(); }","tags":[{"name":"php","slug":"php","permalink":"http://tanyibing.com/tags/php/"},{"name":"session","slug":"session","permalink":"http://tanyibing.com/tags/session/"}]},{"title":"从输入URL到页面渲染完成","date":"2018-02-20T10:09:24.000Z","path":"2018/02/20/从输入URL到页面渲染完成/","text":"转载自www.chauncywu.com 从输入URL到页面渲染完成原文-英文译文 推荐阅读《图解HTTP》 各种协议与HTTP协议的关系(参照该图理解下文) 0-1 1. 输入URL地址 1-1 2. 浏览器根据域名查询IP地址 2-1 从要访问的域名中获取IP地址，DNS查询的步骤如下： 从浏览器缓存中查询。浏览器会存储一定时间的DNS记录，操作系统不会告诉浏览器每个DNS记录的保存时限，不同浏览器设置保存时限为一个固定值（不同浏览器情况不同，一般在2-30分钟）。 从操作系统缓存中查询。如果浏览器中没有包含想要的缓存记录，那浏览器就会发起操作系统请求，继续查询操作系统缓存 从路由器中查询DNS缓存。请求持续发送到你的路由，它通常会有自己的DNS缓存。 从ISP中查询DNS缓存。下一个被查询地方是ISP缓存DNS的服务器。 域名服务器递归查询。首先从root域名服务器中查询如.com域名服务器，然后逐步向前查询，.com顶级域名服务器到Facebook的域名服务器。一般来说，.com级别的都已经在缓存中了，所以一般不会进行对root域名服务器的查询。下面给出一张递归查询的图。扩展什么是DNS？DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 DNS查询的两种方式：递归查询和迭代查询1、递归解析当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。 2-2 2、迭代解析当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。 2-3 DNS域名称空间的组织方式我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例: 2-4 3. 浏览器发送HTTP请求到web服务器向 http://facebook.com/ 发出GET请求 HTTP请求报文在请求中，HTTP报文首部由方法、URI、HTTP版本、HTTP首部字段等构成。 3-1 确保可靠性的TCP协议 3-2 扩展TCP三次握手 第一次握手： 客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认； 第二次握手： 服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。 第三次握手： 客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。 3-2-1 为什需要三次握手？《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。 假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。 例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。 TCP四次挥手 第一次挥手： Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手： Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手： Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手： Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 3-2-2 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 什么是反向代理？客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 3-2-3 负责传输的IP协议 IP间的通信依赖MAC地址 ARP协议：(Address Resolution Protocol)用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址 3-3 4. Facebook服务器返回一个永久重定向响应服务器会发送一个301永久重定向响应来告诉浏览器访问 http://www.facebook.com/ 而不是 http://facebook.com/。 为什么服务器坚持重定向而不是直接给予浏览器用户需要的结果，这有很多有意思原因: 一个原因是搜索引擎排名，如果有两个URLs指向同一个页面，比如 http://www.igoro.com/ 和 http://igoro.com/ ,搜索引擎会认为这是两个不同的网站，结果他们两个每个都有一部分访问量，但是也只能拥有更低的搜索引擎排名。如果使用了301定位，搜索引擎将会识别重定向，进而将同一来源的多个链接算作一个。 另一个原因是，同样的内容多个URLs还不利于缓存，同样的内容拥有多个名字，潜在造成缓存浪费。 扩展301和302的区别：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO 302好于301 重定向原因： 网站调整（如改变网页目录结构）； 网页被移到一个新地址； 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 什么时候进行301或者302跳转呢？当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。 清晰明确而言：使用301跳转的大概场景如下： 1、 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。2、 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。3、 空间服务器不稳定，换空间的时候。 5. 浏览器会跟踪重定向地址浏览器知道了 http://www.facebook.com/ 是真正应该访问的URL，所以就发送了另外一个GET请求。 6. 服务器处理请求服务器会接收这个GET请求，并且返回一个响应结果 怎么存储数据是每个动态网站都会面临的有趣难题小网站会经常有一个SQL数据库来存储他们的数据，但是网站存储数据量过大或者流量过大后就必须将数据库分布在多台机器，解决的方法有很多种 包括sharding(在主键基础上划分表到多个数据库中)，复制和使用简化的弱语义一致性数据库 推迟一些任务到批处理作业是廉价保持数据更新的的一种技术。例如，Facebook必须尽快更新新闻供应，但数据支持的“你可能认识的人”功能可能只需要每晚进行更新（作者猜测是这样）。批处理作业的更新导致存在一些旧的相对不重要的数据，但是使数据更新更快更简单。 7.服务器返回一个HTML响应123456789101112HTTP/1.1 200 OKCache-Control: private, no-store, no-cache, must-revalidate, post-check=0, pre-check=0Expires: Sat, 01 Jan 2000 00:00:00 GMTP3P: CP=&quot;DSP LAW&quot;Pragma: no-cacheContent-Encoding: gzipContent-Type: text/html; charset=utf-8X-Cnection: closeTransfer-Encoding: chunkedDate: Fri, 12 Feb 2010 09:05:55 GMT... 整个完整的响应是36KB，其中大部分处理后由blob类型传送内容编码头部告诉浏览器响应体使用了gzip压缩算法。在解析blob后，你就会看到你期望的HTML了。 8. 浏览器开始渲染HTML在浏览器接收完整HTML文件前，浏览器就开始渲染页面了。 9. 浏览器发送嵌入在HTML中的对象的请求随着浏览器渲染HTML，浏览器会注意到有些标签需要请求其他URLs的资源，浏览器将会发送一个GET请求来重新获取每个文件 。 10. 浏览器发送异步请求在web2.0时代，即使在页面渲染后客户端还是持续与服务器端通信。 例如，当你的朋友上线或下线时，Facebook聊天功能将会持续更新你已经登录的朋友列表。为了更新这个列表，你浏览器上运行的JS将会发送异步请求到服务器，异步请求是发送给特殊URL的GET或POST请求。在Facebook的例子中，客户端会发送一个POST请求到 http://www.facebook.com/ajax/chat/buddy_list.php ，获取你在线的朋友列表 这个模式被称为AJAX，是“Asynchronous JavaScript And XML”,的缩写，虽然不太清楚为什么服务器必须将响应格式化为xml。 相关阅读：当你访问淘宝的时候，发生了什么？","tags":[{"name":"URL","slug":"URL","permalink":"http://tanyibing.com/tags/URL/"},{"name":"HTTP","slug":"HTTP","permalink":"http://tanyibing.com/tags/HTTP/"}]},{"title":"hadoop单机安装、运行","date":"2017-12-28T14:28:13.000Z","path":"2017/12/28/hadoop单机配置、运行/","text":"云计算 hadoop 配置步骤Tanyibing，this is for 14级软件工程专业，My email &#116;&#97;&#x6e;&#121;&#105;&#x62;&#105;&#110;&#103;&#49;&#57;&#x39;&#53;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d; link Hadoop环境准备工作 VMware版本VMware-workstation-full-12.5.7-5813279(版本自己选择)Xshell5自己选择是否使用 CentOS版本CentOS-6.4-x86_64-bin-DVD1(本人的是64位，其他版本未测试) Hadoop版本hadoop-2.6.0(安装完系统后直接命令行安装) jdk版本jdk-8u45-linux-x64.tar 需要了解基本的linux和vim的使用 资源位置百度网盘:https://pan.baidu.com/s/1i5s2eFF密码:n3jq CentOS镜像下载地址http://mirror.nsc.liu.se/centos-store/6.4/isos/x86_64/ VMware安装以及CentOS安装VMware安装步骤省略CentOS安装1.点击新建虚拟机 2.选择稍后操作系统 3.选择64位CentOS的系统 4.选择安装位置(最好不要放C盘) 5.默认配置就好，点击下一步 6.点击自定义硬件 7.配置虚拟机的内存，我们的实验1G即可，电脑好的选择2G也可 8.选择虚拟化cpu(使用本机真实cpu) 9.选择加载的镜像，选1盘，如果自己下载的话2盘是一些软件，不需要加载 10.桥接和NAT模式才能上网，我选择的是桥接(使用自己的真实网卡) 11.选择第一个选项(安装或升级系统) 12.这一步选skip跳过即可 13.选择简体中文，点击下一步 14.选择英国美式，下一步 15.选择默认的基本存储设备，下一步 16.必须选择是，忽略所有数据 17.默认就行，下一步 18.自己输入密码（6位，字母数字），选择无论如何使用(因为我设置的密码不是安全的) 19.为了更好的了解linux，现在进行分盘(挂载点) 20.首先分给/home 2G(选择空闲点击创建，然后挂载点选/home) 21.必须给/boot一定的空间(系统使用，及时其他出现问题也能正常开机，一般200M即可) 22.接着给swap分4G空间(不是在挂载点选择，而是在文件系统类型选择) 23.最后所有空间都分给 / 挂载点(根目录) 24.选择将修改写入磁盘，点击下一步 25.默认即可，下一步 26.由于minimal存在一些兼容问题，选择Basic Server版本，点击下一步进行安装 27.安装完成，点击重新引导，重启虚拟机 28.先输入用户名：root 回车，接着输入密码(密码是不显示的，输入完回车就行) 29.现在一个虚拟机就终于安装完成了 jdk、hadoop的解压1.将jdk解压到 /opt 下 tar -zxvf jdk-8u45-linux-x64.tar.gz -C /opt 注意如果你的虚拟机自带openjdk需要先卸载 rpm -qa | grep java //检查机器上的jdk 应该显示这一类的结果： java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64 javapackages-tools-3.4.1-11.el7.noarch java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64 使用下面的命令删除上面列出的内容： rpm -e --nodeps + 上面出现的内容 2.将hadoop解压到 /opt/hadoop 下 tar -zxvf hadoop-2.6.0-x64.tar.gz -C /opt/hadoop 没有hadoop目录的自己在/opt下创建 在/root /hadoop/目录下，建立tmp、hdfs/name、hdfs/data目录，执行如下命令： mkdir /opt/hadoop/tmp mkdir /opt/hadoop/hdfs mkdir /opt/hadoop/hdfs/data mkdir /opt/hadoop/hdfs/name ##ssh的安装、无密码配置 1.检查 CentOS 默认已安装了 SSH client、SSH server，打开终端执行如下命令进行检验： rpm -qa | grep ssh 成功显示出client、server版本的话则无需安装，若需要安装，则可以通过 yum 进行安装（安装过程中会让你输入 [y/N]，输入 y 即可）： sudo yum install openssh-clients sudo yum install openssh-server 接着执行如下命令测试一下 SSH 是否可用： ssh localhost 此时会有提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码，就登陆到本机了。 2.ssh无密码配置 上面这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。 首先输入 exit 退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中： exit # 退出刚才的 ssh localhost cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 会有提示，都按回车就可以 cat id_rsa.pub &gt;&gt; authorized_keys # 加入授权 chmod 600 ./authorized_keys # 修改文件权限 此时再用 ssh localhost 命令，无需输入密码就可以直接登陆了。 jdk、hadoop的配置1.环境变量的配置 vim /etc/profile加入如下配置： export JAVA_HOME=/opt/jdk1.8.0_45 export HADOOP_HOME=/opt/hadoop/hadoop-2.6.0 exportCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar: exportPATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin: 保存后，不要忘记执行如下命令使配置生效： source /etc/profile 2.hosts文件的修改 vim /etc/hosts最后加入如下内容： 127.0.0.1 自己的主机名 3.hadoop配置 进入/opt/hadoop/hadoop-2.6.0/etc/hadoop目录 1)在hadoop-env.sh和 yarn-env.sh的开头添加如下环境变量(一定要添加) export JAVA_HOME=/opt/jdk1.8.0_45 2)配置core-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;description&gt;HDFS的URI，文件系统://namenode标识:端口号&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/tmp&lt;/value&gt; &lt;description&gt;namenode上本地的hadoop临时文件夹&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 3)配置hdfs-site.xml &lt;configuration&gt; &lt;!—hdfs-site.xml--&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/hdfs/name&lt;/value&gt; &lt;description&gt;namenode上存储hdfs名字空间元数据 &lt;/descriptio&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/hdfs/data&lt;/value&gt; &lt;description&gt;datanode上数据块的物理存储位置&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;description&gt;副本个数，配置默认是3,应小于datanode机器数量&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 4)配置yarn-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;${yarn.resourcemanager.hostname}:8099&lt;/value&gt; &lt;/propert&gt; &lt;/configuration&gt; #####4)配置mapred-site.xml 目录下没有mapred-site.xml，只有mapred-site.xml.template(模板)，所以将其复制重命名为mapred-site.xml: cp mapred-site.xml.template mapred-site.xml 然后再配置mapred-site.xml: &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 5)配置yarn-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;${yarn.resourcemanager.hostname}:8099&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 启动hadoop1.格式化namenode hadoop namenode -format 2.启动hadoop start-all.sh 3.启动验证 jps 应该输出如下的结果: 在浏览器输入虚拟机的ip地址，例如：192.168.31.0:50070，能够打开如下网页： 至此，hadoop环境安装已经全部完成 hadoop下运行MapReduce代码在此，使用WordCount的旧版api版本演示 1.编写WordCount.java,包含Mapper类和Reducec类 import java.io.IOException; import java.util.StringTokenizer; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.input.TextInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat; public class WordCount { public static class WordCountMap extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; { private final IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { String line = value.toString(); StringTokenizer token = new StringTokenizer(line); while (token.hasMoreTokens()) { word.set(token.nextToken()); context.write(word, one); } } } public static class WordCountReduce extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; { public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { int sum = 0; for (IntWritable val : values) { sum += val.get(); } context.write(key, new IntWritable(sum)); } } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); Job job = new Job(conf); job.setJarByClass(WordCount.class); job.setJobName(&quot;wordcount&quot;); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); job.setMapperClass(WordCountMap.class); job.setReducerClass(WordCountReduce.class); job.setInputFormatClass(TextInputFormat.class); job.setOutputFormatClass(TextOutputFormat.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); job.waitForCompletion(true); } } 2.编译WordCount.java文件 javac WordCount.java -d 指定到你希望的目录下 此时目录下应该多出三个文件：WordCount.class、WordCount$WordCountMap.class、WordCount$WordCountReduce.class 3.将以上的.class文件打包成.Jar文件 jar -cvf 你希望指定的名字.jar *.class 4.创建hadoop的input和output目录 hadoop fs -mkdir input hadoop fs -mkdir output 5.将要输入的文件放进input目录下 hadoop fs -put 你要放入计算的文件 input 6.hadoop运行Jar文件并计算结果 hadoop jar WordCount.Jar WordCount input/file output (hadoop jar jar包路径 执行的主函数名(主类名，main方法所在类名) 输入目录名 输出目录名) 7.查看结果(前提是不报错，成功运行完) 成功的话，output目录下会出现一个part-r-xxxx hadoop fs cat output/part-r-00000 #查看提交的结果 附(xshell5、VMware tools使用安装)VMware Tools可以让虚拟机和你的主机之间共享一个文件夹,具体操作不在此赘述，点击链接自行按教程安装VMware Tools安装 Xshell可以方便开发,具体操作不在此赘述，点击链接自行按教程安装Xshell安装","tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://tanyibing.com/tags/hadoop/"},{"name":"java","slug":"java","permalink":"http://tanyibing.com/tags/java/"},{"name":"VMware","slug":"VMware","permalink":"http://tanyibing.com/tags/VMware/"},{"name":"Windows","slug":"Windows","permalink":"http://tanyibing.com/tags/Windows/"}]},{"title":"Hello World","date":"2017-12-25T02:28:13.000Z","path":"2017/12/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://tanyibing.com/tags/hexo/"}]}]